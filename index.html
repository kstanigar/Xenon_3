<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Top-Scrolling Flying Game</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }

    #container {
      position: relative;
      width: 800px;
      margin: 0 auto;
    }

    canvas {
      border: 1px solid black;
      display: block;
      background-color: rgb(0, 0, 0);
    }

    #startButton {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 10px 20px;
      font-size: 16px;
      z-index: 2;
      cursor: pointer;
    }

    #intro {
      color: white;
      position: absolute;
      top: 10px;
      left: 30%;
      font-size: 18px;
      z-index: 2;

    }

    #score {
      color: white;
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 18px;
      z-index: 2;
    }

    #gameOver {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 24px;
      color: red;
      text-shadow: 0 0 10px red;
      z-index: 2;
      text-align: center;
      line-height: 1.6;
    }

    #levelDisplay {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      color: #00FF00;
      text-shadow: 0 0 20px #00FF00, 0 0 40px #00FF00;
      z-index: 3;
      animation: levelPulse 0.5s ease-in-out;
    }

    @keyframes levelPulse {
      0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
      50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }

    #levelIndicator {
      color: white;
      position: absolute;
      top: 60px;
      right: 10px;
      font-size: 16px;
      z-index: 2;
    }

    #health {
      color: white;
      position: absolute;
      top: 60px;
      left: 10px;
      font-size: 16px;
      z-index: 2;
    }

    #powerupDisplay {
      display: none;
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 32px;
      color: #FFD700;
      text-shadow: 0 0 15px #FFD700;
      z-index: 3;
    }

    #bonusDisplay {
      display: none;
      position: absolute;
      top: 65%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 32px;
      color: #FFD700;
      text-shadow: 0 0 15px #FFD700;
      z-index: 3;
    }

    #pauseDisplay {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      color: #FFFFFF;
      text-shadow: 0 0 20px #FFFFFF;
      z-index: 4;
    }

    #victory {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 18px;
      color: #00FF00;
      text-shadow: 0 0 15px #00FF00;
      z-index: 3;
      text-align: center;
      line-height: 1.4;
      max-width: 700px;
      width: 90%;
    }
  </style>
</head>

<body>
  <div id="container">

    <button id="startButton">Start Game</button>
    <div id="intro">Use Left/Right Arrows and Spacebar to Shoot</div>
    <div id="score">Score: 0</div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="levelIndicator">Level: 1</div>
    <div id="health">Health: 50</div>
    <div id="levelDisplay">Level 1</div>
    <div id="powerupDisplay"></div>
    <div id="bonusDisplay"></div>
    <div id="pauseDisplay">PAUSED</div>
    <div id="victory">Thank you for playing!<br><br>Special thanks to Modmotif for the music.<br><br>Please submit your email to download the song for remix.<br><br>&copy; 2026</div>
    <div id="gameOver">Game Over!</div>
  </div>

  <script>
    // ============================================
    // GAME CONFIGURATION - Easy to modify values
    // ============================================
    var CONFIG = {
      // Player settings
      playerSpeed: 5,
      bulletSpeed: 12,
      startingHealth: 50,
      maxHealth: 100,

      // Damage values
      enemyBulletDamage: 10,
      enemyCollisionDamage: 20,
      bossDamage: 25,
      healthPowerupAmount: 10,

      // Enemy settings
      enemyBaseSpeed: 1.5,
      enemySpeedIncrease: 0.3,
      enemySpawnRate: 0.01,
      enemySpawnIncrease: 0.005,

      // Enemy shooting (starts at level 2)
      enemyShootChance: 0.005,
      enemyShootIncrease: 0.002,
      enemyBulletSpeed: 5,

      // Boss settings
      boss1ScoreThreshold: 400,
      boss2ScoreThreshold: 1200,
      bossHealth: 50,
      bossSpeed: 1,
      bossShootChance: 0.02,

      // Level thresholds
      // Levels 1-4: original enemies, Boss 1 at 400
      // Levels 5-8: red enemies (start after Boss 1 defeated)
      // Level thresholds are calculated dynamically after Boss 1
      levelThresholds: [0, 100, 200, 300],

      // Red level speed multiplier (faster than original)
      redLevelSpeedMultiplier: 1.3,

      // Power-up settings
      powerupSpeed: 4,  // Twice as fast as enemies
      powerupSpawnChance: 0.003,

      // Boss minion settings
      bossMinionSpeed: 2,
      bossMinionSpawnChance: 0.015,

      // Enemy types per level (each level adds a new enemy)
      levelEnemyTypes: {
        1: ['enemy1'],
        2: ['enemy1', 'enemy2'],
        3: ['enemy1', 'enemy2', 'enemy3'],
        4: ['enemy1', 'enemy2', 'enemy3', 'enemy4'],
        5: ['enemy1_red'],
        6: ['enemy1_red', 'enemy2_red'],
        7: ['enemy1_red', 'enemy2_red', 'enemy3_red'],
        8: ['enemy1_red', 'enemy2_red', 'enemy3_red', 'enemy4_red']
      },

      // Enemies that zigzag
      zigzagEnemies: ['enemy3', 'enemy3_red', 'enemy4_red'],

      // Enemies that move side to side (horizontal)
      sideToSideEnemies: ['enemy2_red']
    };

    // ============================================
    // CANVAS AND IMAGE SETUP
    // ============================================
    var canvas = document.getElementById("gameCanvas");
    var ctx = canvas.getContext("2d");

    var playerImg = new Image();
    playerImg.src = "/Xenon_3/player.png";

    var enemyImg1 = new Image();
    enemyImg1.src = "/Xenon_3/enemy.png";

    var enemyImg2 = new Image();
    enemyImg2.src = "/Xenon_3/enemy2.png";

    var enemyImg3 = new Image();
    enemyImg3.src = "/Xenon_3/enemy3.png";

    var enemyImg4 = new Image();
    enemyImg4.src = "/Xenon_3/enemy4.png";

    var bossImg = new Image();
    bossImg.src = "/Xenon_3/Boss.png";

    // Red enemy images (levels 5-8)
    var enemyImg1Red = new Image();
    enemyImg1Red.src = "/Xenon_3/enemy1_Red.png";

    var enemyImg2Red = new Image();
    enemyImg2Red.src = "/Xenon_3/enemy2_Red.png";

    var enemyImg3Red = new Image();
    enemyImg3Red.src = "/Xenon_3/enemy3_Red.png";

    var enemyImg4Red = new Image();
    enemyImg4Red.src = "/Xenon_3/enemy4_Red.png";

    var bossImgRed = new Image();
    bossImgRed.src = "/Xenon_3/boss_Red.png";

    // ============================================
    // SOUND SETUP
    // ============================================
    var sounds = {
      playerBullet: new Audio("/Xenon_3/sfx/playerBullet.mp3"),
      playerHit: new Audio("/Xenon_3/sfx/playerHit.mp3"),
      playerDead: new Audio("/Xenon_3/sfx/playerDead.mp3"),
      enemyDead: new Audio("/Xenon_3/sfx/enemyDead.mp3"),
      bossIntro: new Audio("/Xenon_3/sfx/bossIntro.mp3"),
      powerUp: new Audio("/Xenon_3/sfx/powerUp.mp3")
    };

    // Background music (full song, looped)
    var bgMusic = new Audio("/Xenon_3/sfx/NonexFullSong.mp3");
    bgMusic.loop = true;
    bgMusic.volume = 0.79;

    // Credits music
    var creditsMusic = new Audio("/Xenon_3/sfx/NonexFullSong.mp3");
    creditsMusic.volume = 0.79;

    // Set sound effect volumes (all at 0.4)
    sounds.playerBullet.volume = 0.4;
    sounds.playerHit.volume = 0.4;
    sounds.playerDead.volume = 0.4;
    sounds.enemyDead.volume = 0.4;
    sounds.bossIntro.volume = 0.4;
    sounds.powerUp.volume = 0.4;

    var bossIntroInterval = null;

    function playSound(soundName) {
      var sound = sounds[soundName];
      if (sound) {
        sound.currentTime = 0;
        sound.play().catch(function(e) {
          // Ignore autoplay errors
        });
      }
    }

    function startBossMusic() {
      playSound('bossIntro');
      // Repeat every 10 seconds
      bossIntroInterval = setInterval(function() {
        if (bossActive && !gameOver) {
          playSound('bossIntro');
        }
      }, 10000);
    }

    function stopBossMusic() {
      if (bossIntroInterval) {
        clearInterval(bossIntroInterval);
        bossIntroInterval = null;
      }
      sounds.bossIntro.pause();
      sounds.bossIntro.currentTime = 0;
    }

    function startBackgroundMusic() {
      bgMusic.currentTime = 0;
      bgMusic.play().catch(function(e) {
        // Ignore autoplay errors
      });
    }

    function stopBackgroundMusic() {
      bgMusic.pause();
      bgMusic.currentTime = 0;
    }

    function startCreditsMusic() {
      creditsMusic.currentTime = 0;
      creditsMusic.play().catch(function(e) {
        // Ignore autoplay errors
      });
    }

    function stopCreditsMusic() {
      creditsMusic.pause();
      creditsMusic.currentTime = 0;
    }

    function submitEmail() {
      var email = document.getElementById('emailInput').value;
      if (email && email.includes('@')) {
        // Store email locally (can be sent to server later)
        var emails = JSON.parse(localStorage.getItem('xenonEmails')) || [];
        emails.push(email);
        localStorage.setItem('xenonEmails', JSON.stringify(emails));
        alert('Thank you for subscribing!');
        document.getElementById('emailInput').value = '';
      } else {
        alert('Please enter a valid email address.');
      }
    }

    // ============================================
    // GAME STATE
    // ============================================
    var player = {
      x: canvas.width / 2,
      y: canvas.height - 80,
      width: 75,
      height: 75
    };

    var playerBullets = [];
    var enemyBullets = [];
    var enemies = [];
    var powerups = [];
    var score = 0;
    var level = 1;
    var health = 50;
    var gameOver = true;
    var paused = false;
    // Load top 10 high scores from localStorage
    var highScores = JSON.parse(localStorage.getItem('xenonHighScores')) || [];

    function addHighScore(newScore) {
      highScores.push(newScore);
      highScores.sort(function(a, b) { return b - a; }); // Sort descending
      highScores = highScores.slice(0, 10); // Keep only top 10
      localStorage.setItem('xenonHighScores', JSON.stringify(highScores));
    }

    function isTopTenScore(newScore) {
      if (highScores.length < 10) return true;
      return newScore > highScores[highScores.length - 1];
    }

    function getScoreRank(newScore) {
      for (var i = 0; i < highScores.length; i++) {
        if (newScore >= highScores[i]) return i + 1;
      }
      return highScores.length + 1;
    }
    var rightPressed = false;
    var leftPressed = false;

    // Power-up state
    var hasDoubleLaser = false;
    var powerupsSpawnedThisLevel = { health: false, doubleLaser: false, shield: false };

    // Player blink state (when damaged)
    var playerBlinking = false;
    var playerBlinkTimer = 0;
    var playerVisible = true;

    // Boss state
    var boss = null;
    var bossActive = false;
    var bossDefeated = false;
    var bossMinions = [];  // Side-scrolling enemies during boss fight
    var bossBlinking = false;
    var bossBlinkTimer = 0;
    var bossVisible = true;

    // Game phase tracking
    var currentBoss = 0;        // 0 = no boss yet, 1 = boss 1, 2 = boss 2
    var boss1Defeated = false;
    var boss2Defeated = false;
    var redPhase = false;       // True after boss 1 is defeated (levels 5-8)
    var redPhaseStartScore = 0; // Score when red phase started

    // Power-up types
    var POWERUP_TYPES = {
      HEALTH: 'health',       // Red diamond - restore health
      DOUBLE_LASER: 'laser',  // Purple hexagon - double lasers
      SHIELD: 'shield'        // Aqua triangle - damage shield
    };

    // Shield state
    var hasShield = false;
    var shieldHitsRemaining = 0;

    // ============================================
    // UI UPDATES
    // ============================================
    function updateUI() {
      document.getElementById("score").innerText = "Score: " + score;
      document.getElementById("levelIndicator").innerText = "Level: " + level;
      document.getElementById("health").innerText = "Health: " + health;
    }

    function showAnnouncement(element, text, duration) {
      var el = document.getElementById(element);
      el.innerText = text;
      el.style.display = "block";
      setTimeout(function() {
        el.style.display = "none";
      }, duration || 2000);
    }

    // ============================================
    // LEVEL MANAGEMENT
    // ============================================
    function checkLevelUp() {
      // Wave-based system handles level progression via advanceLevel()
      // This function is only used for additional score tracking
      updateUI();
    }

    // ============================================
    // POWER-UP SYSTEM
    // ============================================
    function createPowerup(type) {
      // Double laser moves slightly slower (3.5) than health powerup (4)
      var speed = (type === POWERUP_TYPES.DOUBLE_LASER) ? 3.5 : CONFIG.powerupSpeed;
      var width = 40;
      var height = 40;

      // Find a non-overlapping spawn position (try up to 10 times)
      var x, y = 0;
      var attempts = 0;
      do {
        x = Math.random() * (canvas.width - width);
        attempts++;
      } while (isOverlappingEnemy(x, y, width, height) && attempts < 10);

      // If we couldn't find a spot, skip spawning
      if (attempts >= 10 && isOverlappingEnemy(x, y, width, height)) {
        return false; // Indicate spawn failed
      }

      powerups.push({
        x: x,
        y: y,
        width: width,
        height: height,
        speed: speed,
        type: type
      });
      return true;
    }

    // 123 BPM = 488ms per beat
    var BPM_INTERVAL = 60000 / 123; // ~488ms

    function drawPowerup(powerup) {
      var time = Date.now();

      // Breathing effect for power-ups (every 2 beats)
      var breathInterval = BPM_INTERVAL * 2;
      var breathProgress = (time % breathInterval) / breathInterval;
      var breathScale = 1 + Math.sin(breathProgress * Math.PI) * 0.15;

      var baseW = powerup.width;
      var baseH = powerup.height;
      var w = baseW * breathScale;
      var h = baseH * breathScale;
      var x = powerup.x + baseW / 2 - w / 2;
      var y = powerup.y + baseH / 2 - h / 2;
      var cx = powerup.x + baseW / 2;
      var cy = powerup.y + baseH / 2;

      // Pulsing ripple effect at 123 BPM
      var beatPhase = (time % BPM_INTERVAL) / BPM_INTERVAL; // 0 to 1

      // Draw expanding ripple rings
      var maxRippleRadius = w * 1.5;
      var rippleRadius = beatPhase * maxRippleRadius;
      var rippleAlpha = 1 - beatPhase; // Fade out as it expands

      ctx.save();
      ctx.beginPath();
      ctx.arc(cx, cy, rippleRadius, 0, Math.PI * 2);
      var rippleColor;
      if (powerup.type === POWERUP_TYPES.HEALTH) {
        rippleColor = 'rgba(255, 50, 50, ' + (rippleAlpha * 0.5) + ')';
      } else if (powerup.type === POWERUP_TYPES.SHIELD) {
        rippleColor = 'rgba(0, 255, 255, ' + (rippleAlpha * 0.5) + ')';
      } else {
        rippleColor = 'rgba(153, 50, 255, ' + (rippleAlpha * 0.5) + ')';
      }
      ctx.strokeStyle = rippleColor;
      ctx.lineWidth = 3;
      ctx.stroke();

      // Second ripple (offset by half beat)
      var beatPhase2 = ((time + BPM_INTERVAL / 2) % BPM_INTERVAL) / BPM_INTERVAL;
      var rippleRadius2 = beatPhase2 * maxRippleRadius;
      var rippleAlpha2 = 1 - beatPhase2;

      ctx.beginPath();
      ctx.arc(cx, cy, rippleRadius2, 0, Math.PI * 2);
      var rippleColor2;
      if (powerup.type === POWERUP_TYPES.HEALTH) {
        rippleColor2 = 'rgba(255, 50, 50, ' + (rippleAlpha2 * 0.3) + ')';
      } else if (powerup.type === POWERUP_TYPES.SHIELD) {
        rippleColor2 = 'rgba(0, 255, 255, ' + (rippleAlpha2 * 0.3) + ')';
      } else {
        rippleColor2 = 'rgba(153, 50, 255, ' + (rippleAlpha2 * 0.3) + ')';
      }
      ctx.strokeStyle = rippleColor2;
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();

      if (powerup.type === POWERUP_TYPES.HEALTH) {
        // Red diamond - restore health
        ctx.fillStyle = "#FF3333";
        ctx.beginPath();
        ctx.moveTo(x + w / 2, y);
        ctx.lineTo(x + w, y + h / 2);
        ctx.lineTo(x + w / 2, y + h);
        ctx.lineTo(x, y + h / 2);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = "#FF0000";
        ctx.lineWidth = 2;
        ctx.stroke();
        // Plus symbol
        ctx.fillStyle = "#FFFFFF";
        ctx.fillRect(x + w/2 - 2, y + h/4, 4, h/2);
        ctx.fillRect(x + w/4, y + h/2 - 2, w/2, 4);
      } else if (powerup.type === POWERUP_TYPES.DOUBLE_LASER) {
        // Purple hexagon - double laser
        var cx = x + w / 2;
        var cy = y + h / 2;
        var r = w / 2;
        ctx.fillStyle = "#9933FF";
        ctx.beginPath();
        for (var i = 0; i < 6; i++) {
          var angle = (Math.PI / 3) * i - Math.PI / 2;
          var px = cx + r * Math.cos(angle);
          var py = cy + r * Math.sin(angle);
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = "#6600CC";
        ctx.lineWidth = 3;
        ctx.stroke();
        // Double bar symbol
        ctx.fillStyle = "#FFFFFF";
        ctx.fillRect(cx - 8, cy - 8, 4, 16);
        ctx.fillRect(cx + 4, cy - 8, 4, 16);
      } else if (powerup.type === POWERUP_TYPES.SHIELD) {
        // Aqua triangle - shield
        ctx.fillStyle = "#00FFFF";
        ctx.beginPath();
        ctx.moveTo(x + w / 2, y);
        ctx.lineTo(x + w, y + h);
        ctx.lineTo(x, y + h);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = "#00CCCC";
        ctx.lineWidth = 2;
        ctx.stroke();
        // Shield symbol (small circle)
        ctx.beginPath();
        ctx.arc(x + w / 2, y + h / 2 + 5, 8, 0, Math.PI * 2);
        ctx.strokeStyle = "#FFFFFF";
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }

    function collectPowerup(powerup) {
      playSound('powerUp');
      if (powerup.type === POWERUP_TYPES.HEALTH) {
        health = Math.min(health + CONFIG.healthPowerupAmount, CONFIG.maxHealth);
        updateUI();
        showAnnouncement("powerupDisplay", "+10 Health!", 1500);
      } else if (powerup.type === POWERUP_TYPES.DOUBLE_LASER) {
        hasDoubleLaser = true;
        showAnnouncement("powerupDisplay", "Double Laser!", 1500);
      } else if (powerup.type === POWERUP_TYPES.SHIELD) {
        hasShield = true;
        shieldHitsRemaining = 5;
        showAnnouncement("powerupDisplay", "Shield Active!", 1500);
      }
    }

    function trySpawnPowerup() {
      if (Math.random() > CONFIG.powerupSpawnChance) return;

      // Randomly choose which power-up to try spawning
      // Only mark as spawned if createPowerup succeeds
      var rand = Math.random();
      if (!powerupsSpawnedThisLevel.health && rand < 0.4) {
        if (createPowerup(POWERUP_TYPES.HEALTH)) {
          powerupsSpawnedThisLevel.health = true;
        }
      } else if (!powerupsSpawnedThisLevel.doubleLaser && rand < 0.7) {
        if (createPowerup(POWERUP_TYPES.DOUBLE_LASER)) {
          powerupsSpawnedThisLevel.doubleLaser = true;
        }
      } else if (!powerupsSpawnedThisLevel.shield && level >= 3) {
        // Shield only spawns level 3+
        if (createPowerup(POWERUP_TYPES.SHIELD)) {
          powerupsSpawnedThisLevel.shield = true;
        }
      } else if (!powerupsSpawnedThisLevel.health) {
        if (createPowerup(POWERUP_TYPES.HEALTH)) {
          powerupsSpawnedThisLevel.health = true;
        }
      }
    }

    // ============================================
    // ENEMY CREATION AND DRAWING
    // ============================================
    function getEnemyType() {
      var availableTypes = CONFIG.levelEnemyTypes[level] || CONFIG.levelEnemyTypes[4];
      var randomIndex = Math.floor(Math.random() * availableTypes.length);
      return availableTypes[randomIndex];
    }

    function isOverlappingEnemy(x, y, width, height) {
      for (var i = 0; i < enemies.length; i++) {
        var e = enemies[i];
        if (x < e.x + e.width &&
            x + width > e.x &&
            y < e.y + e.height &&
            y + height > e.y) {
          return true;
        }
      }
      return false;
    }

    function createEnemy() {
      var speedVariation = 1;
      var effectiveLevel = redPhase ? (level - 4) : level; // Levels 5-8 map to 1-4 for speed calc
      var baseSpeed = CONFIG.enemyBaseSpeed + (effectiveLevel - 1) * CONFIG.enemySpeedIncrease;

      // Apply speed multiplier for red phase
      if (redPhase) {
        baseSpeed *= CONFIG.redLevelSpeedMultiplier;
      }

      var enemyType = getEnemyType();
      var width = 50;
      var height = 50;

      // enemy2_red is 50% smaller than normal enemies
      if (enemyType === 'enemy2_red') {
        width = 29;
        height = 29;
      }

      // Find a non-overlapping spawn position (try up to 10 times)
      var x, y = 0;
      var attempts = 0;
      do {
        x = Math.random() * (canvas.width - width);
        attempts++;
      } while (isOverlappingEnemy(x, y, width, height) && attempts < 10);

      // If we couldn't find a spot after 10 tries, skip spawning
      if (attempts >= 10 && isOverlappingEnemy(x, y, width, height)) {
        return;
      }

      var enemy = {
        x: x,
        y: y,
        width: width,
        height: height,
        baseWidth: width,
        baseHeight: height,
        speed: baseSpeed + Math.random() * speedVariation,
        type: enemyType,
        breathPhase: Math.random() // Random phase for breathing effect
      };

      // Add zigzag properties based on config
      if (CONFIG.zigzagEnemies.indexOf(enemyType) !== -1) {
        enemy.zigzag = true;
        enemy.zigzagDirection = Math.random() < 0.5 ? 1 : -1;
        enemy.zigzagSpeed = 2;
        enemy.zigzagTimer = 0;
        enemy.zigzagInterval = 30; // Change direction every 30 frames
      }

      // Add side-to-side movement for enemy2_red
      if (CONFIG.sideToSideEnemies.indexOf(enemyType) !== -1) {
        enemy.sideToSide = true;
        enemy.horizontalDirection = Math.random() < 0.5 ? 1 : -1;
        enemy.horizontalSpeed = 2;
      }

      enemies.push(enemy);
    }

    // ============================================
    // WAVE-BASED FORMATION SYSTEM
    // ============================================

    // Wave state tracking
    var currentWave = 0;        // 0 = not started, 1 = wave 1, 2 = wave 2
    var waveEnemiesRemaining = 0;
    var waveInProgress = false;
    var waveCooldown = false;
    var lastWaveEndTime = 0;
    var morphStartTime = 0;     // When current formation started (for morphing)
    var currentMorphShape = 0;  // Index into formation shapes

    // Formation shapes (marching band style - 2D, well-spaced, no overlap)
    // Each shape returns positions that flow smoothly into the next via rotation
    var FORMATION_SHAPES = {
      // Circle - evenly spaced around perimeter
      circle: function(count) {
        var positions = [];
        for (var i = 0; i < count; i++) {
          var angle = (i / count) * Math.PI * 2 - Math.PI / 2; // Start from top
          positions.push({ x: Math.cos(angle), y: Math.sin(angle) });
        }
        return positions;
      },
      // Oval - wider than tall
      oval: function(count) {
        var positions = [];
        for (var i = 0; i < count; i++) {
          var angle = (i / count) * Math.PI * 2 - Math.PI / 2;
          positions.push({ x: Math.cos(angle) * 1.4, y: Math.sin(angle) * 0.6 });
        }
        return positions;
      },
      // Horizontal line - spread across
      lineH: function(count) {
        var positions = [];
        var spacing = 2 / (count - 1 || 1);
        for (var i = 0; i < count; i++) {
          positions.push({ x: -1 + i * spacing, y: 0 });
        }
        return positions;
      },
      // Vertical line
      lineV: function(count) {
        var positions = [];
        var spacing = 1.6 / (count - 1 || 1);
        for (var i = 0; i < count; i++) {
          positions.push({ x: 0, y: -0.8 + i * spacing });
        }
        return positions;
      },
      // V formation (like flying geese) - pointing down
      veeDown: function(count) {
        var positions = [];
        var half = Math.floor(count / 2);
        var spacing = 0.22;
        for (var i = 0; i < count; i++) {
          if (i < half) {
            // Left arm
            positions.push({ x: -spacing * (half - i), y: -spacing * (half - i) });
          } else if (i === half && count % 2 === 1) {
            // Center point (tip)
            positions.push({ x: 0, y: 0 });
          } else {
            // Right arm
            var idx = i - half - (count % 2 === 1 ? 1 : 0);
            positions.push({ x: spacing * (idx + 1), y: -spacing * (idx + 1) });
          }
        }
        return positions;
      },
      // Inverted V (pointing up)
      veeUp: function(count) {
        var positions = [];
        var half = Math.floor(count / 2);
        var spacing = 0.22;
        for (var i = 0; i < count; i++) {
          if (i < half) {
            positions.push({ x: -spacing * (half - i), y: spacing * (half - i) });
          } else if (i === half && count % 2 === 1) {
            positions.push({ x: 0, y: 0 });
          } else {
            var idx = i - half - (count % 2 === 1 ? 1 : 0);
            positions.push({ x: spacing * (idx + 1), y: spacing * (idx + 1) });
          }
        }
        return positions;
      },
      // Square outline (not filled)
      square: function(count) {
        var positions = [];
        var perSide = Math.floor(count / 4);
        var remainder = count % 4;
        var idx = 0;
        // Top edge (left to right)
        for (var i = 0; i < perSide + (remainder > 0 ? 1 : 0); i++) {
          var t = i / (perSide + (remainder > 0 ? 1 : 0));
          positions.push({ x: -1 + t * 2, y: -0.7 });
          idx++;
        }
        // Right edge (top to bottom)
        for (var i = 0; i < perSide + (remainder > 1 ? 1 : 0); i++) {
          var t = i / (perSide + (remainder > 1 ? 1 : 0));
          positions.push({ x: 1, y: -0.7 + t * 1.4 });
          idx++;
        }
        // Bottom edge (right to left)
        for (var i = 0; i < perSide + (remainder > 2 ? 1 : 0); i++) {
          var t = i / (perSide + (remainder > 2 ? 1 : 0));
          positions.push({ x: 1 - t * 2, y: 0.7 });
          idx++;
        }
        // Left edge (bottom to top)
        while (idx < count) {
          var remaining = count - idx;
          var t = (idx - (count - remaining)) / remaining;
          positions.push({ x: -1, y: 0.7 - t * 1.4 });
          idx++;
        }
        return positions;
      },
      // Diamond (square rotated 45Â°)
      diamond: function(count) {
        var positions = [];
        var perSide = Math.floor(count / 4);
        var remainder = count % 4;
        var size = 0.9;
        var idx = 0;
        // Top-right edge
        for (var i = 0; i < perSide + (remainder > 0 ? 1 : 0); i++) {
          var t = i / (perSide + (remainder > 0 ? 1 : 0));
          positions.push({ x: t * size, y: -size + t * size });
          idx++;
        }
        // Bottom-right edge
        for (var i = 0; i < perSide + (remainder > 1 ? 1 : 0); i++) {
          var t = i / (perSide + (remainder > 1 ? 1 : 0));
          positions.push({ x: size - t * size, y: t * size });
          idx++;
        }
        // Bottom-left edge
        for (var i = 0; i < perSide + (remainder > 2 ? 1 : 0); i++) {
          var t = i / (perSide + (remainder > 2 ? 1 : 0));
          positions.push({ x: -t * size, y: size - t * size });
          idx++;
        }
        // Top-left edge
        while (idx < count) {
          var remaining = count - idx;
          var t = (idx - (count - remaining)) / remaining;
          positions.push({ x: -size + t * size, y: -t * size });
          idx++;
        }
        return positions;
      },
      // Two parallel horizontal lines
      twoLines: function(count) {
        var positions = [];
        var half = Math.floor(count / 2);
        var spacing = 1.8 / (half - 1 || 1);
        // Top line
        for (var i = 0; i < half; i++) {
          positions.push({ x: -0.9 + i * spacing, y: -0.4 });
        }
        // Bottom line
        for (var i = half; i < count; i++) {
          positions.push({ x: -0.9 + (i - half) * spacing, y: 0.4 });
        }
        return positions;
      },
      // Arrow pointing right
      arrowRight: function(count) {
        var positions = [];
        var shaftCount = Math.floor(count * 0.6);
        var headCount = count - shaftCount;
        // Shaft (horizontal line on left)
        var shaftSpacing = 1.2 / (shaftCount - 1 || 1);
        for (var i = 0; i < shaftCount; i++) {
          positions.push({ x: -1 + i * shaftSpacing, y: 0 });
        }
        // Arrow head (V shape on right)
        var headHalf = Math.floor(headCount / 2);
        for (var i = 0; i < headCount; i++) {
          if (i < headHalf) {
            positions.push({ x: 0.4 + (headHalf - i) * 0.18, y: -(headHalf - i) * 0.25 });
          } else {
            var idx = i - headHalf;
            positions.push({ x: 0.4 + idx * 0.18, y: idx * 0.25 });
          }
        }
        return positions;
      },
      // Crescent/arc shape
      arc: function(count) {
        var positions = [];
        for (var i = 0; i < count; i++) {
          var angle = Math.PI * 0.2 + (i / (count - 1 || 1)) * Math.PI * 0.6;
          positions.push({ x: Math.cos(angle) * 1.2, y: Math.sin(angle) * 0.8 - 0.2 });
        }
        return positions;
      }
    };

    // Level definitions with 2 waves each
    // Shapes flow into each other via rotation (marching band style)
    var LEVEL_WAVES = {
      1: {
        waves: [
          { count: 6, shapes: ['lineH', 'veeDown', 'lineH'], enemyTypes: ['enemy1'] },
          { count: 8, shapes: ['circle', 'oval', 'circle'], enemyTypes: ['enemy1'] }
        ]
      },
      2: {
        waves: [
          { count: 8, shapes: ['veeDown', 'lineH', 'veeUp'], enemyTypes: ['enemy1', 'enemy2'] },
          { count: 8, shapes: ['square', 'diamond', 'square'], enemyTypes: ['enemy1', 'enemy2'] }
        ]
      },
      3: {
        waves: [
          { count: 8, shapes: ['circle', 'square', 'diamond', 'circle'], enemyTypes: ['enemy1', 'enemy2', 'enemy3'] },
          { count: 10, shapes: ['twoLines', 'lineH', 'arc', 'twoLines'], enemyTypes: ['enemy1', 'enemy2', 'enemy3'] }
        ]
      },
      4: {
        waves: [
          { count: 10, shapes: ['diamond', 'square', 'lineH', 'veeDown', 'diamond'], enemyTypes: ['enemy1', 'enemy2', 'enemy3', 'enemy4'] },
          { count: 12, shapes: ['circle', 'oval', 'lineH', 'oval', 'circle'], enemyTypes: ['enemy1', 'enemy2', 'enemy3', 'enemy4'] }
        ]
      },
      5: {
        waves: [
          { count: 8, shapes: ['lineH', 'arc', 'lineH'], enemyTypes: ['enemy1_red'] },
          { count: 8, shapes: ['veeUp', 'lineH', 'veeDown'], enemyTypes: ['enemy1_red'] }
        ]
      },
      6: {
        waves: [
          { count: 8, shapes: ['circle', 'diamond', 'circle'], enemyTypes: ['enemy1_red', 'enemy2_red'] },
          { count: 10, shapes: ['square', 'lineH', 'twoLines', 'square'], enemyTypes: ['enemy1_red', 'enemy2_red'] }
        ]
      },
      7: {
        waves: [
          { count: 10, shapes: ['arrowRight', 'lineH', 'veeDown', 'arrowRight'], enemyTypes: ['enemy1_red', 'enemy2_red', 'enemy3_red'] },
          { count: 12, shapes: ['diamond', 'oval', 'diamond', 'square'], enemyTypes: ['enemy1_red', 'enemy2_red', 'enemy3_red'] }
        ]
      },
      8: {
        waves: [
          { count: 12, shapes: ['circle', 'square', 'diamond', 'lineH', 'circle'], enemyTypes: ['enemy1_red', 'enemy2_red', 'enemy3_red', 'enemy4_red'] },
          { count: 12, shapes: ['twoLines', 'veeDown', 'lineV', 'veeUp', 'twoLines'], enemyTypes: ['enemy1_red', 'enemy2_red', 'enemy3_red', 'enemy4_red'] }
        ]
      }
    };

    // Filler enemy tracking
    var lastFillerTime = 0;
    var fillerCooldown = 1500; // 1.5 seconds between fillers

    function startWave(waveNum) {
      var levelData = LEVEL_WAVES[level];
      if (!levelData || waveNum > levelData.waves.length) return;

      currentWave = waveNum;
      waveInProgress = true;
      waveCooldown = false;
      morphStartTime = Date.now();
      currentMorphShape = 0;

      // Reset formation rotation for new wave
      formationRotation = 0;
      targetFormationRotation = 0;

      var waveData = levelData.waves[waveNum - 1];
      waveEnemiesRemaining = waveData.count;

      spawnMorphingFormation(waveData);

      showAnnouncement("levelDisplay", "Wave " + waveNum, 1500);
    }

    function spawnMorphingFormation(waveData) {
      var count = waveData.count;
      var centerX = canvas.width / 2;
      var targetY = 160;
      // Larger spread to prevent overlap (60px enemy + 20px gap minimum)
      var spreadRadius = 160;

      // Get initial shape positions
      var shapeFunc = FORMATION_SHAPES[waveData.shapes[0]];
      var positions = shapeFunc(count);

      for (var i = 0; i < count; i++) {
        (function(index, pos) {
          setTimeout(function() {
            if (gameOver) return;

            var enemyType = waveData.enemyTypes[Math.floor(Math.random() * waveData.enemyTypes.length)];
            var width = 50;
            var height = 50;

            // enemy2_red is smaller
            if (enemyType === 'enemy2_red') {
              width = 35;
              height = 35;
            }

            var enemy = {
              x: centerX + pos.x * spreadRadius - width/2,
              y: -50 - (index * 25),
              width: width,
              height: height,
              baseWidth: width,
              baseHeight: height,
              speed: 2.5,
              type: enemyType,
              formation: true,
              formationType: 'morphing',
              targetY: targetY,
              reachedTarget: false,
              formationIndex: index,
              formationCount: count,
              waveShapes: waveData.shapes,
              spreadRadius: spreadRadius,
              centerX: centerX,
              centerY: targetY,
              // For breathing effect - phase offset based on position
              breathPhase: index * 0.12,
              // Morphing position tracking
              currentPos: { x: pos.x, y: pos.y },
              targetPos: { x: pos.x, y: pos.y },
              // Formation rotation angle
              rotationAngle: 0
            };

            enemies.push(enemy);
          }, index * 60);
        })(i, positions[i]);
      }
    }

    // Track formation rotation for smooth transitions
    var formationRotation = 0;
    var targetFormationRotation = 0;

    function updateMorphingFormation(time) {
      // Check for morph every 8 beats (~4 seconds at 123 BPM)
      var morphInterval = BPM_INTERVAL * 8;
      var timeSinceStart = time - morphStartTime;
      var newShapeIndex = Math.floor(timeSinceStart / morphInterval);

      // Get formation enemies
      var formationEnemies = enemies.filter(function(e) { return e.formation && e.formationType === 'morphing'; });
      if (formationEnemies.length === 0) return;

      var waveShapes = formationEnemies[0].waveShapes;
      if (!waveShapes) return;

      // Cycle through shapes
      newShapeIndex = newShapeIndex % waveShapes.length;

      // If shape changed, update target positions and add rotation
      if (newShapeIndex !== currentMorphShape) {
        currentMorphShape = newShapeIndex;
        var shapeName = waveShapes[newShapeIndex];
        var shapeFunc = FORMATION_SHAPES[shapeName];
        var count = formationEnemies[0].formationCount;
        var newPositions = shapeFunc(count);

        // Add rotation for visual interest (rotate 15-30 degrees on each morph)
        targetFormationRotation += (Math.PI / 12) + Math.random() * (Math.PI / 12);

        // Update target positions for each enemy
        formationEnemies.forEach(function(enemy, idx) {
          if (newPositions[idx]) {
            enemy.targetPos = { x: newPositions[idx].x, y: newPositions[idx].y };
          }
        });
      }

      // Smoothly rotate formation toward target rotation
      var rotationLerpSpeed = 0.03;
      formationRotation += (targetFormationRotation - formationRotation) * rotationLerpSpeed;

      // Lerp speed for position transitions
      var lerpSpeed = 0.04;

      formationEnemies.forEach(function(enemy) {
        if (!enemy.reachedTarget) return;

        // Smoothly interpolate position
        enemy.currentPos.x += (enemy.targetPos.x - enemy.currentPos.x) * lerpSpeed;
        enemy.currentPos.y += (enemy.targetPos.y - enemy.currentPos.y) * lerpSpeed;

        // Apply formation rotation to the position
        var rotatedX = enemy.currentPos.x * Math.cos(formationRotation) - enemy.currentPos.y * Math.sin(formationRotation);
        var rotatedY = enemy.currentPos.x * Math.sin(formationRotation) + enemy.currentPos.y * Math.cos(formationRotation);

        // Calculate actual position with larger vertical spread
        var baseX = enemy.centerX + rotatedX * enemy.spreadRadius;
        var baseY = enemy.centerY + rotatedY * enemy.spreadRadius * 0.7;

        enemy.x = baseX - enemy.width / 2;
        enemy.y = baseY - enemy.height / 2;

        // Keep in bounds with padding
        if (enemy.x < 20) enemy.x = 20;
        if (enemy.x > canvas.width - enemy.width - 20) enemy.x = canvas.width - enemy.width - 20;
        if (enemy.y < 30) enemy.y = 30;
        if (enemy.y > canvas.height * 0.5) enemy.y = canvas.height * 0.5;
      });
    }

    function spawnFillerEnemy() {
      if (Date.now() - lastFillerTime < fillerCooldown) return;
      if (Math.random() > 0.25) return; // 25% chance each frame when cooldown is up

      lastFillerTime = Date.now();

      var enemyType = getEnemyType();
      var width = 50;
      var height = 50;

      if (enemyType === 'enemy2_red') {
        width = 35;
        height = 35;
      }

      // Check if formations are active - if so, only spawn from sides/corners
      var hasFormation = enemies.some(function(e) { return e.formation; });

      var enemy;
      if (hasFormation) {
        // Spawn from sides or corners only (avoid center where formations are)
        var spawnType = Math.random();

        if (spawnType < 0.5) {
          // Side entry (left or right)
          var fromLeft = Math.random() < 0.5;
          enemy = {
            x: fromLeft ? -width : canvas.width,
            y: 200 + Math.random() * 250, // Lower half to avoid formation
            width: width,
            height: height,
            baseWidth: width,
            baseHeight: height,
            speed: 0,
            horizontalSpeed: CONFIG.enemyBaseSpeed + 0.8,
            horizontalDirection: fromLeft ? 1 : -1,
            type: enemyType,
            formation: false,
            filler: true,
            sideEntry: true,
            breathPhase: Math.random()
          };
        } else {
          // Corner entry (top-left or top-right corners)
          var fromLeftCorner = Math.random() < 0.5;
          enemy = {
            x: fromLeftCorner ? Math.random() * 100 : canvas.width - 100 - width + Math.random() * 100,
            y: -height,
            width: width,
            height: height,
            baseWidth: width,
            baseHeight: height,
            speed: CONFIG.enemyBaseSpeed + 0.5,
            type: enemyType,
            formation: false,
            filler: true,
            breathPhase: Math.random()
          };

          // Add movement behaviors
          if (CONFIG.zigzagEnemies.indexOf(enemyType) !== -1) {
            enemy.zigzag = true;
            enemy.zigzagDirection = fromLeftCorner ? 1 : -1;
            enemy.zigzagSpeed = 2;
            enemy.zigzagTimer = 0;
            enemy.zigzagInterval = 30;
          }
          if (CONFIG.sideToSideEnemies.indexOf(enemyType) !== -1) {
            enemy.sideToSide = true;
            enemy.horizontalDirection = fromLeftCorner ? 1 : -1;
            enemy.horizontalSpeed = 2;
          }
        }
      } else {
        // No formation - can spawn anywhere from top
        enemy = {
          x: Math.random() * (canvas.width - width),
          y: -height,
          width: width,
          height: height,
          baseWidth: width,
          baseHeight: height,
          speed: CONFIG.enemyBaseSpeed + Math.random() * 0.5,
          type: enemyType,
          formation: false,
          filler: true,
          breathPhase: Math.random()
        };

        // Add zigzag for appropriate enemies
        if (CONFIG.zigzagEnemies.indexOf(enemyType) !== -1) {
          enemy.zigzag = true;
          enemy.zigzagDirection = Math.random() < 0.5 ? 1 : -1;
          enemy.zigzagSpeed = 2;
          enemy.zigzagTimer = 0;
          enemy.zigzagInterval = 30;
        }

        // Add side-to-side for enemy2_red
        if (CONFIG.sideToSideEnemies.indexOf(enemyType) !== -1) {
          enemy.sideToSide = true;
          enemy.horizontalDirection = Math.random() < 0.5 ? 1 : -1;
          enemy.horizontalSpeed = 2;
        }
      }

      enemies.push(enemy);
    }

    function checkWaveCompletion() {
      if (!waveInProgress) return;

      // Count remaining formation enemies
      var formationCount = enemies.filter(function(e) { return e.formation; }).length;

      if (formationCount === 0) {
        waveInProgress = false;
        waveCooldown = true;
        lastWaveEndTime = Date.now();

        var levelData = LEVEL_WAVES[level];
        if (currentWave < levelData.waves.length) {
          // Start next wave after delay
          setTimeout(function() {
            if (!gameOver && !bossActive) {
              startWave(currentWave + 1);
            }
          }, 3000);
        } else {
          // Level complete - advance to next level or boss
          setTimeout(function() {
            if (!gameOver && !bossActive) {
              advanceLevel();
            }
          }, 2000);
        }
      }
    }

    function advanceLevel() {
      // Check for boss triggers
      if (!redPhase && level >= 4 && score >= CONFIG.boss1ScoreThreshold && !boss1Defeated) {
        currentBoss = 1;
        spawnBoss();
        return;
      }

      if (redPhase && level >= 8 && score >= CONFIG.boss2ScoreThreshold && !boss2Defeated) {
        currentBoss = 2;
        spawnBoss();
        return;
      }

      // Advance to next level
      var nextLevel = level + 1;

      // Handle level caps
      if (!redPhase && nextLevel > 4) {
        // Wait for boss 1
        return;
      }
      if (redPhase && nextLevel > 8) {
        // Wait for boss 2
        return;
      }

      level = nextLevel;
      currentWave = 0;
      powerupsSpawnedThisLevel = { health: false, doubleLaser: false, shield: false };
      updateUI();
      showAnnouncement("levelDisplay", "Level " + level, 2000);

      // Start first wave of new level
      setTimeout(function() {
        if (!gameOver && !bossActive) {
          startWave(1);
        }
      }, 2500);
    }

    // Legacy formation functions (kept for boss fight variety)
    function spawnSpiralFormation() {
      var enemyType = getEnemyType();
      var count = 6;
      var centerX = canvas.width / 2;
      var targetY = 150;

      for (var i = 0; i < count; i++) {
        (function(index) {
          setTimeout(function() {
            var angle = (index / count) * Math.PI * 2;

            var enemy = {
              x: centerX,
              y: -50 - (index * 30),
              width: 50,
              height: 50,
              baseWidth: 50,
              baseHeight: 50,
              speed: 2,
              type: enemyType,
              formation: true,
              formationType: 'spiral',
              targetY: targetY,
              reachedTarget: false,
              spiralAngle: angle,
              spiralBaseRadius: 80,
              spiralCenterX: centerX,
              spiralCenterY: targetY,
              breathPhase: index * 0.3
            };
            enemies.push(enemy);
          }, index * 150);
        })(i);
      }
    }

    function spawnPincerFormation() {
      var enemyType = getEnemyType();
      var count = 3;
      var targetY = 120;

      for (var i = 0; i < count; i++) {
        (function(index) {
          setTimeout(function() {
            var enemy = {
              x: -50,
              y: targetY + index * 70,
              width: 50,
              height: 50,
              baseWidth: 50,
              baseHeight: 50,
              speed: 0,
              type: enemyType,
              formation: true,
              formationType: 'pincer',
              pincer: true,
              pincerSide: 'left',
              pincerSpeed: 3,
              pincerTargetX: 150,
              pincerBaseX: 150,
              reachedTarget: false,
              breathPhase: index * 0.4
            };
            enemies.push(enemy);
          }, index * 200);
        })(i);
      }

      for (var i = 0; i < count; i++) {
        (function(index) {
          setTimeout(function() {
            var enemy = {
              x: canvas.width,
              y: targetY + index * 70,
              width: 50,
              height: 50,
              baseWidth: 50,
              baseHeight: 50,
              speed: 0,
              type: enemyType,
              formation: true,
              formationType: 'pincer',
              pincer: true,
              pincerSide: 'right',
              pincerSpeed: 3,
              pincerTargetX: canvas.width - 200,
              pincerBaseX: canvas.width - 200,
              reachedTarget: false,
              breathPhase: index * 0.4
            };
            enemies.push(enemy);
          }, index * 200);
        })(i);
      }
    }

    function spawnSineWaveFormation() {
      var enemyType = getEnemyType();
      var count = 8;
      var targetY = 100;

      for (var i = 0; i < count; i++) {
        (function(index) {
          setTimeout(function() {
            var enemy = {
              x: 50 + index * ((canvas.width - 100) / count),
              y: -50,
              width: 50,
              height: 50,
              baseWidth: 50,
              baseHeight: 50,
              speed: 2,
              type: enemyType,
              formation: true,
              formationType: 'sineWave',
              sineWave: true,
              targetY: targetY,
              reachedTarget: false,
              sinePhase: index * 0.8,
              sineAmplitude: 60,
              baseX: 50 + index * ((canvas.width - 100) / count),
              baseY: targetY,
              breathPhase: index * 0.2
            };
            enemies.push(enemy);
          }, index * 100);
        })(i);
      }
    }

    function drawEnemy(enemy) {
      var img;
      switch (enemy.type) {
        case 'enemy1': img = enemyImg1; break;
        case 'enemy2': img = enemyImg2; break;
        case 'enemy3': img = enemyImg3; break;
        case 'enemy4': img = enemyImg4; break;
        case 'enemy1_red': img = enemyImg1Red; break;
        case 'enemy2_red': img = enemyImg2Red; break;
        case 'enemy3_red': img = enemyImg3Red; break;
        case 'enemy4_red': img = enemyImg4Red; break;
        default: img = enemyImg1;
      }

      var time = Date.now();
      var cx = enemy.x + enemy.width / 2;
      var cy = enemy.y + enemy.height / 2;

      // Breathing effect - ONLY for enemy2 and enemy2_red
      var drawWidth = enemy.baseWidth || enemy.width;
      var drawHeight = enemy.baseHeight || enemy.height;

      if (enemy.type === 'enemy2' || enemy.type === 'enemy2_red') {
        var breathInterval = BPM_INTERVAL * 2;
        var breathPhaseOffset = (enemy.breathPhase || 0) * breathInterval;
        var breathProgress = ((time + breathPhaseOffset) % breathInterval) / breathInterval;
        var breathScale = 1 + Math.sin(breathProgress * Math.PI) * 0.18;
        drawWidth = drawWidth * breathScale;
        drawHeight = drawHeight * breathScale;
      }

      var drawX = cx - drawWidth / 2;
      var drawY = cy - drawHeight / 2;

      // Draw ripple effect for all enemies at 123 BPM
      var beatPhase = (time % BPM_INTERVAL) / BPM_INTERVAL;
      var maxRipple = enemy.width * 1.0;
      var rippleRadius = beatPhase * maxRipple;
      var rippleAlpha = 1 - beatPhase;

      // Different colors based on enemy type
      var rippleColor;
      if (enemy.type.indexOf('_red') !== -1) {
        rippleColor = 'rgba(255, 80, 80, ' + (rippleAlpha * 0.4) + ')';
      } else if (enemy.type === 'enemy1') {
        rippleColor = 'rgba(100, 255, 100, ' + (rippleAlpha * 0.4) + ')';
      } else if (enemy.type === 'enemy2') {
        rippleColor = 'rgba(100, 200, 255, ' + (rippleAlpha * 0.4) + ')';
      } else if (enemy.type === 'enemy3') {
        rippleColor = 'rgba(255, 200, 100, ' + (rippleAlpha * 0.4) + ')';
      } else {
        rippleColor = 'rgba(200, 100, 255, ' + (rippleAlpha * 0.4) + ')';
      }

      ctx.save();
      ctx.beginPath();
      ctx.arc(cx, cy, rippleRadius, 0, Math.PI * 2);
      ctx.strokeStyle = rippleColor;
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();

      // Draw enemy
      ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
    }

    // ============================================
    // BOSS SYSTEM
    // ============================================
    // Boss orbiting soldiers
    var bossOrbiters = [];
    var maxOrbiters = 5;
    var orbiterRespawnDelay = 3000; // 3 seconds to respawn
    var lastOrbiterDeathTime = 0;
    var orbitersInitialized = false;

    // Smart filler management
    var maxBossFillers = 6;
    var lastBossFillerBeat = 0;
    var bossFillerBeatInterval = 4; // Spawn every 4 beats

    function spawnBoss() {
      bossActive = true;
      enemies = []; // Clear regular enemies
      bossMinions = []; // Clear any existing minions
      bossOrbiters = []; // Clear orbiters
      orbitersInitialized = false;
      showAnnouncement("levelDisplay", "BOSS!", 2000);
      startBossMusic();

      boss = {
        x: canvas.width / 2 - 75,
        y: -150,
        width: 150,
        height: 150,
        health: CONFIG.bossHealth,
        maxHealth: CONFIG.bossHealth,
        speed: CONFIG.bossSpeed,
        direction: 1,
        verticalDirection: 1, // For red boss vertical movement
        entering: true,
        isRedBoss: (currentBoss === 2) // Track which boss type
      };
    }

    function initBossOrbiters() {
      if (orbitersInitialized) return;
      orbitersInitialized = true;

      var orbiterCount = boss.isRedBoss ? 6 : 4;
      maxOrbiters = orbiterCount;

      for (var i = 0; i < orbiterCount; i++) {
        spawnOrbiter(i, orbiterCount);
      }
    }

    function spawnOrbiter(index, total) {
      var angle = (index / total) * Math.PI * 2;
      var enemyType = boss.isRedBoss ? 'enemy1_red' : 'enemy1';

      bossOrbiters.push({
        angle: angle,
        baseRadius: 120,
        width: 40,
        height: 40,
        baseWidth: 40,
        baseHeight: 40,
        type: enemyType,
        index: index,
        total: total,
        breathPhase: index * 0.2,
        alive: true
      });
    }

    function updateBossOrbiters() {
      if (!boss || boss.entering) return;

      // Initialize orbiters once boss has entered
      if (!orbitersInitialized) {
        initBossOrbiters();
      }

      var time = Date.now();
      var bossCx = boss.x + boss.width / 2;
      var bossCy = boss.y + boss.height / 2;

      // BPM-synced orbit radius pulsing
      var beatPhase = (time % BPM_INTERVAL) / BPM_INTERVAL;
      var radiusPulse = 1 + Math.sin(beatPhase * Math.PI * 2) * 0.15;

      // Rotation speed synced to BPM (one full rotation every 8 beats)
      var rotationSpeed = (Math.PI * 2) / (BPM_INTERVAL * 8);
      var baseRotation = (time * rotationSpeed) % (Math.PI * 2);

      for (var i = bossOrbiters.length - 1; i >= 0; i--) {
        var orbiter = bossOrbiters[i];
        if (!orbiter.alive) continue;

        // Calculate position
        var currentAngle = baseRotation + orbiter.angle;
        var currentRadius = orbiter.baseRadius * radiusPulse;

        var orbiterX = bossCx + Math.cos(currentAngle) * currentRadius - orbiter.width / 2;
        var orbiterY = bossCy + Math.sin(currentAngle) * currentRadius - orbiter.height / 2;

        // Store position for collision detection
        orbiter.x = orbiterX;
        orbiter.y = orbiterY;

        // Draw orbiter (no breathing - only enemy2 types breathe)
        var drawWidth = orbiter.baseWidth;
        var drawHeight = orbiter.baseHeight;
        var drawX = orbiterX;
        var drawY = orbiterY;

        // Draw ripple
        var ripplePhase = (time % BPM_INTERVAL) / BPM_INTERVAL;
        var maxRipple = drawWidth * 0.8;
        var rippleRadius = ripplePhase * maxRipple;
        var rippleAlpha = 1 - ripplePhase;

        ctx.save();
        ctx.beginPath();
        ctx.arc(orbiterX + orbiter.width / 2, orbiterY + orbiter.height / 2, rippleRadius, 0, Math.PI * 2);
        var rippleColor = boss.isRedBoss ?
          'rgba(255, 100, 100, ' + (rippleAlpha * 0.5) + ')' :
          'rgba(100, 255, 100, ' + (rippleAlpha * 0.5) + ')';
        ctx.strokeStyle = rippleColor;
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.restore();

        // Draw orbiter image
        var img = boss.isRedBoss ? enemyImg1Red : enemyImg1;
        ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);

        // Orbiter shooting (lower chance than boss)
        if (Math.random() < 0.008) {
          enemyBullets.push({
            x: Math.floor(orbiterX + orbiter.width / 2 - 2),
            y: Math.floor(orbiterY + orbiter.height),
            width: 5,
            height: 10,
            speed: CONFIG.enemyBulletSpeed
          });
        }

        // Check collision with player bullets
        for (var j = playerBullets.length - 1; j >= 0; j--) {
          var bullet = playerBullets[j];
          if (bullet.x < orbiter.x + orbiter.width &&
              bullet.x + bullet.width > orbiter.x &&
              bullet.y < orbiter.y + orbiter.height &&
              bullet.y + bullet.height > orbiter.y) {
            playerBullets.splice(j, 1);
            orbiter.alive = false;
            bossOrbiters.splice(i, 1);
            score += 15; // Slightly more than regular enemies
            updateUI();
            playSound('enemyDead');
            lastOrbiterDeathTime = time;
            break;
          }
        }

        // Check collision with player
        if (orbiter.alive &&
            player.x < orbiter.x + orbiter.width &&
            player.x + player.width > orbiter.x &&
            player.y < orbiter.y + orbiter.height &&
            player.y + player.height > orbiter.y) {
          orbiter.alive = false;
          bossOrbiters.splice(i, 1);
          playerTakeDamage(CONFIG.enemyCollisionDamage);
          lastOrbiterDeathTime = time;
          if (gameOver) return true;
        }
      }

      // Respawn orbiters after delay
      if (bossOrbiters.length < maxOrbiters && time - lastOrbiterDeathTime > orbiterRespawnDelay) {
        // Find missing index
        var existingIndices = bossOrbiters.map(function(o) { return o.index; });
        for (var i = 0; i < maxOrbiters; i++) {
          if (existingIndices.indexOf(i) === -1) {
            spawnOrbiter(i, maxOrbiters);
            lastOrbiterDeathTime = time; // Reset timer for next respawn
            break;
          }
        }
      }

      return false;
    }

    function spawnBossFiller() {
      var time = Date.now();

      // Count current fillers (non-formation, non-orbiter enemies)
      var currentFillers = enemies.filter(function(e) { return !e.formation; }).length;

      // Don't spawn if at cap
      if (currentFillers >= maxBossFillers) return;

      // Beat-synced spawning (every 4 beats)
      var currentBeat = Math.floor(time / BPM_INTERVAL);
      if (currentBeat - lastBossFillerBeat < bossFillerBeatInterval) return;

      // Dynamic spawn chance based on current count (fewer enemies = higher chance)
      var spawnChance = 0.5 * (1 - currentFillers / maxBossFillers);
      if (Math.random() > spawnChance) return;

      lastBossFillerBeat = currentBeat;

      // Spawn from sides to avoid boss orbit zone
      var fromSide = Math.random() < 0.5;
      var enemyType = boss.isRedBoss ?
        (Math.random() < 0.5 ? 'enemy2_red' : 'enemy3_red') :
        (Math.random() < 0.5 ? 'enemy2' : 'enemy3');

      var width = enemyType === 'enemy2_red' ? 29 : 50;
      var height = enemyType === 'enemy2_red' ? 29 : 50;

      var enemy;
      if (fromSide) {
        // Side entry
        var fromLeft = Math.random() < 0.5;
        enemy = {
          x: fromLeft ? -width : canvas.width,
          y: 150 + Math.random() * 200,
          width: width,
          height: height,
          baseWidth: width,
          baseHeight: height,
          speed: 0,
          horizontalSpeed: CONFIG.enemyBaseSpeed + 0.5,
          horizontalDirection: fromLeft ? 1 : -1,
          type: enemyType,
          formation: false,
          sideEntry: true,
          breathPhase: Math.random()
        };
      } else {
        // Top entry (edges only, away from boss)
        var spawnX = Math.random() < 0.5 ?
          Math.random() * 150 : // Left edge
          canvas.width - 150 - width + Math.random() * 150; // Right edge

        enemy = {
          x: spawnX,
          y: -height,
          width: width,
          height: height,
          baseWidth: width,
          baseHeight: height,
          speed: CONFIG.enemyBaseSpeed + 0.3,
          type: enemyType,
          formation: false,
          breathPhase: Math.random()
        };

        // Add movement behaviors
        if (CONFIG.zigzagEnemies.indexOf(enemyType) !== -1) {
          enemy.zigzag = true;
          enemy.zigzagDirection = Math.random() < 0.5 ? 1 : -1;
          enemy.zigzagSpeed = 2;
          enemy.zigzagTimer = 0;
          enemy.zigzagInterval = 30;
        }
        if (CONFIG.sideToSideEnemies.indexOf(enemyType) !== -1) {
          enemy.sideToSide = true;
          enemy.horizontalDirection = Math.random() < 0.5 ? 1 : -1;
          enemy.horizontalSpeed = 2;
        }
      }

      enemies.push(enemy);
    }

    function createBossMinion() {
      // Spawn from left or right side randomly
      var fromLeft = Math.random() < 0.5;
      var targetY = 100 + Math.random() * 150; // Stay in upper half

      bossMinions.push({
        x: fromLeft ? -50 : canvas.width,
        y: targetY,
        width: 50,
        height: 50,
        speed: CONFIG.bossMinionSpeed,
        direction: fromLeft ? 1 : -1,
        isRedMinion: (currentBoss === 2) // Track which boss phase
      });
    }

    function updateBossMinions() {
      for (var i = bossMinions.length - 1; i >= 0; i--) {
        var minion = bossMinions[i];

        // Draw minion (enemy2 for boss 1, enemy3_red for boss 2)
        var minionImg = minion.isRedMinion ? enemyImg3Red : enemyImg2;
        ctx.drawImage(minionImg, minion.x, minion.y, minion.width, minion.height);

        // Move horizontally
        minion.x += minion.speed * minion.direction;

        // Remove if off screen on opposite side
        if ((minion.direction > 0 && minion.x > canvas.width) ||
            (minion.direction < 0 && minion.x < -minion.width)) {
          bossMinions.splice(i, 1);
          continue;
        }

        // Check collision with player bullets
        for (var j = playerBullets.length - 1; j >= 0; j--) {
          if (isColliding(playerBullets[j], minion)) {
            playerBullets.splice(j, 1);
            bossMinions.splice(i, 1);
            score += 10;
            updateUI();
            playSound('enemyDead');
            break;
          }
        }
      }

      // Check collision with player (separate loop since array may have changed)
      for (var i = bossMinions.length - 1; i >= 0; i--) {
        if (isColliding(bossMinions[i], player)) {
          bossMinions.splice(i, 1);
          playerTakeDamage(CONFIG.enemyCollisionDamage);
          if (gameOver) return true; // Signal game over
        }
      }

      // Spawn new minions
      if (Math.random() < CONFIG.bossMinionSpawnChance) {
        createBossMinion();
      }

      return false; // Game continues
    }

    function updateBoss() {
      if (!boss) return;

      // Update boss blink effect
      updateBossBlink();

      // Boss entrance animation
      if (boss.entering) {
        boss.y += 1;
        if (boss.y >= 30) {
          boss.entering = false;
        }
      } else {
        // Move side to side
        boss.x += boss.speed * boss.direction;
        if (boss.x <= 0 || boss.x >= canvas.width - boss.width) {
          boss.direction *= -1;
        }

        // Red boss also moves north/south
        if (boss.isRedBoss) {
          boss.y += boss.speed * 0.6 * boss.verticalDirection;
          if (boss.y <= 20) {
            boss.verticalDirection = 1;
          } else if (boss.y >= 100) {
            boss.verticalDirection = -1;
          }
        }

        // Boss shooting
        if (Math.random() < CONFIG.bossShootChance) {
          var bossBulletSpeed = CONFIG.enemyBulletSpeed + 1;
          if (boss.isRedBoss) {
            bossBulletSpeed = CONFIG.enemyBulletSpeed + 3; // Faster for red boss
          }
          enemyBullets.push({
            x: Math.floor(boss.x + boss.width / 2 - 4),
            y: Math.floor(boss.y + boss.height),
            width: 8,
            height: 15,
            speed: bossBulletSpeed,
            isBossBullet: true
          });
        }
      }

      // Draw boss ripple effect at 123 BPM
      var bossCx = boss.x + boss.width / 2;
      var bossCy = boss.y + boss.height / 2;
      var time = Date.now();
      var beatPhase = (time % BPM_INTERVAL) / BPM_INTERVAL;
      var maxBossRipple = boss.width * 0.8;
      var bossRippleRadius = beatPhase * maxBossRipple;
      var bossRippleAlpha = 1 - beatPhase;

      ctx.save();
      ctx.beginPath();
      ctx.arc(bossCx, bossCy, bossRippleRadius, 0, Math.PI * 2);
      var bossRippleColor = boss.isRedBoss ?
        'rgba(255, 50, 50, ' + (bossRippleAlpha * 0.5) + ')' :
        'rgba(50, 255, 50, ' + (bossRippleAlpha * 0.5) + ')';
      ctx.strokeStyle = bossRippleColor;
      ctx.lineWidth = 3;
      ctx.stroke();

      // Second boss ripple
      var beatPhase2 = ((time + BPM_INTERVAL / 2) % BPM_INTERVAL) / BPM_INTERVAL;
      var bossRippleRadius2 = beatPhase2 * maxBossRipple;
      var bossRippleAlpha2 = 1 - beatPhase2;
      ctx.beginPath();
      ctx.arc(bossCx, bossCy, bossRippleRadius2, 0, Math.PI * 2);
      var bossRippleColor2 = boss.isRedBoss ?
        'rgba(255, 50, 50, ' + (bossRippleAlpha2 * 0.3) + ')' :
        'rgba(50, 255, 50, ' + (bossRippleAlpha2 * 0.3) + ')';
      ctx.strokeStyle = bossRippleColor2;
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();

      // Draw boss (only if visible during blink)
      if (bossVisible) {
        var bossImage = boss.isRedBoss ? bossImgRed : bossImg;
        ctx.drawImage(bossImage, boss.x, boss.y, boss.width, boss.height);
      }

      // Draw health bar (always visible)
      var healthPercent = boss.health / boss.maxHealth;
      ctx.fillStyle = "#333";
      ctx.fillRect(boss.x, boss.y - 15, boss.width, 10);
      ctx.fillStyle = healthPercent > 0.3 ? "#00FF00" : "#FF0000";
      ctx.fillRect(boss.x, boss.y - 15, boss.width * healthPercent, 10);
    }

    function damageBoss() {
      if (!boss) return;
      boss.health--;

      // Start boss blinking effect
      bossBlinking = true;
      bossBlinkTimer = 10; // Short blink (10 frames)

      if (boss.health <= 0) {
        // Boss defeated!
        bossActive = false;
        boss = null;
        bossMinions = [];
        bossOrbiters = [];
        orbitersInitialized = false;
        enemies = [];
        stopBossMusic();

        if (currentBoss === 1) {
          // Boss 1 defeated - show victory, then start red phase
          boss1Defeated = true;

          // Calculate bonus and set score to 800
          var bonus = 800 - score;
          if (bonus < 0) bonus = 0;
          score = 800;
          redPhaseStartScore = score;
          updateUI();

          // Show victory message
          showAnnouncement("levelDisplay", "Victory!", 2500);

          // Show bonus in yellow
          setTimeout(function() {
            showAnnouncement("bonusDisplay", "Bonus +" + bonus + "!", 2000);
          }, 500);

          // After delay, start level 5 with wave reset
          setTimeout(function() {
            redPhase = true;
            level = 5;
            currentWave = 0;
            waveInProgress = false;
            waveCooldown = false;
            powerupsSpawnedThisLevel = { health: false, doubleLaser: false, shield: false };
            updateUI();
            showAnnouncement("levelDisplay", "Level 5", 2000);
          }, 3000);
        } else if (currentBoss === 2) {
          // Boss 2 defeated - game complete!
          boss2Defeated = true;
          bossDefeated = true;
          score += 100;
          updateUI();
          showVictory();
        }
      }
    }

    function updateBossBlink() {
      if (bossBlinking) {
        bossBlinkTimer--;
        bossVisible = Math.floor(bossBlinkTimer / 2) % 2 === 0;
        if (bossBlinkTimer <= 0) {
          bossBlinking = false;
          bossVisible = true;
        }
      }
    }

    function showVictory() {
      gameOver = true;
      stopBossMusic();
      stopBackgroundMusic();

      // Clear all game objects from screen
      enemies = [];
      playerBullets = [];
      enemyBullets = [];
      powerups = [];
      bossMinions = [];
      boss = null;

      // Clear the canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Check if top 10 score and save
      var madeTopTen = isTopTenScore(score);
      var rank = getScoreRank(score);
      if (madeTopTen) {
        addHighScore(score);
      }

      // Build victory display
      var victoryEl = document.getElementById("victory");
      var html = "Thank you for playing!<br>";
      html += "Your Score: " + score;
      if (madeTopTen) {
        html += " <span style='color: #FFD700;'>- TOP 10! Rank #" + rank + "</span>";
      }
      html += "<br><br>";
      html += "Special thanks to <a href='https://modmotif.com/' target='_blank' style='color: #FFFFFF; text-decoration: underline;'>Modmotif</a> for the music.<br>";
      html += "Please submit your email to subscribe and download our music:<br>";
      html += "<input type='email' id='emailInput' placeholder='your@email.com' style='padding: 6px; font-size: 14px; width: 180px; border-radius: 4px; border: none; margin-top: 5px;'>";
      html += "<button onclick='submitEmail()' style='padding: 6px 12px; font-size: 14px; margin-left: 5px; border-radius: 4px; border: none; background: #FFD700; cursor: pointer;'>Submit</button>";
      html += "<br><br>&copy; 2026";

      victoryEl.innerHTML = html;
      victoryEl.style.display = "block";
      document.getElementById("startButton").innerText = "Start Game";
      startCreditsMusic();
    }

    // ============================================
    // BULLETS
    // ============================================
    function shootBullet() {
      playSound('playerBullet');
      if (hasDoubleLaser) {
        // Double laser - two side-by-side bullets
        playerBullets.push({
          x: Math.floor(player.x + player.width / 4 - 2),
          y: Math.floor(player.y),
          width: 5,
          height: 10,
          speed: CONFIG.bulletSpeed
        });
        playerBullets.push({
          x: Math.floor(player.x + (player.width * 3 / 4) - 2),
          y: Math.floor(player.y),
          width: 5,
          height: 10,
          speed: CONFIG.bulletSpeed
        });
      } else {
        // Single bullet
        playerBullets.push({
          x: Math.floor(player.x + player.width / 2 - 2),
          y: Math.floor(player.y),
          width: 5,
          height: 10,
          speed: CONFIG.bulletSpeed
        });
      }
    }

    function shootEnemyBullet(enemy) {
      var bulletSpeed = CONFIG.enemyBulletSpeed;
      // 15% faster bullets in red phase
      if (redPhase) {
        bulletSpeed *= 1.4; // 40% faster in red phase
      }
      enemyBullets.push({
        x: Math.floor(enemy.x + enemy.width / 2 - 2),
        y: Math.floor(enemy.y + enemy.height),
        width: 5,
        height: 10,
        speed: bulletSpeed
      });
    }

    // ============================================
    // COLLISION DETECTION
    // ============================================
    function isColliding(a, b) {
      return a.x < b.x + b.width &&
             a.x + a.width > b.x &&
             a.y < b.y + b.height &&
             a.y + a.height > b.y;
    }

    // ============================================
    // PLAYER DAMAGE
    // ============================================
    function playerTakeDamage(damage) {
      // Shield reduces all damage to 5 and protects double laser
      if (hasShield) {
        damage = 5;
        shieldHitsRemaining--;
        if (shieldHitsRemaining <= 0) {
          hasShield = false;
          showAnnouncement("powerupDisplay", "Shield Broken!", 1500);
        } else {
          showAnnouncement("powerupDisplay", "Shield: " + shieldHitsRemaining + " hits left", 800);
        }
      } else {
        // Lose double laser in red phase when hit (only without shield)
        if (redPhase && hasDoubleLaser) {
          hasDoubleLaser = false;
        }
      }

      health -= damage;
      updateUI();

      // Start blinking effect
      playerBlinking = true;
      playerBlinkTimer = 30; // Blink for 30 frames (~0.5 seconds)

      if (health <= 0) {
        health = 0;
        updateUI();
        gameOver = true;
        playSound('playerDead');
        stopBossMusic();
        stopBackgroundMusic();

        // Check if top 10 score and save
        var madeTopTen = isTopTenScore(score);
        var rank = getScoreRank(score);
        if (madeTopTen) {
          addHighScore(score);
        }

        // Build game over display
        var gameOverEl = document.getElementById("gameOver");
        var html = "Game Over!<br><br>Your Score: " + score;
        if (madeTopTen) {
          html += "<br><span style='color: #FFD700;'>TOP 10! Rank #" + rank + "</span>";
        }
        gameOverEl.innerHTML = html;
        gameOverEl.style.display = "block";
        document.getElementById("startButton").innerText = "Start Game";
      } else {
        playSound('playerHit');
      }
    }

    function updatePlayerBlink() {
      if (playerBlinking) {
        playerBlinkTimer--;
        // Toggle visibility every 3 frames
        playerVisible = Math.floor(playerBlinkTimer / 3) % 2 === 0;
        if (playerBlinkTimer <= 0) {
          playerBlinking = false;
          playerVisible = true;
        }
      }
    }

    // ============================================
    // INPUT HANDLING
    // ============================================
    document.addEventListener("keydown", function(e) {
      // Pause toggle (P or Escape)
      if (e.key === "p" || e.key === "P" || e.key === "Escape") {
        if (!gameOver) {
          paused = !paused;
          document.getElementById("pauseDisplay").style.display = paused ? "block" : "none";
          document.getElementById("startButton").innerText = paused ? "Resume" : "Pause";
          if (paused) {
            bgMusic.pause();
          } else {
            bgMusic.play();
          }
        }
        return;
      }

      // Ignore other keys if paused
      if (paused) return;

      if (e.key === "Right" || e.key === "ArrowRight") rightPressed = true;
      else if (e.key === "Left" || e.key === "ArrowLeft") leftPressed = true;
      else if (e.key === " ") {
        e.preventDefault();
        shootBullet();
      }
    });

    document.addEventListener("keyup", function(e) {
      if (e.key === "Right" || e.key === "ArrowRight") rightPressed = false;
      else if (e.key === "Left" || e.key === "ArrowLeft") leftPressed = false;
    });

    // ============================================
    // MAIN GAME LOOP
    // ============================================
    function draw() {
      if (gameOver) return;

      // If paused, just keep the animation frame going but don't update
      if (paused) {
        requestAnimationFrame(draw);
        return;
      }

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Update player blink effect
      updatePlayerBlink();

      // Draw shield ripple effect if active
      if (hasShield) {
        var playerCx = player.x + player.width / 2;
        var playerCy = player.y + player.height / 2;
        var time = Date.now();
        var beatPhase = (time % BPM_INTERVAL) / BPM_INTERVAL;
        var maxShieldRipple = player.width * 0.9;
        var shieldRippleRadius = beatPhase * maxShieldRipple;
        var shieldRippleAlpha = 1 - beatPhase;

        ctx.save();
        ctx.beginPath();
        ctx.arc(playerCx, playerCy, shieldRippleRadius, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(0, 255, 255, ' + (shieldRippleAlpha * 0.6) + ')';
        ctx.lineWidth = 3;
        ctx.stroke();

        // Second ripple
        var beatPhase2 = ((time + BPM_INTERVAL / 2) % BPM_INTERVAL) / BPM_INTERVAL;
        var shieldRippleRadius2 = beatPhase2 * maxShieldRipple;
        var shieldRippleAlpha2 = 1 - beatPhase2;
        ctx.beginPath();
        ctx.arc(playerCx, playerCy, shieldRippleRadius2, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(0, 255, 255, ' + (shieldRippleAlpha2 * 0.4) + ')';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.restore();
      }

      // Draw and move player (only if visible during blink)
      if (playerVisible) {
        ctx.drawImage(playerImg, player.x, player.y, player.width, player.height);
      }
      if (rightPressed && player.x < canvas.width - player.width) {
        player.x += CONFIG.playerSpeed;
      } else if (leftPressed && player.x > 0) {
        player.x -= CONFIG.playerSpeed;
      }

      // Update player bullets
      for (var i = playerBullets.length - 1; i >= 0; i--) {
        var bullet = playerBullets[i];

        ctx.fillStyle = "#00FF00";
        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
        bullet.y -= bullet.speed;

        if (bullet.y < 0) {
          playerBullets.splice(i, 1);
          continue;
        }

        // Check collision with boss
        if (boss && isColliding(bullet, boss)) {
          playerBullets.splice(i, 1);
          damageBoss();
          continue;
        }

        // Check collision with enemies
        for (var j = enemies.length - 1; j >= 0; j--) {
          if (isColliding(bullet, enemies[j])) {
            playerBullets.splice(i, 1);
            enemies.splice(j, 1);
            score += 10;
            updateUI();
            playSound('enemyDead');
            checkLevelUp();
            break;
          }
        }
      }

      // Update enemy bullets
      for (var i = enemyBullets.length - 1; i >= 0; i--) {
        var bullet = enemyBullets[i];

        ctx.fillStyle = "#FF0000";
        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
        bullet.y += bullet.speed;

        if (bullet.y > canvas.height) {
          enemyBullets.splice(i, 1);
          continue;
        }

        if (isColliding(bullet, player)) {
          enemyBullets.splice(i, 1);
          var damage = bullet.isBossBullet ? CONFIG.bossDamage : CONFIG.enemyBulletDamage;
          playerTakeDamage(damage);
          if (gameOver) return;
        }
      }

      // Update power-ups
      for (var i = powerups.length - 1; i >= 0; i--) {
        var powerup = powerups[i];

        drawPowerup(powerup);
        powerup.y += powerup.speed;

        if (powerup.y > canvas.height) {
          powerups.splice(i, 1);
          continue;
        }

        if (isColliding(powerup, player)) {
          collectPowerup(powerup);
          powerups.splice(i, 1);
        }
      }

      // Boss mode
      if (bossActive) {
        updateBoss();

        // Update orbiting soldiers
        var orbiterGameOver = updateBossOrbiters();
        if (orbiterGameOver) return;

        // Update side-scrolling minions (enemy2)
        var minionGameOver = updateBossMinions();
        if (minionGameOver) return;

        // Smart filler spawning (beat-synced, capped)
        spawnBossFiller();

        // Random powerup spawn during boss fight
        if (!powerupsSpawnedThisLevel.health && !powerupsSpawnedThisLevel.doubleLaser) {
          if (Math.random() < 0.0008) {
            var powerupType = Math.random() < 0.6 ? POWERUP_TYPES.HEALTH : POWERUP_TYPES.DOUBLE_LASER;
            if (createPowerup(powerupType)) {
              if (powerupType === POWERUP_TYPES.HEALTH) {
                powerupsSpawnedThisLevel.health = true;
              } else {
                powerupsSpawnedThisLevel.doubleLaser = true;
              }
            }
          }
        }

        // Update filler enemies during boss fight
        for (var i = enemies.length - 1; i >= 0; i--) {
          var enemy = enemies[i];

          drawEnemy(enemy);

          // Side entry enemies move horizontally
          if (enemy.sideEntry) {
            enemy.x += enemy.horizontalSpeed * enemy.horizontalDirection;
            enemy.y += 0.3; // Slight downward drift

            // Remove if crossed screen
            if ((enemy.horizontalDirection > 0 && enemy.x > canvas.width) ||
                (enemy.horizontalDirection < 0 && enemy.x < -enemy.width)) {
              enemies.splice(i, 1);
              continue;
            }
          } else {
            // Top entry enemies
            enemy.y += enemy.speed;

            // Zigzag movement
            if (enemy.zigzag) {
              enemy.x += enemy.zigzagSpeed * enemy.zigzagDirection;
              enemy.zigzagTimer++;
              if (enemy.zigzagTimer >= enemy.zigzagInterval) {
                enemy.zigzagTimer = 0;
                enemy.zigzagDirection *= -1;
              }
              if (enemy.x <= 0) {
                enemy.x = 0;
                enemy.zigzagDirection = 1;
              } else if (enemy.x >= canvas.width - enemy.width) {
                enemy.x = canvas.width - enemy.width;
                enemy.zigzagDirection = -1;
              }
            }

            // Side-to-side movement
            if (enemy.sideToSide) {
              enemy.x += enemy.horizontalSpeed * enemy.horizontalDirection;
              if (enemy.x <= 0) {
                enemy.x = 0;
                enemy.horizontalDirection = 1;
              } else if (enemy.x >= canvas.width - enemy.width) {
                enemy.x = canvas.width - enemy.width;
                enemy.horizontalDirection = -1;
              }
            }
          }

          // Check collision with player
          if (isColliding(enemy, player)) {
            enemies.splice(i, 1);
            playerTakeDamage(CONFIG.enemyCollisionDamage);
            if (gameOver) return;
            continue;
          }

          // Remove if off screen (bottom)
          if (enemy.y > canvas.height) {
            enemies.splice(i, 1);
            continue;
          }

          // Check collision with player bullets
          for (var j = playerBullets.length - 1; j >= 0; j--) {
            if (isColliding(playerBullets[j], enemy)) {
              playerBullets.splice(j, 1);
              enemies.splice(i, 1);
              score += 10;
              updateUI();
              playSound('enemyDead');
              break;
            }
          }
        }

        // Check boss collision with player
        if (boss && isColliding(boss, player)) {
          playerTakeDamage(CONFIG.bossDamage);
          if (gameOver) return;
        }
      } else {
        // Regular enemy mode - wave-based formations
        var time = Date.now();

        // Start first wave if not started
        if (currentWave === 0 && !waveCooldown) {
          startWave(1);
        }

        // Update morphing formations
        if (waveInProgress) {
          updateMorphingFormation(time);
        }

        // Spawn filler enemies for variety (between waves or during)
        spawnFillerEnemy();

        for (var i = enemies.length - 1; i >= 0; i--) {
          var enemy = enemies[i];

          drawEnemy(enemy);

          // Formation enemies (morphing type handled by updateMorphingFormation)
          if (enemy.formation) {
            // Move down until reaching target
            if (!enemy.reachedTarget) {
              enemy.y += enemy.speed;
              if (enemy.y >= enemy.targetY) {
                enemy.y = enemy.targetY;
                enemy.reachedTarget = true;
              }
            }

            // Legacy formation types (spiral, pincer, sineWave) for variety
            var beatPhase = ((time + (enemy.breathPhase || 0) * BPM_INTERVAL) % BPM_INTERVAL) / BPM_INTERVAL;

            if (enemy.formationType === 'spiral' && enemy.reachedTarget) {
              enemy.spiralAngle += 0.02;
              var pulseFactor = 1 + Math.sin(beatPhase * Math.PI * 2) * 0.3;
              var currentRadius = enemy.spiralBaseRadius * pulseFactor;
              enemy.x = enemy.spiralCenterX + Math.cos(enemy.spiralAngle) * currentRadius - enemy.width / 2;
              enemy.y = enemy.spiralCenterY + Math.sin(enemy.spiralAngle) * currentRadius - enemy.height / 2;
            }

            if (enemy.formationType === 'pincer') {
              if (!enemy.reachedTarget) {
                if (enemy.pincerSide === 'left' && enemy.x < enemy.pincerTargetX) {
                  enemy.x += enemy.pincerSpeed;
                  if (enemy.x >= enemy.pincerTargetX) enemy.reachedTarget = true;
                } else if (enemy.pincerSide === 'right' && enemy.x > enemy.pincerTargetX) {
                  enemy.x -= enemy.pincerSpeed;
                  if (enemy.x <= enemy.pincerTargetX) enemy.reachedTarget = true;
                }
              } else {
                var pulseDist = Math.sin(beatPhase * Math.PI * 2) * 30;
                if (enemy.pincerSide === 'left') {
                  enemy.x = enemy.pincerBaseX + pulseDist;
                } else {
                  enemy.x = enemy.pincerBaseX - pulseDist;
                }
              }
            }

            if (enemy.formationType === 'sineWave' && enemy.reachedTarget) {
              var wavePhase = (time / BPM_INTERVAL) * Math.PI * 2;
              enemy.x = enemy.baseX + Math.sin(wavePhase + enemy.sinePhase) * enemy.sineAmplitude;
              var vertBounce = Math.abs(Math.sin(beatPhase * Math.PI)) * 15;
              enemy.y = enemy.baseY + vertBounce;
              if (enemy.x < 0) enemy.x = 0;
              if (enemy.x > canvas.width - enemy.width) enemy.x = canvas.width - enemy.width;
            }

            // Morphing formations are handled by updateMorphingFormation()
          } else {
            // Regular non-formation enemies (fillers)

            // Side entry enemies move horizontally across screen
            if (enemy.sideEntry) {
              enemy.x += enemy.horizontalSpeed * enemy.horizontalDirection;
              enemy.y += 0.3; // Slight downward drift

              // Remove if crossed screen
              if ((enemy.horizontalDirection > 0 && enemy.x > canvas.width) ||
                  (enemy.horizontalDirection < 0 && enemy.x < -enemy.width)) {
                enemies.splice(i, 1);
                continue;
              }
            } else {
              // Top entry enemies move down
              enemy.y += enemy.speed;

              // Zigzag movement
              if (enemy.zigzag) {
                enemy.x += enemy.zigzagSpeed * enemy.zigzagDirection;
                enemy.zigzagTimer++;
                if (enemy.zigzagTimer >= enemy.zigzagInterval) {
                  enemy.zigzagTimer = 0;
                  enemy.zigzagDirection *= -1;
                }
                if (enemy.x <= 0) {
                  enemy.x = 0;
                  enemy.zigzagDirection = 1;
                } else if (enemy.x >= canvas.width - enemy.width) {
                  enemy.x = canvas.width - enemy.width;
                  enemy.zigzagDirection = -1;
                }
              }

              // Side-to-side movement
              if (enemy.sideToSide) {
                enemy.x += enemy.horizontalSpeed * enemy.horizontalDirection;
                if (enemy.x <= 0) {
                  enemy.x = 0;
                  enemy.horizontalDirection = 1;
                } else if (enemy.x >= canvas.width - enemy.width) {
                  enemy.x = canvas.width - enemy.width;
                  enemy.horizontalDirection = -1;
                }
              }
            }
          }

          if (isColliding(enemy, player)) {
            enemies.splice(i, 1);
            playerTakeDamage(CONFIG.enemyCollisionDamage);
            if (gameOver) return;
            continue;
          }

          // Remove filler enemies if off screen (formations stay)
          if (!enemy.formation && enemy.y > canvas.height) {
            enemies.splice(i, 1);
            continue;
          }

          // Enemy shooting (level 2+)
          if (level >= 2 && enemy.reachedTarget !== false) {
            var shootChance = CONFIG.enemyShootChance + (level - 2) * CONFIG.enemyShootIncrease;
            if (Math.random() < shootChance) {
              shootEnemyBullet(enemy);
            }
          }
        }

        // Check wave completion
        checkWaveCompletion();

        // Spawn power-ups
        trySpawnPowerup();
      }

      requestAnimationFrame(draw);
    }

    // ============================================
    // GAME START
    // ============================================
    var startButton = document.getElementById("startButton");
    startButton.addEventListener("click", function() {
      this.blur();

      if (gameOver) {
        // Reset game state
        stopBossMusic();
        stopCreditsMusic();
        gameOver = false;
        score = 0;
        level = 1;
        health = CONFIG.startingHealth;
        hasDoubleLaser = false;
        hasShield = false;
        shieldHitsRemaining = 0;
        powerupsSpawnedThisLevel = { health: false, doubleLaser: false, shield: false };
        playerBlinking = false;
        playerVisible = true;
        bossActive = false;
        bossDefeated = false;
        boss = null;
        bossBlinking = false;
        bossVisible = true;

        // Reset phase tracking
        currentBoss = 0;
        boss1Defeated = false;
        boss2Defeated = false;
        redPhase = false;
        redPhaseStartScore = 0;

        // Reset wave state
        currentWave = 0;
        waveEnemiesRemaining = 0;
        waveInProgress = false;
        waveCooldown = false;
        lastWaveEndTime = 0;
        morphStartTime = 0;
        currentMorphShape = 0;
        lastFillerTime = 0;
        formationRotation = 0;
        targetFormationRotation = 0;

        player.x = canvas.width / 2;
        enemies = [];
        playerBullets = [];
        enemyBullets = [];
        powerups = [];
        bossMinions = [];
        bossOrbiters = [];
        orbitersInitialized = false;
        lastOrbiterDeathTime = 0;
        lastBossFillerBeat = 0;

        // Update UI
        updateUI();
        document.getElementById("levelDisplay").style.display = "none";
        document.getElementById("powerupDisplay").style.display = "none";
        document.getElementById("bonusDisplay").style.display = "none";
        document.getElementById("pauseDisplay").style.display = "none";
        document.getElementById("gameOver").style.display = "none";
        document.getElementById("victory").style.display = "none";
        paused = false;

        // Change button to Pause
        startButton.innerText = "Pause";

        showAnnouncement("levelDisplay", "Level 1", 2000);
        startBackgroundMusic();
        draw();
      } else {
        // Game is running - toggle pause
        paused = !paused;
        document.getElementById("pauseDisplay").style.display = paused ? "block" : "none";
        startButton.innerText = paused ? "Resume" : "Pause";
        if (paused) {
          bgMusic.pause();
        } else {
          bgMusic.play();
        }
      }
    });
  </script>
</body>

</html>