<!--
  ============================================================
  game.html ‚Äî NON-X Desktop Game
  ============================================================
  Desktop build of the NON-X top-scrolling space shooter.
  Targets a fixed 4:3 canvas (800√ó600 px) centered in the
  viewport. Scaled up via CSS transform to fill the screen
  while preserving the intended aspect ratio.

  Controls:
    Arrow Keys / WASD ‚Äî Move player ship
    Spacebar          ‚Äî Fire

  Game Structure:
    ‚Ä¢ 12 levels split across 3 phases (Original / Red / Purple)
    ‚Ä¢ Wave-based formation system: enemies enter in morphing
      formations that cycle through multiple shapes
    ‚Ä¢ 3 boss encounters triggered by score thresholds:
        Boss 1 at score 400  (end of level 4)
        Boss 2 at score 1200 (end of level 8, red phase)
        Boss 3 at score 2000 (end of level 12, purple phase)
    ‚Ä¢ Power-up drops: Health (+10 HP), Double Laser, Shield,
      Quad Shot
    ‚Ä¢ High score leaderboard stored in localStorage (top 10)

  Image Assets (all in project root, paths use /Xenon_3/ prefix):
    player.png, enemy.png, enemy2‚Äì4.png, Boss.png,
    enemy1‚Äì4_Red.png, boss_Red.png, boss_aRed.png,
    enemy1‚Äì4_purple.png, boss_purple.png

  Audio Assets (in /Xenon_3/sfx/):
    background.mp3, boss.mp3, credits.mp3,
    shoot.mp3, enemyDead.mp3, playerDead.mp3,
    bossIntro.mp3, powerup.mp3, shieldHit.mp3

  Dependencies: None (no external libraries or frameworks).
  Entry point: index.html ‚Üí launchGame() ‚Üí game.html
  ============================================================
-->
<!DOCTYPE html>
<html lang="en">

<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-9ECFZ9JBE5"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){window.dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-9ECFZ9JBE5', {
      'send_page_view': true,
      'page_title': 'NON-X Desktop Game',
      'page_location': window.location.href
    });
  </script>

  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>NON-X - Desktop</title>
  <style>
    /* Reset ‚Äî consistent box model */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    /* Prevent pull-to-refresh (mobile) and swipe-to-navigate (desktop touchpads) */
    html,
    body {
      overscroll-behavior: none;
      touch-action: none;
    }

    /* Full-screen black background; overflow hidden prevents any scroll */
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: Arial, sans-serif;
    }

    /* Centers the game canvas in the viewport */
    #container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #000;
    }

    /* Wrapper sized to the canvas ‚Äî positions HUD overlays absolutely */
    #gameWrapper {
      position: relative;
      display: inline-block;
    }

    /* Pixel-perfect rendering for the sprite-based game canvas */
    canvas {
      display: block;
      background-color: #000;
      image-rendering: crisp-edges;
      image-rendering: pixelated;
    }

    #startButton {
      position: absolute;
      top: 12px;
      left: 12px;
      padding: 10px 20px;
      font-size: 16px;
      z-index: 10;
      cursor: pointer;
      background: #00FFFF;
      color: #000;
      border: none;
      border-radius: 4px;
      font-weight: bold;
    }

    #muteButton {
      position: absolute;
      top: 12px;
      right: 12px;
      padding: 10px 15px;
      font-size: 20px;
      z-index: 10;
      cursor: pointer;
      background: #00FFFF;
      color: #000;
      border: none;
      border-radius: 4px;
      font-weight: bold;
      display: block;
    }

    #introCard {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 10;
      background: rgba(0, 0, 0, 0.88);
      border: 1px solid #00FFFF;
      border-radius: 12px;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.25);
      padding: 32px 36px;
      width: 360px;
      color: #ccc;
      font-family: Arial, sans-serif;
      text-align: left;
    }

    #introCard h2 {
      color: #00FFFF;
      font-size: 20px;
      letter-spacing: 2px;
      text-transform: uppercase;
      text-align: center;
      margin-bottom: 24px;
      text-shadow: 0 0 10px #00FFFF;
    }

    #introCard h3 {
      color: #fff;
      font-size: 13px;
      letter-spacing: 1px;
      text-transform: uppercase;
      margin-bottom: 8px;
      margin-top: 18px;
    }

    #introCard ul {
      list-style: none;
      padding: 0;
      margin: 0;
      font-size: 13px;
      line-height: 1.9;
      color: #bbb;
    }

    #introCard ul li::before {
      content: "‚Äî ";
      color: #00FFFF;
    }

    .powerup-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 4px;
    }

    .powerup-item {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 13px;
      color: #bbb;
    }

    .pu-icon {
      flex-shrink: 0;
      display: block;
    }

    #introCard .card-start-btn {
      display: block;
      width: 100%;
      margin-top: 26px;
      padding: 14px 0;
      font-size: 18px;
      font-family: Arial, sans-serif;
      font-weight: bold;
      letter-spacing: 2px;
      text-transform: uppercase;
      background: #00FFFF;
      color: #000;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
      transition: background 0.2s, box-shadow 0.2s;
    }

    #introCard .card-start-btn:hover {
      background: #fff;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
    }

    #score,
    #levelIndicator,
    #health,
    #gameOver,
    #levelDisplay,
    #powerupDisplay,
    #bonusDisplay,
    #warningDisplay,
    #pauseDisplay,
    #victory {
      position: absolute;
      z-index: 2;
    }

    #score {
      color: white;
      top: 60px;
      right: 10px;
      font-size: 18px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
    }

    #levelIndicator {
      display: none;
    }

    #health {
      color: white;
      top: 60px;
      left: 10px;
      font-size: 16px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
    }

    #gameOver {
      display: none;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 24px;
      color: #00FFFF;
      text-shadow: 0 0 10px #00FFFF;
      text-align: center;
      line-height: 1.6;
    }

    #levelDisplay {
      display: none;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      color: #00FF00;
      text-shadow: 0 0 20px #00FF00, 0 0 40px #00FF00;
      z-index: 3;
      animation: levelPulse 0.5s ease-in-out;
    }

    @keyframes levelPulse {
      0% {
        transform: translate(-50%, -50%) scale(0.5);
        opacity: 0;
      }

      50% {
        transform: translate(-50%, -50%) scale(1.2);
        opacity: 1;
      }

      100% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
      }
    }

    #powerupDisplay {
      display: none;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 32px;
      color: #FFD700;
      text-shadow: 0 0 15px #FFD700;
      z-index: 3;
    }

    #bonusDisplay {
      display: none;
      top: 65%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 32px;
      color: #FFD700;
      text-shadow: 0 0 15px #FFD700;
      z-index: 3;
    }

    #warningDisplay {
      display: none;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 24px;
      color: #FFD700;
      text-shadow: 0 0 10px #FFD700, 0 0 20px #FFD700;
      z-index: 3;
      text-align: center;
      line-height: 1.5;
      animation: warningPulse 0.5s ease-in-out infinite;
    }

    #warningDisplay br {
      display: block;
      margin-bottom: 8px;
    }

    @keyframes warningPulse {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.6;
      }
    }

    #pauseDisplay {
      display: none;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      color: #FFFFFF;
      text-shadow: 0 0 20px #FFFFFF;
      z-index: 4;
    }

    #victory {
      display: none;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 18px;
      color: #00FFFF;
      text-shadow: 0 0 15px #00FFFF;
      z-index: 3;
      text-align: center;
      line-height: 1.4;
      max-width: 90%;
      padding: 20px;
    }
  </style>
</head>

<body>
  <div id="container">
    <div id="gameWrapper">
      <button id="startButton">Pause</button>
      <button id="muteButton">üîä</button>

      <div id="introCard">
        <h2>NON-X</h2>
        <p>Can you defeat all 3 Alien Bosses?</p>
        <h3>Controls</h3>
        <ul>
          <li>Use mouse or ‚Üê ‚Üí Arrow keys to move</li>
          <li>Hold left mouse button or Spacebar to shoot</li>
          <li>P or Escape to pause</li>
        </ul>

        <h3>Power-ups</h3>
        <div class="powerup-list">
          <div class="powerup-item">
            <canvas class="pu-icon" id="puHealth" width="32" height="32"></canvas>
            <span>Health ‚Äî restores 10 HP</span>
          </div>
          <div class="powerup-item">
            <canvas class="pu-icon" id="puLaser" width="32" height="32"></canvas>
            <span>Double Laser ‚Äî dual shots</span>
          </div>
          <div class="powerup-item">
            <canvas class="pu-icon" id="puShield" width="32" height="32"></canvas>
            <span>Shield ‚Äî absorbs hits</span>
          </div>
          <div class="powerup-item">
            <canvas class="pu-icon" id="puQuad" width="32" height="32"></canvas>
            <span>Quad Laser ‚Äî four simultaneous shots</span>
          </div>
        </div>

        <button class="card-start-btn" onclick="startFromCard()">Start Game</button>
      </div>

      <div id="score">Score: 0</div>
      <canvas id="gameCanvas" width="800" height="600"></canvas>
      <div id="levelIndicator">Level: 1</div>
      <div id="health">Health: 50</div>
      <div id="levelDisplay">Level 1</div>
      <div id="powerupDisplay"></div>
      <div id="bonusDisplay"></div>
      <div id="warningDisplay">Warning!<br>Shielded Enemy!</div>
      <div id="pauseDisplay">PAUSED</div>
      <div id="victory">Thank you for playing!<br><br>Special thanks to Modmotif for the music.<br><br>Please submit
        your email to download the song for remix.<br><br>&copy; 2026</div>
      <div id="gameOver">Game Over!</div>
    </div>
  </div>

  <script>
    // ============================================
    // CANVAS SETUP
    // ============================================
    var canvas = document.getElementById("gameCanvas");
    var ctx = canvas.getContext("2d");

    // ============================================
    // GAME CONFIGURATION
    // ============================================
    // Central tuning object. All gameplay-affecting numbers live here
    // so difficulty, feel, and balance can be adjusted in one place.
    var CONFIG = {
      // ‚îÄ‚îÄ Player ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      playerSpeed: 5,           // Movement speed in px/frame
      bulletSpeed: 12,          // Player bullet speed in px/frame (upward)
      startingHealth: 100,      // HP at game start
      maxHealth: 250,           // HP cap (cannot exceed this via pickups)

      // ‚îÄ‚îÄ Damage ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      enemyBulletDamage: 10,    // HP lost per enemy bullet hit
      enemyCollisionDamage: 20, // HP lost when an enemy physically collides with player
      bossDamage: 25,           // HP lost per boss bullet or boss body collision
      healthPowerupAmount: 10,  // HP restored by a health pickup

      // ‚îÄ‚îÄ Enemy movement ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      enemyBaseSpeed: 1.5,      // Base downward speed in px/frame at level 1
      enemySpeedIncrease: 0.3,  // Additional px/frame added per level
      enemySpawnRate: 0.01,     // Probability per frame of spawning an enemy (non-wave mode)
      enemySpawnIncrease: 0.005,// Spawn rate increase per level

      // ‚îÄ‚îÄ Enemy shooting (unlocked at level 2) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      enemyShootChance: 0.005,  // Per-frame probability an individual enemy fires
      enemyShootIncrease: 0.002,// Shoot chance increase per level above 2
      enemyBulletSpeed: 5,      // Enemy bullet speed in px/frame (downward)

      // ‚îÄ‚îÄ Boss triggers (score thresholds) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      boss1ScoreThreshold: 400, // Boss 1 spawns when score reaches this value
      boss2ScoreThreshold: 1200,// Boss 2 spawns (red phase, post-Boss 1)
      boss3ScoreThreshold: 2000,// Boss 3 spawns (purple phase, post-Boss 2)
      bossHealth: 50,           // Hits required to defeat each boss
      bossSpeed: 1,             // Boss horizontal drift speed in px/frame
      bossShootChance: 0.02,    // Per-frame probability the boss fires a bullet

      // ‚îÄ‚îÄ Level progression ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Phases: levels 1‚Äì4 (standard), 5‚Äì8 (red), 9‚Äì12 (purple).
      // Boss encounters separate the phases; thresholds below apply
      // within each phase and are recalculated after each boss defeat.
      levelThresholds: [0, 100, 200, 300], // Score required for levels 1‚Äì4

      // Red-phase enemies move faster than the standard phase
      redLevelSpeedMultiplier: 1.3,

      // ‚îÄ‚îÄ Power-ups ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      powerupSpeed: 4,          // Pickup fall speed in px/frame
      powerupSpawnChance: 0.003,// Per-frame probability of a power-up spawning

      // ‚îÄ‚îÄ Boss minions (spawn during boss fights) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      bossMinionSpeed: 2,           // Minion horizontal scroll speed in px/frame
      bossMinionSpawnChance: 0.025, // Per-frame probability (desktop: 67% more than mobile)

      // ‚îÄ‚îÄ Enemy roster per level ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Each level unlocks an additional enemy type. Wave formations
      // randomly select from all types available at the current level.
      levelEnemyTypes: {
        1: ['enemy1'],
        2: ['enemy1', 'enemy2'],
        3: ['enemy1', 'enemy2', 'enemy3'],
        4: ['enemy1', 'enemy2', 'enemy3', 'enemy4'],
        5: ['enemy1_red'],
        6: ['enemy1_red', 'enemy2_red'],
        7: ['enemy1_red', 'enemy2_red', 'enemy3_red'],
        8: ['enemy1_red', 'enemy2_red', 'enemy3_red', 'enemy4_red'],
        9: ['enemy1_purple'],
        10: ['enemy1_purple', 'enemy2_purple'],
        11: ['enemy1_purple', 'enemy2_purple', 'enemy3_purple'],
        12: ['enemy1_purple', 'enemy2_purple', 'enemy3_purple', 'enemy4_purple']
      },

      // Enemy types that move in a diagonal zigzag pattern
      zigzagEnemies: ['enemy3', 'enemy3_red', 'enemy4_red', 'enemy3_purple', 'enemy4_purple'],

      // Enemy types that sweep horizontally across the screen
      sideToSideEnemies: ['enemy2_red', 'enemy2_purple']
    };

    // ============================================
    // IMAGE SETUP
    // ============================================
    var playerImg = new Image();
    playerImg.src = "/Xenon_3/player.png";

    var enemyImg1 = new Image();
    enemyImg1.src = "/Xenon_3/enemy.png";

    var enemyImg2 = new Image();
    enemyImg2.src = "/Xenon_3/enemy2.png";

    var enemyImg3 = new Image();
    enemyImg3.src = "/Xenon_3/enemy3.png";

    var enemyImg4 = new Image();
    enemyImg4.src = "/Xenon_3/enemy4.png";

    var bossImg = new Image();
    bossImg.src = "/Xenon_3/Boss.png";

    // Red enemy images (levels 5-8)
    var enemyImg1Red = new Image();
    enemyImg1Red.src = "/Xenon_3/enemy1_Red.png";

    var enemyImg2Red = new Image();
    enemyImg2Red.src = "/Xenon_3/enemy2_Red.png";

    var enemyImg3Red = new Image();
    enemyImg3Red.src = "/Xenon_3/enemy3_Red.png";

    var enemyImg4Red = new Image();
    enemyImg4Red.src = "/Xenon_3/enemy4_Red.png";

    var bossImgRed = new Image();
    bossImgRed.src = "/Xenon_3/boss_Red.png";

    // Purple enemy images (levels 9-12)
    var enemyImg1Purple = new Image();
    enemyImg1Purple.src = "/Xenon_3/enemy1_purple.png";

    var enemyImg2Purple = new Image();
    enemyImg2Purple.src = "/Xenon_3/enemy2_purple.png";

    var enemyImg3Purple = new Image();
    enemyImg3Purple.src = "/Xenon_3/enemy3_purple.png";

    var enemyImg4Purple = new Image();
    enemyImg4Purple.src = "/Xenon_3/enemy4_purple.png";

    var bossImgPurple = new Image();
    bossImgPurple.src = "/Xenon_3/boss_purple.png";

    // ============================================
    // SOUND SETUP
    // ============================================
    var sounds = {
      playerBullet: new Audio("/Xenon_3/sfx/playerBullet.mp3"),
      playerHit: new Audio("/Xenon_3/sfx/playerHit.mp3"),
      playerDead: new Audio("/Xenon_3/sfx/playerDead.mp3"),
      enemyDead: new Audio("/Xenon_3/sfx/enemyDead.mp3"),
      bossIntro: new Audio("/Xenon_3/sfx/bossIntro.mp3"),
      powerUp: new Audio("/Xenon_3/sfx/powerUp.mp3")
    };

    // Background music (full song, looped)
    var bgMusic = new Audio("/Xenon_3/sfx/NonexFullSong.mp3");
    bgMusic.loop = true;
    bgMusic.volume = 0.79;

    // Credits music
    var creditsMusic = new Audio("/Xenon_3/sfx/NonexFullSong.mp3");
    creditsMusic.volume = 0.79;

    // Set sound effect volumes (all at 0.4)
    sounds.playerBullet.volume = 0.4;
    sounds.playerHit.volume = 0.4;
    sounds.playerDead.volume = 0.4;
    sounds.enemyDead.volume = 0.4;
    sounds.bossIntro.volume = 0.4;
    sounds.powerUp.volume = 0.4;

    var bossIntroInterval = null;

    /**
     * Plays a one-shot sound effect by resetting its playback position and
     * calling play(). Autoplay errors are silently ignored (browser policy).
     * @param {string} soundName - Key in the `sounds` object (e.g. 'enemyDead').
     */
    function playSound(soundName) {
      var sound = sounds[soundName];
      if (sound) {
        sound.currentTime = 0;
        sound.play().catch(function (e) {
          // Ignore autoplay errors
        });
      }
    }

    /**
     * Starts the boss intro sting and sets a repeating interval so it plays
     * every 10 seconds for as long as a boss fight is active.
     */
    function startBossMusic() {
      playSound('bossIntro');
      // Repeat every 10 seconds
      bossIntroInterval = setInterval(function () {
        if (bossActive && !gameOver) {
          playSound('bossIntro');
        }
      }, 10000);
    }

    /** Clears the boss music interval and resets the audio element to the start. */
    function stopBossMusic() {
      if (bossIntroInterval) {
        clearInterval(bossIntroInterval);
        bossIntroInterval = null;
      }
      sounds.bossIntro.pause();
      sounds.bossIntro.currentTime = 0;
    }

    /**
     * Starts looping background music from the beginning, unless the player
     * has disabled music (localStorage key `nonex_music` === 'off').
     */
    // ============================================
    // A/B TESTING - MUSIC DEFAULT
    // ============================================
    /**
     * Assigns user to A/B test group for music default setting.
     * Group A: Music ON by default
     * Group B: Music OFF by default
     * Assignment is random and persists in localStorage.
     */
    function initMusicABTest() {
      var abGroup = localStorage.getItem('nonx_ab_music_group');

      if (!abGroup) {
        abGroup = Math.random() < 0.5 ? 'A' : 'B';
        localStorage.setItem('nonx_ab_music_group', abGroup);

        if (!localStorage.getItem('nonex_music')) {
          if (abGroup === 'A') {
            localStorage.setItem('nonex_music', 'on');
          } else {
            localStorage.setItem('nonex_music', 'off');
          }
        }
      }

      return abGroup;
    }

    var userABGroup = initMusicABTest();

    function startBackgroundMusic() {
      if (localStorage.getItem('nonex_music') === 'off') return;
      bgMusic.currentTime = 0;
      bgMusic.play().catch(function (e) { });
    }

    /** Pauses and resets the background music track. */
    function stopBackgroundMusic() {
      bgMusic.pause();
      bgMusic.currentTime = 0;
    }

    /**
     * Toggles the background music on/off and updates the mute button icon.
     * Saves the preference to localStorage for persistence across sessions.
     */
    function toggleMusic() {
      var muteBtn = document.getElementById('muteButton');
      var victoryMuteBtn = document.getElementById('victoryMuteBtn');
      var gameOverMuteBtn = document.getElementById('gameOverMuteBtn');

      if (bgMusic.paused) {
        bgMusic.play().catch(function (e) {
          // Silently handle autoplay restrictions
        });
        localStorage.setItem('nonex_music', 'on');
        if (muteBtn) muteBtn.textContent = 'üîä';
        if (victoryMuteBtn) victoryMuteBtn.textContent = 'üîä';
        if (gameOverMuteBtn) gameOverMuteBtn.textContent = 'üîä';
      } else {
        bgMusic.pause();
        localStorage.setItem('nonex_music', 'off');
        if (muteBtn) muteBtn.textContent = 'üîá';
        if (victoryMuteBtn) victoryMuteBtn.textContent = 'üîá';
        if (gameOverMuteBtn) gameOverMuteBtn.textContent = 'üîá';
      }
    }

    /** Plays the credits music track from the beginning (used on victory screen). */
    function startCreditsMusic() {
      creditsMusic.currentTime = 0;
      creditsMusic.play().catch(function (e) {
        // Ignore autoplay errors
      });
    }

    /** Pauses and resets the credits music track. */
    function stopCreditsMusic() {
      creditsMusic.pause();
      creditsMusic.currentTime = 0;
    }

    /**
     * Validates and saves the email address entered in the victory screen input.
     * Emails are stored in `localStorage` under the key `xenonEmails` (JSON array).
     * A basic '@' check is the only validation applied.
     */
    /**
     * Submits score to the global leaderboard with optional Instagram handle.
     * Leaderboard is stored in localStorage and can sync to backend.
     */
    function submitToLeaderboard() {
      var igHandle = document.getElementById('igInput').value.trim();

      var sanitized = igHandle.replace(/[@<>'"]/g, '').substring(0, 30);

      var leaderboard = JSON.parse(localStorage.getItem('nonx_leaderboard')) || [];

      leaderboard.push({
        score: score,
        instagram: sanitized || 'Anonymous',
        date: new Date().toISOString(),
        platform: 'desktop'
      });

      leaderboard.sort(function (a, b) { return b.score - a.score; });
      leaderboard = leaderboard.slice(0, 100);

      //Save
      localStorage.setItem('nonx_leaderboard', JSON.stringify(leaderboard));

      //Track leaderboard submission
      gtag('event', 'leaderboard_submit', {
        'ab_music_group': userABGroup,
        'platform': 'desktop',
        'score': score,
        'instagram_provided': sanitized !== ''
      });


      alert('Score submitted! You rank #' + (leaderboard.findIndex(function (e) { return e.score === score; }) + 1) + ' globally!');

      document.getElementById('leaderboardSubmit').style.display = 'none';
      showLeaderboard();
    }

    function showLeaderboard() {
      var leaderboard = JSON.parse(localStorage.getItem('nonx_leaderboard')) || [];
      var top10 = leaderboard.slice(0, 10);

      var html = '<div style="margin-top: 20px; text-align: left; display: inline-block;"><strong>Top 10 Global Scores:</strong><br>';
      for (var i = 0; i < top10.length; i++) {
        var entry = top10[i];
        var igText = entry.instagram !== 'Anonymous' ? '@' + entry.instagram : entry.instagram;
        html += (i + 1) + '. ' + entry.score + ' - ' + igText + '<br>';
      }
      html += '</div>';

      document.getElementById('leaderboardDisplay').innerHTML = html;
    }

    // ============================================
    // GAME STATE
    // ============================================
    var player = {
      x: canvas.width / 2,
      y: canvas.height - 100,
      width: 75,
      height: 75
    };

    var playerBullets = [];
    var enemyBullets = [];
    var enemies = [];
    var powerups = [];
    var score = 0;
    var level = 1;
    var health = 50;
    var gameOver = true;
    var paused = false;
    // Load top 10 high scores from localStorage
    var highScores = JSON.parse(localStorage.getItem('xenonHighScores')) || [];

    /**
     * Inserts a score into the top-10 leaderboard, sorts descending, trims to
     * 10 entries, and persists to `localStorage` under `xenonHighScores`.
     * @param {number} newScore - The score to add.
     */
    function addHighScore(newScore) {
      highScores.push(newScore);
      highScores.sort(function (a, b) { return b - a; }); // Sort descending
      highScores = highScores.slice(0, 10); // Keep only top 10
      localStorage.setItem('xenonHighScores', JSON.stringify(highScores));
    }

    /**
     * Returns true if `newScore` would make it into the current top-10 list.
     * Always returns true when fewer than 10 scores have been recorded.
     * @param {number} newScore
     * @returns {boolean}
     */
    function isTopTenScore(newScore) {
      if (highScores.length < 10) return true;
      return newScore > highScores[highScores.length - 1];
    }

    /**
     * Returns the 1-based rank position that `newScore` would occupy in the
     * existing sorted leaderboard (lower rank = better).
     * @param {number} newScore
     * @returns {number} Rank, from 1 (best) to highScores.length + 1 (last).
     */
    function getScoreRank(newScore) {
      for (var i = 0; i < highScores.length; i++) {
        if (newScore >= highScores[i]) return i + 1;
      }
      return highScores.length + 1;
    }
    var rightPressed = false;
    var leftPressed = false;

    // Mouse controls (desktop only)
    var mouseX = 0;
    var mouseY = 0;
    var mouseActive = false;
    var mouseDown = false;
    var spacebarPressed = false;
    var lastShotTime = 0;
    var FIRE_COOLDOWN = 127; // ms between shots (~7.9 shots/sec, +2 more than mobile)

    // Power-up state
    var hasDoubleLaser = false;
    var laserLevel = 1; // 1 = single, 2 = double, 3 = triple, 4 = quad (purple phase only)
    var powerupsSpawnedThisLevel = { health: false, doubleLaser: false, shield: false };
    var lastPowerupSpawnTime = 0;
    var powerupSpawnCooldown = 5000; // 5 seconds minimum between power-ups

    // Player blink state (when damaged)
    var playerBlinking = false;
    var playerBlinkTimer = 0;
    var playerVisible = true;

    // Boss state
    var boss = null;
    var bossActive = false;
    var bossDefeated = false;
    var bossMinions = [];  // Side-scrolling enemies during boss fight
    var bossBlinking = false;
    var bossBlinkTimer = 0;
    var bossVisible = true;

    // Screen shake state
    var screenShakeActive = false;
    var screenShakeIntensity = 0;
    var screenShakeDuration = 0;
    var screenShakeTimer = 0;

    // Explosion effects (desktop enhancement)
    var explosions = [];
    var particles = [];

    // Game phase tracking
    var currentBoss = 0;        // 0 = no boss yet, 1 = boss 1, 2 = boss 2, 3 = boss 3
    var boss1Defeated = false;
    var boss2Defeated = false;
    var boss3Defeated = false;
    var redPhase = false;       // True after boss 1 is defeated (levels 5-8)
    var redPhaseStartScore = 0; // Score when red phase started
    var purplePhase = false;    // True after boss 2 is defeated (levels 9-12)
    var purplePhaseStartScore = 0;

    // Power-up types
    var POWERUP_TYPES = {
      HEALTH: 'health',       // Red diamond - restore health
      DOUBLE_LASER: 'laser',  // Purple hexagon - double lasers
      SHIELD: 'shield'        // Aqua triangle - damage shield
    };

    // Shield state
    var hasShield = false;
    var shieldHitsRemaining = 0;

    // ============================================
    // UI UPDATES
    // ============================================
    /**
     * Syncs the score, level, and health DOM elements with current game state.
     * Called after any change to those values.
     */
    function updateUI() {
      document.getElementById("score").innerText = "Score: " + score;
      document.getElementById("levelIndicator").innerText = "Level: " + level;
      document.getElementById("health").innerText = "Health: " + health;
    }

    /**
     * Briefly shows a HUD overlay element with the given text, then hides it
     * after `duration` milliseconds (default 2000 ms).
     * @param {string} element  - DOM element ID (e.g. 'levelDisplay').
     * @param {string} text     - Text to display.
     * @param {number} [duration=2000] - Display duration in milliseconds.
     */
    function showAnnouncement(element, text, duration) {
      var el = document.getElementById(element);
      el.innerText = text;
      el.style.display = "block";
      setTimeout(function () {
        el.style.display = "none";
      }, duration || 2000);
    }

    /**
     * Initiates a screen-shake effect by translating the canvas element with
     * random offsets that decay over the specified duration.
     * @param {number} [intensity=10] - Maximum pixel offset in each direction.
     * @param {number} [duration=500] - Total shake duration in milliseconds.
     */
    function triggerScreenShake(intensity, duration) {
      screenShakeActive = true;
      screenShakeIntensity = intensity || 10;
      screenShakeDuration = duration || 500;
      screenShakeTimer = Date.now();
    }

    /**
     * Called every frame. Applies or clears the CSS transform that produces
     * the screen-shake effect, with intensity decaying linearly over time.
     */
    function updateScreenShake() {
      if (!screenShakeActive) {
        canvas.style.transform = '';
        return;
      }

      var elapsed = Date.now() - screenShakeTimer;
      if (elapsed >= screenShakeDuration) {
        screenShakeActive = false;
        canvas.style.transform = '';
        return;
      }

      // Decrease intensity over time for decay effect
      var progress = elapsed / screenShakeDuration;
      var currentIntensity = screenShakeIntensity * (1 - progress);

      // Random shake offset
      var offsetX = (Math.random() - 0.5) * 2 * currentIntensity;
      var offsetY = (Math.random() - 0.5) * 2 * currentIntensity;

      canvas.style.transform = 'translate(' + offsetX + 'px, ' + offsetY + 'px)';
    }

    // ============================================
    // LEVEL MANAGEMENT
    // ============================================
    /**
     * Refreshes UI after each enemy kill. Level progression itself is handled
     * by the wave system (see `advanceLevel`); this is purely a UI sync hook.
     */
    function checkLevelUp() {
      // Wave-based system handles level progression via advanceLevel()
      // This function is only used for additional score tracking
      updateUI();
    }

    // ============================================
    // POWER-UP SYSTEM
    // ============================================
    /**
     * Spawns a power-up of the specified type at a random horizontal position
     * along the top of the canvas, avoiding collision with existing enemies.
     * Up to 10 placement attempts are made; returns false if no safe spot found.
     * @param {string} type - One of POWERUP_TYPES (HEALTH, DOUBLE_LASER, SHIELD).
     * @returns {boolean} True if the power-up was successfully added.
     */
    function createPowerup(type) {
      // Double laser moves slightly slower (3.5) than health powerup (4)
      var speed = (type === POWERUP_TYPES.DOUBLE_LASER) ? 3.5 : CONFIG.powerupSpeed;
      var width = 40;
      var height = 40;

      // Find a non-overlapping spawn position (try up to 10 times)
      var x, y = 0;
      var attempts = 0;
      do {
        x = Math.random() * (canvas.width - width);
        attempts++;
      } while (isOverlappingEnemy(x, y, width, height) && attempts < 10);

      // If we couldn't find a spot, skip spawning
      if (attempts >= 10 && isOverlappingEnemy(x, y, width, height)) {
        return false; // Indicate spawn failed
      }

      powerups.push({
        x: x,
        y: y,
        width: width,
        height: height,
        speed: speed,
        type: type
      });
      return true;
    }

    // 123 BPM = 488ms per beat
    var BPM_INTERVAL = 60000 / 123; // ~488ms

    /**
     * Renders a single power-up to the canvas with a BPM-synced breathing scale
     * and two expanding ripple rings. Each type has a distinct shape and color:
     *   HEALTH      ‚Üí red diamond with white plus
     *   DOUBLE_LASER ‚Üí purple hexagon with double bars
     *   SHIELD      ‚Üí aqua triangle with inner circle
     * @param {Object} powerup - Power-up object from the `powerups` array.
     */
    function drawPowerup(powerup) {
      var time = Date.now();

      // Breathing effect for power-ups (every 2 beats)
      var breathInterval = BPM_INTERVAL * 2;
      var breathProgress = (time % breathInterval) / breathInterval;
      var breathScale = 1 + Math.sin(breathProgress * Math.PI) * 0.15;

      var baseW = powerup.width;
      var baseH = powerup.height;
      var w = baseW * breathScale;
      var h = baseH * breathScale;
      var x = powerup.x + baseW / 2 - w / 2;
      var y = powerup.y + baseH / 2 - h / 2;
      var cx = powerup.x + baseW / 2;
      var cy = powerup.y + baseH / 2;

      // Pulsing ripple effect at 123 BPM
      var beatPhase = (time % BPM_INTERVAL) / BPM_INTERVAL; // 0 to 1

      // Draw expanding ripple rings
      var maxRippleRadius = w * 1.5;
      var rippleRadius = beatPhase * maxRippleRadius;
      var rippleAlpha = 1 - beatPhase; // Fade out as it expands

      ctx.save();
      ctx.beginPath();
      ctx.arc(cx, cy, rippleRadius, 0, Math.PI * 2);
      var rippleColor;
      if (powerup.type === POWERUP_TYPES.HEALTH) {
        rippleColor = 'rgba(255, 50, 50, ' + (rippleAlpha * 0.5) + ')';
      } else if (powerup.type === POWERUP_TYPES.SHIELD) {
        rippleColor = 'rgba(0, 255, 255, ' + (rippleAlpha * 0.5) + ')';
      } else {
        rippleColor = 'rgba(153, 50, 255, ' + (rippleAlpha * 0.5) + ')';
      }
      ctx.strokeStyle = rippleColor;
      ctx.lineWidth = 3;
      ctx.stroke();

      // Second ripple (offset by half beat)
      var beatPhase2 = ((time + BPM_INTERVAL / 2) % BPM_INTERVAL) / BPM_INTERVAL;
      var rippleRadius2 = beatPhase2 * maxRippleRadius;
      var rippleAlpha2 = 1 - beatPhase2;

      ctx.beginPath();
      ctx.arc(cx, cy, rippleRadius2, 0, Math.PI * 2);
      var rippleColor2;
      if (powerup.type === POWERUP_TYPES.HEALTH) {
        rippleColor2 = 'rgba(255, 50, 50, ' + (rippleAlpha2 * 0.3) + ')';
      } else if (powerup.type === POWERUP_TYPES.SHIELD) {
        rippleColor2 = 'rgba(0, 255, 255, ' + (rippleAlpha2 * 0.3) + ')';
      } else {
        rippleColor2 = 'rgba(153, 50, 255, ' + (rippleAlpha2 * 0.3) + ')';
      }
      ctx.strokeStyle = rippleColor2;
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();

      if (powerup.type === POWERUP_TYPES.HEALTH) {
        // Red diamond - restore health
        ctx.fillStyle = "#FF3333";
        ctx.beginPath();
        ctx.moveTo(x + w / 2, y);
        ctx.lineTo(x + w, y + h / 2);
        ctx.lineTo(x + w / 2, y + h);
        ctx.lineTo(x, y + h / 2);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = "#FF0000";
        ctx.lineWidth = 2;
        ctx.stroke();
        // Plus symbol
        ctx.fillStyle = "#FFFFFF";
        ctx.fillRect(x + w / 2 - 2, y + h / 4, 4, h / 2);
        ctx.fillRect(x + w / 4, y + h / 2 - 2, w / 2, 4);
      } else if (powerup.type === POWERUP_TYPES.DOUBLE_LASER) {
        // Purple hexagon - double laser
        var cx = x + w / 2;
        var cy = y + h / 2;
        var r = w / 2;
        ctx.fillStyle = "#9933FF";
        ctx.beginPath();
        for (var i = 0; i < 6; i++) {
          var angle = (Math.PI / 3) * i - Math.PI / 2;
          var px = cx + r * Math.cos(angle);
          var py = cy + r * Math.sin(angle);
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = "#6600CC";
        ctx.lineWidth = 3;
        ctx.stroke();
        // Double bar symbol
        ctx.fillStyle = "#FFFFFF";
        ctx.fillRect(cx - 8, cy - 8, 4, 16);
        ctx.fillRect(cx + 4, cy - 8, 4, 16);
      } else if (powerup.type === POWERUP_TYPES.SHIELD) {
        // Aqua triangle - shield
        ctx.fillStyle = "#00FFFF";
        ctx.beginPath();
        ctx.moveTo(x + w / 2, y);
        ctx.lineTo(x + w, y + h);
        ctx.lineTo(x, y + h);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = "#00CCCC";
        ctx.lineWidth = 2;
        ctx.stroke();
        // Shield symbol (small circle)
        ctx.beginPath();
        ctx.arc(x + w / 2, y + h / 2 + 5, 8, 0, Math.PI * 2);
        ctx.strokeStyle = "#FFFFFF";
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }

    /**
     * Applies the effect of a collected power-up to the player and shows the
     * appropriate HUD announcement. Collecting any power-up also awards 5 pts.
     * @param {Object} powerup - The power-up object being collected.
     */
    function collectPowerup(powerup) {
      playSound('powerUp');
      score += 5;
      updateUI();
      if (powerup.type === POWERUP_TYPES.HEALTH) {
        health = Math.min(health + CONFIG.healthPowerupAmount, CONFIG.maxHealth);
        updateUI();
        showAnnouncement("powerupDisplay", "+10 Health!", 1500);
      } else if (powerup.type === POWERUP_TYPES.DOUBLE_LASER) {
        if (purplePhase && hasDoubleLaser) {
          if (laserLevel === 2) {
            laserLevel = 3;
            showAnnouncement("powerupDisplay", "TRIPLE LASER!", 1500);
          } else if (laserLevel === 3) {
            laserLevel = 4;
            showAnnouncement("powerupDisplay", "QUAD LASER!", 1500);
          } else {
            // Already at max power
            score += 50;
            showAnnouncement("powerupDisplay", "MAX POWER +50", 1500);
          }
        } else {
          hasDoubleLaser = true;
          laserLevel = 2;
          showAnnouncement("powerupDisplay", "Double Laser!", 1500);
        }
      } else if (powerup.type === POWERUP_TYPES.SHIELD) {
        hasShield = true;
        shieldHitsRemaining = 5;
        showAnnouncement("powerupDisplay", "Shield Active!", 1500);
      }
    }

    /**
     * Attempts to spawn a power-up based on random chance, respecting a 5-second
     * minimum cooldown between drops and a per-level one-of-each limit.
     * Priority: health (40%) ‚Üí double laser (70%) ‚Üí shield (level 3+) ‚Üí health fallback.
     */
    function trySpawnPowerup() {
      // Stagger power-ups - minimum 5 seconds between spawns
      var now = Date.now();
      if (now - lastPowerupSpawnTime < powerupSpawnCooldown) return;
      if (Math.random() > CONFIG.powerupSpawnChance) return;

      // Randomly choose which power-up to try spawning
      // Only mark as spawned if createPowerup succeeds
      var rand = Math.random();
      var spawned = false;

      if (!powerupsSpawnedThisLevel.health && rand < 0.4) {
        if (createPowerup(POWERUP_TYPES.HEALTH)) {
          powerupsSpawnedThisLevel.health = true;
          spawned = true;
        }
      } else if (!powerupsSpawnedThisLevel.doubleLaser && rand < 0.7) {
        if (createPowerup(POWERUP_TYPES.DOUBLE_LASER)) {
          powerupsSpawnedThisLevel.doubleLaser = true;
          spawned = true;
        }
      } else if (!powerupsSpawnedThisLevel.shield && level >= 3) {
        // Shield only spawns level 3+
        if (createPowerup(POWERUP_TYPES.SHIELD)) {
          powerupsSpawnedThisLevel.shield = true;
          spawned = true;
        }
      } else if (!powerupsSpawnedThisLevel.health) {
        if (createPowerup(POWERUP_TYPES.HEALTH)) {
          powerupsSpawnedThisLevel.health = true;
          spawned = true;
        }
      }

      if (spawned) {
        lastPowerupSpawnTime = now;
      }
    }

    // ============================================
    // ENEMY CREATION AND DRAWING
    // ============================================
    /**
     * Randomly selects an enemy sprite type from the roster unlocked for the
     * current level (defined in `CONFIG.levelEnemyTypes`).
     * @returns {string} Enemy type key (e.g. 'enemy1', 'enemy3_red').
     */
    function getEnemyType() {
      var availableTypes = CONFIG.levelEnemyTypes[level] || CONFIG.levelEnemyTypes[4];
      var randomIndex = Math.floor(Math.random() * availableTypes.length);
      return availableTypes[randomIndex];
    }

    /**
     * AABB overlap test between a candidate rect and all current enemies.
     * Used to find non-colliding spawn positions for enemies and power-ups.
     * @param {number} x      - Candidate rect left edge.
     * @param {number} y      - Candidate rect top edge.
     * @param {number} width  - Candidate rect width.
     * @param {number} height - Candidate rect height.
     * @returns {boolean} True if the rect overlaps any existing enemy.
     */
    function isOverlappingEnemy(x, y, width, height) {
      for (var i = 0; i < enemies.length; i++) {
        var e = enemies[i];
        if (x < e.x + e.width &&
          x + width > e.x &&
          y < e.y + e.height &&
          y + height > e.y) {
          return true;
        }
      }
      return false;
    }

    /**
     * Creates a single freeform (non-formation) enemy at a random top-edge x
     * position, with speed, type, and movement behaviour determined by the
     * current level and phase. Zigzag and side-to-side behaviours are assigned
     * based on `CONFIG.zigzagEnemies` / `CONFIG.sideToSideEnemies`.
     * Returns early (no-op) if no non-overlapping position is found in 10 tries.
     */
    function createEnemy() {
      var speedVariation = 1;
      var effectiveLevel = redPhase ? (level - 4) : level; // Levels 5-8 map to 1-4 for speed calc
      var baseSpeed = CONFIG.enemyBaseSpeed + (effectiveLevel - 1) * CONFIG.enemySpeedIncrease;

      // Apply speed multiplier for red phase
      if (redPhase) {
        baseSpeed *= CONFIG.redLevelSpeedMultiplier;
      }

      var enemyType = getEnemyType();
      var width = 50;
      var height = 50;

      // enemy2_red is 50% smaller than normal enemies
      if (enemyType === 'enemy2_red') {
        width = 29;
        height = 29;
      }

      // Find a non-overlapping spawn position (try up to 10 times)
      var x, y = 0;
      var attempts = 0;
      do {
        x = Math.random() * (canvas.width - width);
        attempts++;
      } while (isOverlappingEnemy(x, y, width, height) && attempts < 10);

      // If we couldn't find a spot after 10 tries, skip spawning
      if (attempts >= 10 && isOverlappingEnemy(x, y, width, height)) {
        return;
      }

      var enemy = {
        x: x,
        y: y,
        width: width,
        height: height,
        baseWidth: width,
        baseHeight: height,
        speed: baseSpeed + Math.random() * speedVariation,
        type: enemyType,
        breathPhase: Math.random() // Random phase for breathing effect
      };

      // Add zigzag properties based on config
      if (CONFIG.zigzagEnemies.indexOf(enemyType) !== -1) {
        enemy.zigzag = true;
        enemy.zigzagDirection = Math.random() < 0.5 ? 1 : -1;
        enemy.zigzagSpeed = 2;
        enemy.zigzagTimer = 0;
        enemy.zigzagInterval = 30; // Change direction every 30 frames
      }

      // Add side-to-side movement for enemy2_red
      if (CONFIG.sideToSideEnemies.indexOf(enemyType) !== -1) {
        enemy.sideToSide = true;
        enemy.horizontalDirection = Math.random() < 0.5 ? 1 : -1;
        enemy.horizontalSpeed = 2;
      }

      enemies.push(enemy);
    }

    // ============================================
    // WAVE-BASED FORMATION SYSTEM
    // ============================================

    // Wave state tracking
    var currentWave = 0;        // 0 = not started, 1 = wave 1, 2 = wave 2
    var waveEnemiesRemaining = 0;
    var waveInProgress = false;
    var waveCooldown = false;
    var lastWaveEndTime = 0;
    var morphStartTime = 0;     // When current formation started (for morphing)
    var currentMorphShape = 0;  // Index into formation shapes

    // Formation shapes - each has a collapsed and exploded version
    // Dance pattern: exploded (enter) -> collapsed -> exploded (repeat)
    var FORMATION_SHAPES = {
      // 3x3 Grid - collapsed
      grid3x3: function (count) {
        var positions = [];
        var cols = 3, rows = 3;
        var spacing = 0.35;
        for (var row = 0; row < rows; row++) {
          for (var col = 0; col < cols; col++) {
            if (positions.length >= count) break;
            positions.push({ x: (col - 1) * spacing, y: (row - 1) * spacing });
          }
        }
        return positions;
      },
      // 3x3 Grid - exploded
      grid3x3Exploded: function (count) {
        var positions = [];
        var cols = 3, rows = 3;
        var spacing = 0.35;
        var explode = 2.5;
        for (var row = 0; row < rows; row++) {
          for (var col = 0; col < cols; col++) {
            if (positions.length >= count) break;
            var x = (col - 1) * spacing;
            var y = (row - 1) * spacing;
            var dist = Math.sqrt(x * x + y * y);
            if (dist > 0.01) { x *= explode; y *= explode; }
            positions.push({ x: x, y: y });
          }
        }
        return positions;
      },
      // Diamond - 9 enemies (4 corners + 4 edges + 1 center)
      diamond: function (count) {
        var positions = [];
        var size = 0.4;
        // Center
        positions.push({ x: 0, y: 0 });
        // 4 cardinal points
        positions.push({ x: 0, y: -size });      // top
        positions.push({ x: size, y: 0 });       // right
        positions.push({ x: 0, y: size });       // bottom
        positions.push({ x: -size, y: 0 });      // left
        // 4 diagonal points (outer)
        positions.push({ x: -size * 0.7, y: -size * 0.7 }); // top-left
        positions.push({ x: size * 0.7, y: -size * 0.7 });  // top-right
        positions.push({ x: size * 0.7, y: size * 0.7 });   // bottom-right
        positions.push({ x: -size * 0.7, y: size * 0.7 });  // bottom-left
        return positions.slice(0, count);
      },
      // Diamond - exploded
      diamondExploded: function (count) {
        var positions = [];
        var size = 1.0;
        positions.push({ x: 0, y: 0 });
        positions.push({ x: 0, y: -size });
        positions.push({ x: size, y: 0 });
        positions.push({ x: 0, y: size });
        positions.push({ x: -size, y: 0 });
        positions.push({ x: -size * 0.7, y: -size * 0.7 });
        positions.push({ x: size * 0.7, y: -size * 0.7 });
        positions.push({ x: size * 0.7, y: size * 0.7 });
        positions.push({ x: -size * 0.7, y: size * 0.7 });
        return positions.slice(0, count);
      },
      // Circle - evenly spaced ring
      circle: function (count) {
        var positions = [];
        var radius = 0.45;
        for (var i = 0; i < count; i++) {
          var angle = (i / count) * Math.PI * 2 - Math.PI / 2;
          positions.push({ x: Math.cos(angle) * radius, y: Math.sin(angle) * radius });
        }
        return positions;
      },
      // Circle - exploded
      circleExploded: function (count) {
        var positions = [];
        var radius = 1.1;
        for (var i = 0; i < count; i++) {
          var angle = (i / count) * Math.PI * 2 - Math.PI / 2;
          positions.push({ x: Math.cos(angle) * radius, y: Math.sin(angle) * radius });
        }
        return positions;
      },
      // Flying V - point facing down
      flyingV: function (count) {
        var positions = [];
        var spacing = 0.25;
        var half = Math.floor(count / 2);
        // Tip at bottom center
        positions.push({ x: 0, y: spacing * half * 0.7 });
        // Left arm going up-left
        for (var i = 1; i <= half; i++) {
          positions.push({ x: -spacing * i, y: spacing * (half - i) * 0.7 });
        }
        // Right arm going up-right
        for (var i = 1; i < count - half - 1; i++) {
          positions.push({ x: spacing * i, y: spacing * (half - i) * 0.7 });
        }
        return positions.slice(0, count);
      },
      // Flying V - exploded
      flyingVExploded: function (count) {
        var positions = [];
        var spacing = 0.5;
        var half = Math.floor(count / 2);
        positions.push({ x: 0, y: spacing * half * 0.7 });
        for (var i = 1; i <= half; i++) {
          positions.push({ x: -spacing * i, y: spacing * (half - i) * 0.7 });
        }
        for (var i = 1; i < count - half - 1; i++) {
          positions.push({ x: spacing * i, y: spacing * (half - i) * 0.7 });
        }
        return positions.slice(0, count);
      },
      // 4x4 Square grid
      grid4x4: function (count) {
        var positions = [];
        var spacing = 0.28;
        for (var row = 0; row < 4; row++) {
          for (var col = 0; col < 4; col++) {
            if (positions.length >= count) break;
            positions.push({ x: (col - 1.5) * spacing, y: (row - 1.5) * spacing });
          }
        }
        return positions;
      },
      // 4x4 Square - exploded
      grid4x4Exploded: function (count) {
        var positions = [];
        var spacing = 0.28;
        var explode = 2.2;
        for (var row = 0; row < 4; row++) {
          for (var col = 0; col < 4; col++) {
            if (positions.length >= count) break;
            var x = (col - 1.5) * spacing;
            var y = (row - 1.5) * spacing;
            var dist = Math.sqrt(x * x + y * y);
            if (dist > 0.01) { x *= explode; y *= explode; }
            positions.push({ x: x, y: y });
          }
        }
        return positions;
      },
      // Double Diamond - inner (5) + outer (8)
      doubleDiamond: function (count) {
        var positions = [];
        var innerSize = 0.25;
        var outerSize = 0.55;
        // Inner diamond (5)
        positions.push({ x: 0, y: 0 });
        positions.push({ x: 0, y: -innerSize });
        positions.push({ x: innerSize, y: 0 });
        positions.push({ x: 0, y: innerSize });
        positions.push({ x: -innerSize, y: 0 });
        // Outer diamond (8)
        positions.push({ x: 0, y: -outerSize });
        positions.push({ x: outerSize, y: 0 });
        positions.push({ x: 0, y: outerSize });
        positions.push({ x: -outerSize, y: 0 });
        positions.push({ x: -outerSize * 0.7, y: -outerSize * 0.7 });
        positions.push({ x: outerSize * 0.7, y: -outerSize * 0.7 });
        positions.push({ x: outerSize * 0.7, y: outerSize * 0.7 });
        positions.push({ x: -outerSize * 0.7, y: outerSize * 0.7 });
        return positions.slice(0, count);
      },
      // Double Diamond - exploded
      doubleDiamondExploded: function (count) {
        var positions = [];
        var innerSize = 0.5;
        var outerSize = 1.1;
        positions.push({ x: 0, y: 0 });
        positions.push({ x: 0, y: -innerSize });
        positions.push({ x: innerSize, y: 0 });
        positions.push({ x: 0, y: innerSize });
        positions.push({ x: -innerSize, y: 0 });
        positions.push({ x: 0, y: -outerSize });
        positions.push({ x: outerSize, y: 0 });
        positions.push({ x: 0, y: outerSize });
        positions.push({ x: -outerSize, y: 0 });
        positions.push({ x: -outerSize * 0.7, y: -outerSize * 0.7 });
        positions.push({ x: outerSize * 0.7, y: -outerSize * 0.7 });
        positions.push({ x: outerSize * 0.7, y: outerSize * 0.7 });
        positions.push({ x: -outerSize * 0.7, y: outerSize * 0.7 });
        return positions.slice(0, count);
      },
      // Double V - front V (5) + rear V (6)
      doubleV: function (count) {
        var positions = [];
        var spacing = 0.22;
        // Front V (closer to bottom, 5 enemies)
        positions.push({ x: 0, y: 0.3 }); // tip
        positions.push({ x: -spacing, y: 0.1 });
        positions.push({ x: spacing, y: 0.1 });
        positions.push({ x: -spacing * 2, y: -0.1 });
        positions.push({ x: spacing * 2, y: -0.1 });
        // Rear V (further back, 6 enemies)
        positions.push({ x: 0, y: -0.15 }); // tip
        positions.push({ x: -spacing, y: -0.35 });
        positions.push({ x: spacing, y: -0.35 });
        positions.push({ x: -spacing * 2, y: -0.55 });
        positions.push({ x: spacing * 2, y: -0.55 });
        positions.push({ x: 0, y: -0.55 }); // extra center back
        return positions.slice(0, count);
      },
      // Double V - exploded
      doubleVExploded: function (count) {
        var positions = [];
        var spacing = 0.45;
        positions.push({ x: 0, y: 0.6 });
        positions.push({ x: -spacing, y: 0.2 });
        positions.push({ x: spacing, y: 0.2 });
        positions.push({ x: -spacing * 2, y: -0.2 });
        positions.push({ x: spacing * 2, y: -0.2 });
        positions.push({ x: 0, y: -0.3 });
        positions.push({ x: -spacing, y: -0.7 });
        positions.push({ x: spacing, y: -0.7 });
        positions.push({ x: -spacing * 2, y: -1.1 });
        positions.push({ x: spacing * 2, y: -1.1 });
        positions.push({ x: 0, y: -1.1 });
        return positions.slice(0, count);
      },
      // Dual Sine Waves - two parallel wavy lines
      dualSineWave: function (count) {
        var positions = [];
        var half = Math.floor(count / 2);
        var xSpacing = 0.2;
        var amplitude = 0.15;
        // Top wave
        for (var i = 0; i < half; i++) {
          var x = (i - (half - 1) / 2) * xSpacing;
          var y = Math.sin(i * 0.8) * amplitude - 0.25;
          positions.push({ x: x, y: y });
        }
        // Bottom wave (offset phase)
        for (var i = 0; i < count - half; i++) {
          var x = (i - (count - half - 1) / 2) * xSpacing;
          var y = Math.sin(i * 0.8 + Math.PI) * amplitude + 0.25;
          positions.push({ x: x, y: y });
        }
        return positions;
      },
      // Dual Sine Waves - exploded
      dualSineWaveExploded: function (count) {
        var positions = [];
        var half = Math.floor(count / 2);
        var xSpacing = 0.35;
        var amplitude = 0.3;
        for (var i = 0; i < half; i++) {
          var x = (i - (half - 1) / 2) * xSpacing;
          var y = Math.sin(i * 0.8) * amplitude - 0.55;
          positions.push({ x: x, y: y });
        }
        for (var i = 0; i < count - half; i++) {
          var x = (i - (count - half - 1) / 2) * xSpacing;
          var y = Math.sin(i * 0.8 + Math.PI) * amplitude + 0.55;
          positions.push({ x: x, y: y });
        }
        return positions;
      },

      // Spiral - Archimedean spiral (collapsed)
      // Min radius 0.56 ensures arc-spacing >= enemy width at spreadRadius=175
      spiral: function (count) {
        var positions = [];
        for (var i = 0; i < count; i++) {
          var t = (i / count) * Math.PI * 3.5; // 1.75 full turns
          var r = 0.56 + 0.32 * (i / count);   // range 0.56‚Äì0.88
          positions.push({ x: Math.cos(t) * r, y: Math.sin(t) * r * 0.55 });
        }
        return positions;
      },
      // Spiral - exploded (wide scatter along spiral arms)
      spiralExploded: function (count) {
        var positions = [];
        for (var i = 0; i < count; i++) {
          var t = (i / count) * Math.PI * 3.5;
          var r = 0.62 + 0.36 * (i / count);   // range 0.62‚Äì0.98, all start wide
          positions.push({ x: Math.cos(t) * r, y: Math.sin(t) * r * 0.45 });
        }
        return positions;
      },

      // Hex Grid - honeycomb layout (collapsed)
      hexGrid: function (count) {
        var positions = [];
        var spacing = 0.28;
        // Offset rows to form hex grid
        var layout = [
          [-1, -0.5], [0, -0.5], [1, -0.5],
          [-0.5, 0], [0.5, 0],
          [-1, 0.5], [0, 0.5], [1, 0.5],
          [-0.5, -1], [0.5, -1],
          [-0.5, 1], [0.5, 1],
          [0, -1.5], [0, 1.5],
          [-1, -1.5], [1, -1.5],
          [-1, 1.5], [1, 1.5]
        ];
        for (var i = 0; i < Math.min(count, layout.length); i++) {
          positions.push({ x: layout[i][0] * spacing, y: layout[i][1] * spacing });
        }
        return positions.slice(0, count);
      },
      // Hex Grid - exploded
      hexGridExploded: function (count) {
        var positions = [];
        var spacing = 0.28;
        var explode = 2.8;
        var layout = [
          [-1, -0.5], [0, -0.5], [1, -0.5],
          [-0.5, 0], [0.5, 0],
          [-1, 0.5], [0, 0.5], [1, 0.5],
          [-0.5, -1], [0.5, -1],
          [-0.5, 1], [0.5, 1],
          [0, -1.5], [0, 1.5],
          [-1, -1.5], [1, -1.5],
          [-1, 1.5], [1, 1.5]
        ];
        for (var i = 0; i < Math.min(count, layout.length); i++) {
          var x = layout[i][0] * spacing;
          var y = layout[i][1] * spacing;
          var dist = Math.sqrt(x * x + y * y);
          if (dist > 0.01) { x *= explode; y *= explode; }
          positions.push({ x: x, y: y });
        }
        return positions.slice(0, count);
      },

      // Twin Circles - two concentric rings (collapsed)
      twinCircles: function (count) {
        var positions = [];
        var innerCount = Math.floor(count * 0.45);
        var outerCount = count - innerCount;
        var innerR = 0.25;
        var outerR = 0.55;
        for (var i = 0; i < innerCount; i++) {
          var a = (i / innerCount) * Math.PI * 2;
          positions.push({ x: Math.cos(a) * innerR, y: Math.sin(a) * innerR * 0.7 });
        }
        for (var i = 0; i < outerCount; i++) {
          var a = (i / outerCount) * Math.PI * 2;
          positions.push({ x: Math.cos(a) * outerR, y: Math.sin(a) * outerR * 0.7 });
        }
        return positions;
      },
      // Twin Circles - exploded
      twinCirclesExploded: function (count) {
        var positions = [];
        var innerCount = Math.floor(count * 0.45);
        var outerCount = count - innerCount;
        var innerR = 0.6;
        var outerR = 1.2;
        for (var i = 0; i < innerCount; i++) {
          var a = (i / innerCount) * Math.PI * 2;
          positions.push({ x: Math.cos(a) * innerR, y: Math.sin(a) * innerR * 0.7 });
        }
        for (var i = 0; i < outerCount; i++) {
          var a = (i / outerCount) * Math.PI * 2;
          positions.push({ x: Math.cos(a) * outerR, y: Math.sin(a) * outerR * 0.7 });
        }
        return positions;
      },

      // Arrowhead - filled triangle pointing down (collapsed)
      arrowhead: function (count) {
        var positions = [];
        var rows = Math.ceil(Math.sqrt(count * 2));
        for (var row = 0; row < rows && positions.length < count; row++) {
          var cols = rows - row;
          var yPos = -0.45 + row * (0.9 / (rows - 1));
          for (var col = 0; col < cols && positions.length < count; col++) {
            var xPos = cols === 1 ? 0 : (col / (cols - 1) - 0.5) * (cols * 0.28);
            positions.push({ x: xPos, y: yPos });
          }
        }
        return positions.slice(0, count);
      },
      // Arrowhead - exploded (wide fan)
      arrowheadExploded: function (count) {
        var positions = [];
        var rows = Math.ceil(Math.sqrt(count * 2));
        var explode = 2.4;
        for (var row = 0; row < rows && positions.length < count; row++) {
          var cols = rows - row;
          var yPos = -0.45 + row * (0.9 / (rows - 1));
          for (var col = 0; col < cols && positions.length < count; col++) {
            var xPos = cols === 1 ? 0 : (col / (cols - 1) - 0.5) * (cols * 0.28);
            positions.push({ x: xPos * explode, y: yPos * explode });
          }
        }
        return positions.slice(0, count);
      }
    };

    // Level definitions - single wave per level
    // Dance pattern: exploded (enter) -> collapsed -> exploded (repeat)
    // Barriers: circle, horizontalLine, arrow, orbitingShield, dualLines
    var LEVEL_WAVES = {
      1: {
        enemyType: 'enemy1',
        waves: [
          { count: 9, kamikazes: 2, shapes: ['grid3x3Exploded', 'grid3x3'], barrier: 'circle', barrierCount: 5 }
        ]
      },
      2: {
        enemyType: 'enemy2',
        waves: [
          { count: 9, kamikazes: 2, shapes: ['diamondExploded', 'diamond'], barrier: 'horizontalLine', barrierCount: 5 }
        ]
      },
      3: {
        enemyType: 'enemy3',
        waves: [
          { count: 10, kamikazes: 3, shapes: ['circleExploded', 'circle'], barrier: null }
        ]
      },
      4: {
        enemyType: 'enemy4',
        waves: [
          { count: 9, kamikazes: 3, shapes: ['flyingVExploded', 'flyingV'], barrier: 'arrow', barrierCount: 5 }
        ]
      },
      5: {
        enemyType: 'enemy1_red',
        waves: [
          { count: 16, kamikazes: 3, shapes: ['grid4x4Exploded', 'grid4x4'], barrier: null }
        ]
      },
      6: {
        enemyType: 'enemy2_red',
        waves: [
          { count: 13, kamikazes: 3, shapes: ['doubleDiamondExploded', 'doubleDiamond'], barrier: 'orbitingShield', barrierCount: 6 }
        ]
      },
      7: {
        enemyType: 'enemy3_red',
        waves: [
          { count: 11, kamikazes: 4, shapes: ['doubleVExploded', 'doubleV'], barrier: null }
        ]
      },
      8: {
        enemyType: 'enemy4_red',
        waves: [
          { count: 12, kamikazes: 4, shapes: ['dualSineWaveExploded', 'dualSineWave'], barrier: 'dualLines', barrierCount: 8 }
        ]
      },
      9: {
        enemyType: 'enemy1_purple',
        waves: [
          { count: 18, kamikazes: 4, shapes: ['spiralExploded', 'spiral'], barrier: 'orbitingShield', barrierCount: 8 }
        ]
      },
      10: {
        enemyType: 'enemy2_purple',
        waves: [
          { count: 20, kamikazes: 5, shapes: ['hexGridExploded', 'hexGrid'], barrier: 'dualLines', barrierCount: 10 }
        ]
      },
      11: {
        enemyType: 'enemy3_purple',
        waves: [
          { count: 22, kamikazes: 5, shapes: ['twinCirclesExploded', 'twinCircles'], barrier: 'circle', barrierCount: 8 }
        ]
      },
      12: {
        enemyType: 'enemy4_purple',
        waves: [
          { count: 25, kamikazes: 6, shapes: ['arrowheadExploded', 'arrowhead'], barrier: 'arrow', barrierCount: 8 }
        ]
      }
    };

    // Barrier reinforcement tracking
    var morphCount = 0;
    var barrierSpawned = false;
    var barrierEnemies = []; // Track barrier enemies separately

    /**
     * Initialises and begins a numbered wave for the current level. Resets all
     * formation and barrier tracking state, then delegates to
     * `spawnMorphingFormation()` to create the enemy group.
     * @param {number} waveNum - 1-based wave index within the current level.
     */
    function startWave(waveNum) {
      var levelData = LEVEL_WAVES[level];
      if (!levelData || waveNum > levelData.waves.length) return;

      currentWave = waveNum;
      waveInProgress = true;
      waveCooldown = false;
      morphStartTime = Date.now();
      currentMorphShape = 0;

      // Reset formation and barrier tracking
      formationRotation = 0;
      targetFormationRotation = 0;
      lastMorphTime = Date.now();
      morphCount = 0;
      barrierSpawned = false;
      barrierEnemies = [];
      pendingKamikazeCount = 0;
      kamikazesLaunched = false;

      var waveData = levelData.waves[waveNum - 1];
      waveEnemiesRemaining = waveData.count;

      spawnMorphingFormation(waveData);

      showAnnouncement("levelDisplay", "Level " + level, 1500);
    }

    // Formation center tracking - moves as a unit
    var formationCurrentCenterY = -120;
    var formationTargetCenterY = 160;
    var formationEntrySpeed = 1.8;
    var formationEntered = false;

    // Kamikaze wave tracking (separate from formation)
    var pendingKamikazeCount = 0;
    var kamikazesLaunched = false;
    var kamikazeCenterY = -80;
    var kamikazeCenterTargetY = 120;
    var kamikazeCenterActive = false;

    // Shield cascade system
    var shieldCascadeStarted = false;
    var shieldCascadeTime = 0;
    var shieldsDropped = 0;
    var allShieldsDown = false;
    var shieldRegenTime = 0;

    /**
     * Instantiates all formation enemies for the current wave. Enemies enter
     * from above the canvas in the first (exploded) shape and are marked
     * `formation: true`. Each enemy carries its `waveShapes` list so
     * `updateMorphingFormation()` knows what to cycle through. All formation
     * enemies start shielded.
     * @param {Object} waveData - Wave descriptor from `LEVEL_WAVES[level].waves`.
     */
    function spawnMorphingFormation(waveData) {
      var count = waveData.count;
      var centerX = canvas.width / 2;
      var targetY = 160;
      var spreadRadius = purplePhase ? 175 : 140;

      // Store kamikaze count to be launched separately after formation settles
      pendingKamikazeCount = waveData.kamikazes || 2;
      kamikazesLaunched = false;

      // Reset formation center - starts well above screen so all enemies enter from top
      formationCurrentCenterY = -200;
      formationTargetCenterY = targetY;
      formationEntered = false;

      var levelData = LEVEL_WAVES[level];
      var enemyType = levelData.enemyType;

      // Get initial shape positions (exploded - enters spread out)
      var shapeFunc = FORMATION_SHAPES[waveData.shapes[0]];
      if (typeof shapeFunc !== 'function') {
        console.error('Formation shape not found:', waveData.shapes[0]);
        shapeFunc = FORMATION_SHAPES['grid3x3']; // safe fallback
      }
      var positions = shapeFunc(count);

      for (var i = 0; i < count; i++) {
        var pos = positions[i];
        var width = 50;
        var height = 50;

        if (enemyType === 'enemy2_red' || enemyType === 'enemy2_purple') {
          width = 35;
          height = 35;
        }

        // Position relative to formation center (which will move)
        var enemy = {
          x: centerX + pos.x * spreadRadius - width / 2,
          y: formationCurrentCenterY + pos.y * spreadRadius * 0.8 - height / 2,
          width: width,
          height: height,
          baseWidth: width,
          baseHeight: height,
          speed: formationEntrySpeed,
          type: enemyType,
          formation: true,
          formationType: 'morphing',
          targetY: targetY,
          reachedTarget: false,
          formationIndex: i,
          formationCount: count,
          waveShapes: waveData.shapes,
          spreadRadius: spreadRadius,
          centerX: centerX,
          centerY: targetY,
          breathPhase: i * 0.12,
          startPos: { x: pos.x, y: pos.y },
          currentPos: { x: pos.x, y: pos.y },
          targetPos: { x: pos.x, y: pos.y },
          shielded: true,  // Start with shield
          shieldOrder: i,  // Order for cascade (lower = drops first)
          nextShootTime: Date.now() + 2000 + Math.random() * 4000  // Staggered random shoot times
        };

        enemies.push(enemy);
      }

      // Reset shield cascade tracking
      shieldCascadeStarted = false;
      shieldCascadeTime = 0;
      shieldsDropped = 0;
      allShieldsDown = false;
      shieldRegenTime = 0;
    }

    /**
     * Spawns a group of kamikaze enemies that first enter from the top in a
     * horizontal spread, then dive toward the player's position once the group
     * center has reached its target Y (handled by `updateKamikazeEntry`).
     * @param {number} count - Number of kamikaze enemies to spawn.
     */
    function spawnKamikazeWave(count) {
      var levelData = LEVEL_WAVES[level];
      var enemyType = levelData ? levelData.enemyType : 'enemy1';
      var width = 50, height = 50;
      if (enemyType === 'enemy2_red' || enemyType === 'enemy2_purple') { width = 35; height = 35; }

      // Set up center that will scroll down, all kamikazes follow it
      kamikazeCenterY = -80;
      kamikazeCenterTargetY = 120;
      kamikazeCenterActive = true;

      // Spread evenly across screen width, with slight random jitter
      var spacing = (canvas.width - 80) / (count + 1);
      for (var k = 0; k < count; k++) {
        var centerOffsetX = (spacing * (k + 1) + 40) - canvas.width / 2;
        centerOffsetX += (Math.random() - 0.5) * 30;
        enemies.push({
          x: canvas.width / 2 + centerOffsetX - width / 2,
          y: kamikazeCenterY - height / 2,
          width: width,
          height: height,
          baseWidth: width,
          baseHeight: height,
          type: enemyType,
          formation: false,
          kamikaze: true,
          kamikazeEntering: true,
          kamikazeCenterOffsetX: centerOffsetX,
          shielded: false,
          breathPhase: Math.random()
        });
      }
    }

    /**
     * Moves the invisible kamikaze group center downward each frame. Once it
     * reaches its target Y, all kamikazes are given a velocity vector aimed at
     * the player's current position and begin their dive.
     */
    function updateKamikazeEntry() {
      if (!kamikazeCenterActive) return;

      kamikazeCenterY += formationEntrySpeed;

      if (kamikazeCenterY >= kamikazeCenterTargetY) {
        kamikazeCenterY = kamikazeCenterTargetY;
        kamikazeCenterActive = false;

        // Center has landed ‚Äî trigger all kamikazes to dive
        for (var i = 0; i < enemies.length; i++) {
          var e = enemies[i];
          if (e.kamikaze && e.kamikazeEntering) {
            e.kamikazeEntering = false;
            var speed = (purplePhase ? 4.5 : 4) + Math.random() * 2;
            var dx = player.x + player.width / 2 - (e.x + e.width / 2);
            var dy = player.y + player.height / 2 - (e.y + e.height / 2);
            var dist = Math.sqrt(dx * dx + dy * dy) || 1;
            e.kamikazeVelX = (dx / dist) * speed;
            e.kamikazeVelY = (dy / dist) * speed;
            e.kamikazeSpeed = speed;
          }
        }
      } else {
        // Update all entering kamikaze positions relative to descending center
        for (var i = 0; i < enemies.length; i++) {
          var e = enemies[i];
          if (e.kamikaze && e.kamikazeEntering) {
            e.x = canvas.width / 2 + e.kamikazeCenterOffsetX - e.width / 2;
            e.y = kamikazeCenterY - e.height / 2;
          }
        }
      }
    }

    // Track formation for simple dance
    var formationRotation = 0;
    var targetFormationRotation = 0;
    var lastMorphTime = 0;

    /**
     * Cubic ease-in-out interpolation for smooth, natural formation movement.
     * @param {number} t - Progress from 0.0 (start) to 1.0 (end).
     * @returns {number} Eased value in the same 0‚Äì1 range.
     */
    function easeInOutCubic(t) {
      return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }

    /**
     * Drives the formation dance cycle. Every 6 BPM beats (~3 s) the formation
     * switches to the next shape in `waveShapes`, updating each enemy's
     * `targetPos`. Enemy positions are smoothly lerped using `easeInOutCubic`
     * over 70% of the morph interval, then held. Also triggers kamikaze launch
     * after the second morph and shield cascade after the third.
     * @param {number} time - Current timestamp from `Date.now()`.
     */
    function updateMorphingFormation(time) {
      // Dance timing: morph every 6 beats (~3 seconds at 123 BPM)
      var morphInterval = BPM_INTERVAL * 6;
      var timeSinceStart = time - morphStartTime;
      var newShapeIndex = Math.floor(timeSinceStart / morphInterval);

      // Get formation enemies
      var formationEnemies = enemies.filter(function (e) { return e.formation && e.formationType === 'morphing'; });
      if (formationEnemies.length === 0) return;

      var waveShapes = formationEnemies[0].waveShapes;
      if (!waveShapes) return;

      // Cycle through shapes (tightGrid -> exploded -> tightGrid -> exploded...)
      newShapeIndex = newShapeIndex % waveShapes.length;

      // If shape changed, update target positions
      if (newShapeIndex !== currentMorphShape) {
        currentMorphShape = newShapeIndex;
        morphCount++;
        lastMorphTime = time;

        // Hide shield warning after 3 morphs (enemies now vulnerable)
        if (morphCount === 3) {
          document.getElementById("warningDisplay").style.display = "none";
        }

        // Spawn barrier after first collapse (morphCount 1 = collapsed state)
        if (morphCount === 1 && !barrierSpawned) {
          var levelData = LEVEL_WAVES[level];
          var waveData = levelData.waves[currentWave - 1];
          if (waveData.barrier) {
            spawnBarrier(waveData.barrier, waveData.barrierCount || 5);
          }
        }

        var shapeName = waveShapes[newShapeIndex];
        var shapeFunc = FORMATION_SHAPES[shapeName];
        if (typeof shapeFunc !== 'function') {
          console.error('Morph shape not found:', shapeName, '(index', newShapeIndex, ')');
          shapeFunc = FORMATION_SHAPES['grid3x3']; // safe fallback
        }
        var count = formationEnemies[0].formationCount;
        var newPositions = shapeFunc(count);

        // Store starting positions and update targets
        formationEnemies.forEach(function (enemy, idx) {
          if (newPositions[idx]) {
            enemy.startPos = { x: enemy.currentPos.x, y: enemy.currentPos.y };
            enemy.targetPos = { x: newPositions[idx].x, y: newPositions[idx].y };
          }
        });

        // Launch kamikaze wave separately after formation has settled (morphCount 2)
        if (morphCount === 2 && !kamikazesLaunched && pendingKamikazeCount > 0) {
          kamikazesLaunched = true;
          spawnKamikazeWave(pendingKamikazeCount);
        }
      }

      // Calculate eased progress (use 70% of interval for transition, hold for rest)
      var morphDuration = morphInterval * 0.7;
      var timeSinceMorph = time - lastMorphTime;
      var morphProgress = Math.min(timeSinceMorph / morphDuration, 1);
      var easedProgress = easeInOutCubic(morphProgress);

      formationEnemies.forEach(function (enemy) {
        if (!enemy.reachedTarget) return;

        // Smooth interpolation between positions
        if (enemy.startPos) {
          enemy.currentPos.x = enemy.startPos.x + (enemy.targetPos.x - enemy.startPos.x) * easedProgress;
          enemy.currentPos.y = enemy.startPos.y + (enemy.targetPos.y - enemy.startPos.y) * easedProgress;
        } else {
          enemy.currentPos.x = enemy.targetPos.x;
          enemy.currentPos.y = enemy.targetPos.y;
        }

        // Calculate actual position (no rotation - clean dance)
        var baseX = enemy.centerX + enemy.currentPos.x * enemy.spreadRadius;
        var baseY = enemy.centerY + enemy.currentPos.y * enemy.spreadRadius * 0.8;

        enemy.x = baseX - enemy.width / 2;
        enemy.y = baseY - enemy.height / 2;

        // Keep in bounds
        if (enemy.x < 20) enemy.x = 20;
        if (enemy.x > canvas.width - enemy.width - 20) enemy.x = canvas.width - enemy.width - 20;
        if (enemy.y < 30) enemy.y = 30;
        if (enemy.y > canvas.height * 0.5) enemy.y = canvas.height * 0.5;
      });
    }

    /**
     * Manages the rolling shield cascade for formation enemies. After 3 morphs,
     * shields drop 2-at-a-time every 2 seconds (ordered by `shieldOrder`).
     * Once all shields are down they regenerate after 5 seconds. Shields
     * permanently broken by 15+ hits (25+ at level 9+) are excluded from regen.
     */
    function updateShieldCascade() {
      var formationEnemies = enemies.filter(function (e) {
        return e.formation && e.formationType === 'morphing';
      });
      if (formationEnemies.length === 0) return;

      var now = Date.now();

      // Start cascade after 3 morphs
      if (morphCount >= 3 && !shieldCascadeStarted) {
        shieldCascadeStarted = true;
        shieldCascadeTime = now;
        shieldsDropped = 0;
        allShieldsDown = false;
      }

      if (!shieldCascadeStarted) return;

      // If all shields are down, check for regeneration
      if (allShieldsDown) {
        if (now - shieldRegenTime >= 5000) {
          // Regenerate all shields (except those broken by 25 hits)
          formationEnemies.forEach(function (e) {
            if (!e.shieldBroken) {
              e.shielded = true;
              e.shieldHits = 0; // Reset hit counter on regen
            }
          });
          // Reset cascade
          shieldCascadeStarted = true;
          shieldCascadeTime = now;
          shieldsDropped = 0;
          allShieldsDown = false;
          // Show brief warning for shield regen
          var warningEl = document.getElementById("warningDisplay");
          warningEl.style.display = "block";
          setTimeout(function () {
            warningEl.style.display = "none";
          }, 1500);
        }
        return;
      }

      // Drop shields every 2 seconds (2 enemies at a time)
      var timeSinceCascadeStart = now - shieldCascadeTime;
      var shouldHaveDropped = Math.floor(timeSinceCascadeStart / 2000) * 2;

      if (shouldHaveDropped > shieldsDropped) {
        // Find shielded enemies sorted by shieldOrder
        var shieldedEnemies = formationEnemies
          .filter(function (e) { return e.shielded; })
          .sort(function (a, b) { return a.shieldOrder - b.shieldOrder; });

        // Drop shields from next 2 enemies
        var toDrop = Math.min(2, shieldedEnemies.length);
        for (var i = 0; i < toDrop; i++) {
          shieldedEnemies[i].shielded = false;
        }
        shieldsDropped += toDrop;

        // Check if all shields are now down
        var remainingShielded = formationEnemies.filter(function (e) { return e.shielded; });
        if (remainingShielded.length === 0) {
          allShieldsDown = true;
          shieldRegenTime = now;
        }
      }
    }

    // Spawn barrier reinforcements (4-8 enemies forming a protective barrier)
    // Barriers stay between player and formation, no further than halfway down screen
    function spawnBarrier(barrierType, count) {
      if (barrierSpawned) return;
      barrierSpawned = true;

      var levelData = LEVEL_WAVES[level];
      var enemyType = levelData ? levelData.enemyType : 'enemy1';
      var width = 50;
      var height = 50;
      if (enemyType === 'enemy2_red' || enemyType === 'enemy2_purple') { width = 35; height = 35; }

      var centerX = canvas.width / 2;
      var barrierY = canvas.height * 0.45; // Halfway down screen max

      if (barrierType === 'circle' || barrierType === 'orbitingShield') {
        // Circle/orbiting barrier ‚Äî enemies drop from above screen to their orbit start position
        var radius = 180;
        var orbitSpeed = barrierType === 'orbitingShield' ? 0.015 : 0.01;
        for (var i = 0; i < count; i++) {
          var angle = (i / count) * Math.PI * 2;
          var orbitX = centerX + Math.cos(angle) * radius - width / 2;
          var orbitY = 160 + Math.sin(angle) * radius * 0.6 - height / 2;
          var enemy = {
            x: orbitX,
            y: -height,           // start above screen
            targetY: orbitY,      // drop to orbit start position
            width: width,
            height: height,
            baseWidth: width,
            baseHeight: height,
            speed: 2.5,
            type: enemyType,
            formation: false,
            barrier: true,
            barrierType: 'orbit',
            orbitEntering: true,  // entering phase before orbiting begins
            orbitAngle: angle,
            orbitRadius: radius,
            orbitSpeed: orbitSpeed,
            orbitCenterX: centerX,
            orbitCenterY: 160,
            breathPhase: i * 0.3
          };
          enemies.push(enemy);
          barrierEnemies.push(enemy);
        }
      } else if (barrierType === 'horizontalLine') {
        // Horizontal line that moves side to side
        var lineWidth = (count - 1) * 70;
        var startX = centerX - lineWidth / 2;
        for (var i = 0; i < count; i++) {
          var enemy = {
            x: startX + i * 70 - width / 2,
            y: -height, // Enter from top
            targetY: barrierY,
            width: width,
            height: height,
            baseWidth: width,
            baseHeight: height,
            speed: 2.5,
            type: enemyType,
            formation: false,
            barrier: true,
            barrierType: 'horizontalLine',
            lineIndex: i,
            lineDirection: 1,
            lineSpeed: 1.5,
            breathPhase: i * 0.2
          };
          enemies.push(enemy);
          barrierEnemies.push(enemy);
        }
      } else if (barrierType === 'arrow') {
        // Arrow/V formation entering from top
        var spacing = 55;
        var half = Math.floor(count / 2);
        for (var i = 0; i < count; i++) {
          var xOffset, yOffset;
          if (i === 0) {
            xOffset = 0; yOffset = 0; // Tip
          } else if (i <= half) {
            xOffset = -spacing * i;
            yOffset = -spacing * i * 0.6;
          } else {
            xOffset = spacing * (i - half);
            yOffset = -spacing * (i - half) * 0.6;
          }
          var enemy = {
            x: centerX + xOffset - width / 2,
            y: -height - Math.abs(yOffset), // Stagger entry
            targetY: barrierY + yOffset,
            width: width,
            height: height,
            baseWidth: width,
            baseHeight: height,
            speed: 2.0,
            type: enemyType,
            formation: false,
            barrier: true,
            barrierType: 'arrow',
            arrowOffset: xOffset,
            breathPhase: i * 0.25
          };
          enemies.push(enemy);
          barrierEnemies.push(enemy);
        }
      } else if (barrierType === 'dualLines') {
        // Two horizontal lines
        var lineCount = Math.floor(count / 2);
        var lineWidth = (lineCount - 1) * 70;
        var startX = centerX - lineWidth / 2;
        for (var line = 0; line < 2; line++) {
          var lineY = barrierY - 40 + line * 80;
          for (var i = 0; i < lineCount; i++) {
            if (enemies.filter(function (e) { return e.barrier; }).length >= count) break;
            var enemy = {
              x: startX + i * 70 - width / 2,
              y: -height - line * 50,
              targetY: lineY,
              width: width,
              height: height,
              baseWidth: width,
              baseHeight: height,
              speed: 2.5,
              type: enemyType,
              formation: false,
              barrier: true,
              barrierType: 'horizontalLine',
              lineIndex: i,
              lineDirection: line === 0 ? 1 : -1,
              lineSpeed: 1.2,
              breathPhase: (line * lineCount + i) * 0.15
            };
            enemies.push(enemy);
            barrierEnemies.push(enemy);
          }
        }
      }
    }

    // Update barrier enemy positions
    function updateBarriers() {
      enemies.forEach(function (enemy) {
        if (!enemy.barrier) return;

        if (enemy.barrierType === 'orbit') {
          // Entry phase: drop from above screen to orbit start position
          if (enemy.orbitEntering) {
            if (enemy.y < enemy.targetY) {
              enemy.y += enemy.speed;
            } else {
              enemy.y = enemy.targetY;
              enemy.orbitEntering = false;
            }
          } else {
            // Orbit around formation center
            enemy.orbitAngle += enemy.orbitSpeed;
            enemy.x = enemy.orbitCenterX + Math.cos(enemy.orbitAngle) * enemy.orbitRadius - enemy.width / 2;
            enemy.y = enemy.orbitCenterY + Math.sin(enemy.orbitAngle) * enemy.orbitRadius * 0.6 - enemy.height / 2;
          }
        } else if (enemy.barrierType === 'horizontalLine') {
          // Move down to target then oscillate side to side
          if (enemy.y < enemy.targetY) {
            enemy.y += enemy.speed;
          } else {
            enemy.y = enemy.targetY;
            enemy.x += enemy.lineDirection * enemy.lineSpeed;
            // Bounce off screen edges
            if (enemy.x < 30 || enemy.x > canvas.width - enemy.width - 30) {
              enemy.lineDirection *= -1;
            }
          }
        } else if (enemy.barrierType === 'arrow') {
          // Move down to target position
          if (enemy.y < enemy.targetY) {
            enemy.y += enemy.speed;
          }
        }

        // Keep active (non-entering) barriers in upper half of screen
        if (!enemy.orbitEntering && enemy.y > canvas.height * 0.5) {
          enemy.y = canvas.height * 0.5;
        }
      });
    }

    /**
     * Polls whether all formation enemies have been destroyed. When the wave
     * is cleared, either starts the next wave within the level (after 3 s) or
     * calls `advanceLevel()` to move to the next level (after 2 s).
     */
    function checkWaveCompletion() {
      if (!waveInProgress) return;

      // Count remaining formation enemies
      var formationCount = enemies.filter(function (e) { return e.formation; }).length;

      if (formationCount === 0) {
        waveInProgress = false;
        waveCooldown = true;
        lastWaveEndTime = Date.now();

        var levelData = LEVEL_WAVES[level];
        if (currentWave < levelData.waves.length) {
          // Start next wave after delay
          setTimeout(function () {
            if (!gameOver && !bossActive) {
              startWave(currentWave + 1);
            }
          }, 3000);
        } else {
          // Level complete - advance to next level or boss
          setTimeout(function () {
            if (!gameOver && !bossActive) {
              advanceLevel();
            }
          }, 2000);
        }
      }
    }

    /**
     * Progresses the game to the next level or triggers a boss encounter.
     * Boss checks happen at level/score thresholds; phase caps prevent
     * skipping to a phase whose boss hasn't been defeated yet. Resets per-level
     * power-up tracking and starts the first wave of the new level.
     */
    function advanceLevel() {
      // Check for boss triggers
      if (!redPhase && level >= 4 && score >= CONFIG.boss1ScoreThreshold && !boss1Defeated) {
        currentBoss = 1;
        spawnBoss();
        return;
      }

      if (redPhase && !purplePhase && level >= 8 && score >= CONFIG.boss2ScoreThreshold && !boss2Defeated) {
        currentBoss = 2;
        spawnBoss();
        return;
      }

      if (purplePhase && level >= 12 && score >= CONFIG.boss3ScoreThreshold && !boss3Defeated) {
        currentBoss = 3;
        spawnBoss();
        return;
      }

      // Advance to next level
      var nextLevel = level + 1;

      // Handle level caps
      if (!redPhase && nextLevel > 4) {
        // Wait for boss 1
        return;
      }
      if (redPhase && !purplePhase && nextLevel > 8) {
        // Wait for boss 2
        return;
      }
      if (purplePhase && nextLevel > 12) {
        // Wait for boss 3
        return;
      }

      level = nextLevel;
      currentWave = 0;
      powerupsSpawnedThisLevel = { health: false, doubleLaser: false, shield: false };
      lastPowerupSpawnTime = 0; // Reset power-up cooldown for new level
      updateUI();
      showAnnouncement("levelDisplay", "Level " + level, 2000);

      // Start first wave of new level
      setTimeout(function () {
        if (!gameOver && !bossActive) {
          startWave(1);
        }
      }, 2500);
    }

    // Legacy formation functions (kept for boss fight variety)
    // Note: spawnSpiralFormation, spawnPincerFormation, spawnSineWaveFormation
    // are defined here but currently unused in the live wave system.
    // They are available for future boss-fight scripted sequences.

    /** Spawns 6 enemies at staggered intervals, each entering at the top center
     *  and then orbiting in a circular formation around y=150. */
    function spawnSpiralFormation() {
      var enemyType = getEnemyType();
      var count = 6;
      var centerX = canvas.width / 2;
      var targetY = 150;

      for (var i = 0; i < count; i++) {
        (function (index) {
          setTimeout(function () {
            var angle = (index / count) * Math.PI * 2;

            var enemy = {
              x: centerX,
              y: -50 - (index * 30),
              width: 50,
              height: 50,
              baseWidth: 50,
              baseHeight: 50,
              speed: 2,
              type: enemyType,
              formation: true,
              formationType: 'spiral',
              targetY: targetY,
              reachedTarget: false,
              spiralAngle: angle,
              spiralBaseRadius: 80,
              spiralCenterX: centerX,
              spiralCenterY: targetY,
              breathPhase: index * 0.3
            };
            enemies.push(enemy);
          }, index * 150);
        })(i);
      }
    }

    /**
     * Spawns a 3+3 pincer: three enemies enter from the left and three from the
     * right, sliding to fixed x targets then bouncing rhythmically in time with
     * the beat.
     */
    function spawnPincerFormation() {
      var enemyType = getEnemyType();
      var count = 3;
      var targetY = 120;

      for (var i = 0; i < count; i++) {
        (function (index) {
          setTimeout(function () {
            var enemy = {
              x: -50,
              y: targetY + index * 70,
              width: 50,
              height: 50,
              baseWidth: 50,
              baseHeight: 50,
              speed: 0,
              type: enemyType,
              formation: true,
              formationType: 'pincer',
              pincer: true,
              pincerSide: 'left',
              pincerSpeed: 3,
              pincerTargetX: 150,
              pincerBaseX: 150,
              reachedTarget: false,
              breathPhase: index * 0.4
            };
            enemies.push(enemy);
          }, index * 200);
        })(i);
      }

      for (var i = 0; i < count; i++) {
        (function (index) {
          setTimeout(function () {
            var enemy = {
              x: canvas.width,
              y: targetY + index * 70,
              width: 50,
              height: 50,
              baseWidth: 50,
              baseHeight: 50,
              speed: 0,
              type: enemyType,
              formation: true,
              formationType: 'pincer',
              pincer: true,
              pincerSide: 'right',
              pincerSpeed: 3,
              pincerTargetX: canvas.width - 200,
              pincerBaseX: canvas.width - 200,
              reachedTarget: false,
              breathPhase: index * 0.4
            };
            enemies.push(enemy);
          }, index * 200);
        })(i);
      }
    }

    /**
     * Spawns 8 enemies evenly spread across the screen width that descend to
     * y=100, then undulate horizontally in a sine-wave pattern synced to the
     * background music BPM.
     */
    function spawnSineWaveFormation() {
      var enemyType = getEnemyType();
      var count = 8;
      var targetY = 100;

      for (var i = 0; i < count; i++) {
        (function (index) {
          setTimeout(function () {
            var enemy = {
              x: 50 + index * ((canvas.width - 100) / count),
              y: -50,
              width: 50,
              height: 50,
              baseWidth: 50,
              baseHeight: 50,
              speed: 2,
              type: enemyType,
              formation: true,
              formationType: 'sineWave',
              sineWave: true,
              targetY: targetY,
              reachedTarget: false,
              sinePhase: index * 0.8,
              sineAmplitude: 60,
              baseX: 50 + index * ((canvas.width - 100) / count),
              baseY: targetY,
              breathPhase: index * 0.2
            };
            enemies.push(enemy);
          }, index * 100);
        })(i);
      }
    }

    /**
     * Renders a single enemy sprite with an optional BPM-synced breathing scale
     * (enemy2 variants only) and a colour-coded ripple ring that expands at
     * 123 BPM. Shielded enemies show a brighter, wider gold ripple with an
     * additional inner ring. The ripple colour reflects the enemy's type/phase.
     * @param {Object} enemy - Enemy object from the `enemies` array.
     */
    function drawEnemy(enemy) {
      var img;
      switch (enemy.type) {
        case 'enemy1': img = enemyImg1; break;
        case 'enemy2': img = enemyImg2; break;
        case 'enemy3': img = enemyImg3; break;
        case 'enemy4': img = enemyImg4; break;
        case 'enemy1_red': img = enemyImg1Red; break;
        case 'enemy2_red': img = enemyImg2Red; break;
        case 'enemy3_red': img = enemyImg3Red; break;
        case 'enemy4_red': img = enemyImg4Red; break;
        case 'enemy1_purple': img = enemyImg1Purple; break;
        case 'enemy2_purple': img = enemyImg2Purple; break;
        case 'enemy3_purple': img = enemyImg3Purple; break;
        case 'enemy4_purple': img = enemyImg4Purple; break;
        default: img = enemyImg1;
      }

      var time = Date.now();
      var cx = enemy.x + enemy.width / 2;
      var cy = enemy.y + enemy.height / 2;

      // Breathing effect - ONLY for enemy2 and enemy2_red
      var drawWidth = enemy.baseWidth || enemy.width;
      var drawHeight = enemy.baseHeight || enemy.height;

      if (enemy.type === 'enemy2' || enemy.type === 'enemy2_red' || enemy.type === 'enemy2_purple') {
        var breathInterval = BPM_INTERVAL * 2;
        var breathPhaseOffset = (enemy.breathPhase || 0) * breathInterval;
        var breathProgress = ((time + breathPhaseOffset) % breathInterval) / breathInterval;
        var breathScale = 1 + Math.sin(breathProgress * Math.PI) * 0.18;
        drawWidth = drawWidth * breathScale;
        drawHeight = drawHeight * breathScale;
      }

      var drawX = cx - drawWidth / 2;
      var drawY = cy - drawHeight / 2;

      // Check if enemy is shielded (formation enemy before 3 morphs)
      var isShielded = enemy.shielded === true;

      // Draw ripple effect for all enemies at 123 BPM
      var beatPhase = (time % BPM_INTERVAL) / BPM_INTERVAL;
      var maxRipple = enemy.width * (isShielded ? 1.4 : 1.0); // Larger ripple when shielded
      var rippleRadius = beatPhase * maxRipple;
      var rippleAlpha = 1 - beatPhase;

      // Different colors based on enemy type (golden shield color when protected)
      var rippleColor;
      if (isShielded) {
        // Golden/yellow shield ripple - fades to white as it weakens from hits
        var shieldHits = enemy.shieldHits || 0;
        var shieldBreakThreshold = level >= 9 ? 25 : 15;
        var shieldWeakness = Math.min(shieldHits / shieldBreakThreshold, 1); // 0 to 1
        // Interpolate from golden (255, 215, 0) to light yellow/white (255, 255, 200)
        var g = Math.round(215 + (255 - 215) * shieldWeakness); // 215 -> 255
        var b = Math.round(0 + 200 * shieldWeakness); // 0 -> 200
        rippleColor = 'rgba(255, ' + g + ', ' + b + ', ' + (rippleAlpha * 0.7) + ')';
      } else if (enemy.type.indexOf('_red') !== -1) {
        rippleColor = 'rgba(255, 80, 80, ' + (rippleAlpha * 0.4) + ')';
      } else if (enemy.type === 'enemy1') {
        rippleColor = 'rgba(100, 255, 100, ' + (rippleAlpha * 0.4) + ')';
      } else if (enemy.type === 'enemy2') {
        rippleColor = 'rgba(100, 200, 255, ' + (rippleAlpha * 0.4) + ')';
      } else if (enemy.type === 'enemy3') {
        rippleColor = 'rgba(255, 200, 100, ' + (rippleAlpha * 0.4) + ')';
      } else {
        rippleColor = 'rgba(200, 100, 255, ' + (rippleAlpha * 0.4) + ')';
      }

      ctx.save();
      ctx.beginPath();
      ctx.arc(cx, cy, rippleRadius, 0, Math.PI * 2);
      ctx.strokeStyle = rippleColor;
      ctx.lineWidth = isShielded ? 5 : 2; // Thicker line when shielded
      ctx.stroke();

      // Draw second inner ripple for shielded enemies
      if (isShielded) {
        var innerRippleRadius = rippleRadius * 0.6;
        ctx.beginPath();
        ctx.arc(cx, cy, innerRippleRadius, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(255, 255, 100, ' + (rippleAlpha * 0.5) + ')';
        ctx.lineWidth = 3;
        ctx.stroke();
      }
      ctx.restore();

      // Draw enemy
      ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
    }

    // ============================================
    // BOSS SYSTEM
    // ============================================
    // Boss orbiting soldiers
    var bossOrbiters = [];
    var maxOrbiters = 5;
    var orbiterRespawnDelay = 3000; // 3 seconds to respawn
    var lastOrbiterDeathTime = 0;
    var orbitersInitialized = false;

    // Smart filler management
    var maxBossFillers = 6;
    var lastBossFillerBeat = 0;
    var bossFillerBeatInterval = 4; // Spawn every 4 beats

    /**
     * Activates a boss encounter matching `currentBoss` (1 = green, 2 = red,
     * 3 = purple). Clears all existing enemies and minions, plays the boss sting,
     * and creates the boss object with a shield that is always active at the start.
     */
    function spawnBoss() {
      bossActive = true;
      enemies = []; // Clear regular enemies
      bossMinions = []; // Clear any existing minions
      bossOrbiters = []; // Clear orbiters
      orbitersInitialized = false;
      showAnnouncement("levelDisplay", "BOSS!", 2000);
      startBossMusic();

      var isRedBoss = (currentBoss === 2);
      var isPurpleBoss = (currentBoss === 3);
      boss = {
        x: canvas.width / 2 - 75,
        y: -150,
        width: 150,
        height: 150,
        health: CONFIG.bossHealth,
        maxHealth: CONFIG.bossHealth,
        speed: CONFIG.bossSpeed,
        direction: 1,
        verticalDirection: 1, // For red/purple boss vertical movement
        entering: true,
        isRedBoss: isRedBoss,
        isPurpleBoss: isPurpleBoss,
        // Boss shield system
        shielded: true, // Start with shield
        shieldStartTime: Date.now(),
        shieldDuration: 5000, // 5 seconds on
        shieldCooldown: 5000, // 5 seconds off (only for red/purple boss)
        shieldCycling: isRedBoss || isPurpleBoss // Red and purple bosses cycle shields
      };
    }

    /**
     * One-time initialisation of the orbiting escort satellites once the boss
     * has finished its entrance animation. Orbiter count: 4 (green), 6 (red),
     * or 8 (purple) based on boss difficulty.
     */
    function initBossOrbiters() {
      if (orbitersInitialized) return;
      orbitersInitialized = true;

      var orbiterCount = boss.isPurpleBoss ? 8 : (boss.isRedBoss ? 6 : 4);
      maxOrbiters = orbiterCount;

      for (var i = 0; i < orbiterCount; i++) {
        spawnOrbiter(i, orbiterCount);
      }
    }

    /**
     * Creates one orbiter satellite at the given angular slot and pushes it
     * into `bossOrbiters`. Orbiters use the same enemy sprite as the current
     * boss phase (enemy1 / enemy1_red / enemy1_purple).
     * @param {number} index - Angular slot (0..total-1).
     * @param {number} total - Total number of orbiters in the ring.
     */
    function spawnOrbiter(index, total) {
      var angle = (index / total) * Math.PI * 2;
      var enemyType = boss.isPurpleBoss ? 'enemy1_purple' : (boss.isRedBoss ? 'enemy1_red' : 'enemy1');

      bossOrbiters.push({
        angle: angle,
        baseRadius: 120,
        width: 40,
        height: 40,
        baseWidth: 40,
        baseHeight: 40,
        type: enemyType,
        index: index,
        total: total,
        breathPhase: index * 0.2,
        alive: true
      });
    }

    /**
     * Each frame: rotates all living orbiters around the boss centre with a
     * BPM-pulsing radius, draws them with a ripple ring, handles bullet and
     * player collision, and respawns destroyed orbiters after a 3-second delay.
     * Returns true if a collision killed the player (signals game loop to stop).
     * @returns {boolean}
     */
    function updateBossOrbiters() {
      if (!boss || boss.entering) return;

      // Initialize orbiters once boss has entered
      if (!orbitersInitialized) {
        initBossOrbiters();
      }

      var time = Date.now();
      var bossCx = boss.x + boss.width / 2;
      var bossCy = boss.y + boss.height / 2;

      // BPM-synced orbit radius pulsing
      var beatPhase = (time % BPM_INTERVAL) / BPM_INTERVAL;
      var radiusPulse = 1 + Math.sin(beatPhase * Math.PI * 2) * 0.15;

      // Rotation speed synced to BPM (one full rotation every 8 beats)
      var rotationSpeed = (Math.PI * 2) / (BPM_INTERVAL * 8);
      var baseRotation = (time * rotationSpeed) % (Math.PI * 2);

      for (var i = bossOrbiters.length - 1; i >= 0; i--) {
        var orbiter = bossOrbiters[i];
        if (!orbiter.alive) continue;

        // Calculate position
        var currentAngle = baseRotation + orbiter.angle;
        var currentRadius = orbiter.baseRadius * radiusPulse;

        var orbiterX = bossCx + Math.cos(currentAngle) * currentRadius - orbiter.width / 2;
        var orbiterY = bossCy + Math.sin(currentAngle) * currentRadius - orbiter.height / 2;

        // Store position for collision detection
        orbiter.x = orbiterX;
        orbiter.y = orbiterY;

        // Draw orbiter (no breathing - only enemy2 types breathe)
        var drawWidth = orbiter.baseWidth;
        var drawHeight = orbiter.baseHeight;
        var drawX = orbiterX;
        var drawY = orbiterY;

        // Draw ripple
        var ripplePhase = (time % BPM_INTERVAL) / BPM_INTERVAL;
        var maxRipple = drawWidth * 0.8;
        var rippleRadius = ripplePhase * maxRipple;
        var rippleAlpha = 1 - ripplePhase;

        ctx.save();
        ctx.beginPath();
        ctx.arc(orbiterX + orbiter.width / 2, orbiterY + orbiter.height / 2, rippleRadius, 0, Math.PI * 2);
        var rippleColor = boss.isPurpleBoss ?
          'rgba(180, 80, 255, ' + (rippleAlpha * 0.5) + ')' :
          (boss.isRedBoss ?
            'rgba(255, 100, 100, ' + (rippleAlpha * 0.5) + ')' :
            'rgba(100, 255, 100, ' + (rippleAlpha * 0.5) + ')');
        ctx.strokeStyle = rippleColor;
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.restore();

        // Draw orbiter image
        var img = boss.isPurpleBoss ? enemyImg1Purple : (boss.isRedBoss ? enemyImg1Red : enemyImg1);
        ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);

        // Orbiter shooting (lower chance than boss)
        if (Math.random() < 0.008) {
          enemyBullets.push({
            x: Math.floor(orbiterX + orbiter.width / 2 - 2),
            y: Math.floor(orbiterY + orbiter.height),
            width: 5,
            height: 10,
            speed: CONFIG.enemyBulletSpeed
          });
        }

        // Check collision with player bullets
        for (var j = playerBullets.length - 1; j >= 0; j--) {
          var bullet = playerBullets[j];
          if (bullet.x < orbiter.x + orbiter.width &&
            bullet.x + bullet.width > orbiter.x &&
            bullet.y < orbiter.y + orbiter.height &&
            bullet.y + bullet.height > orbiter.y) {
            playerBullets.splice(j, 1);
            orbiter.alive = false;
            var orbiterCenterX = orbiter.x + orbiter.width / 2;
            var orbiterCenterY = orbiter.y + orbiter.height / 2;
            spawnExplosion(orbiterCenterX, orbiterCenterY, false);
            spawnParticles(orbiterCenterX, orbiterCenterY, 10); // 10 particles for orbiter
            bossOrbiters.splice(i, 1);
            score += 15; // Slightly more than regular enemies
            updateUI();
            playSound('enemyDead');
            lastOrbiterDeathTime = time;
            break;
          }
        }

        // Check collision with player
        if (orbiter.alive &&
          player.x < orbiter.x + orbiter.width &&
          player.x + player.width > orbiter.x &&
          player.y < orbiter.y + orbiter.height &&
          player.y + player.height > orbiter.y) {
          orbiter.alive = false;
          bossOrbiters.splice(i, 1);
          playerTakeDamage(CONFIG.enemyCollisionDamage);
          lastOrbiterDeathTime = time;
          if (gameOver) return true;
        }
      }

      // Respawn orbiters after delay
      if (bossOrbiters.length < maxOrbiters && time - lastOrbiterDeathTime > orbiterRespawnDelay) {
        // Find missing index
        var existingIndices = bossOrbiters.map(function (o) { return o.index; });
        for (var i = 0; i < maxOrbiters; i++) {
          if (existingIndices.indexOf(i) === -1) {
            spawnOrbiter(i, maxOrbiters);
            lastOrbiterDeathTime = time; // Reset timer for next respawn
            break;
          }
        }
      }

      return false;
    }

    /**
     * Beat-synced filler enemy spawner active during boss fights. Spawns up to
     * `maxBossFillers` additional enemies (mix of side-entry and top-entry)
     * every 4 beats. The spawn chance scales inversely with the current filler
     * count so the field self-regulates to a comfortable density.
     */
    function spawnBossFiller() {
      var time = Date.now();

      // Count current fillers (non-formation, non-orbiter enemies)
      var currentFillers = enemies.filter(function (e) { return !e.formation; }).length;

      // Don't spawn if at cap
      if (currentFillers >= maxBossFillers) return;

      // Beat-synced spawning (every 4 beats)
      var currentBeat = Math.floor(time / BPM_INTERVAL);
      if (currentBeat - lastBossFillerBeat < bossFillerBeatInterval) return;

      // Dynamic spawn chance based on current count (fewer enemies = higher chance)
      var spawnChance = 0.5 * (1 - currentFillers / maxBossFillers);
      if (Math.random() > spawnChance) return;

      lastBossFillerBeat = currentBeat;

      // Spawn from sides to avoid boss orbit zone
      var fromSide = Math.random() < 0.5;
      var enemyType = boss.isPurpleBoss ?
        (Math.random() < 0.5 ? 'enemy2_purple' : 'enemy3_purple') :
        (boss.isRedBoss ?
          (Math.random() < 0.5 ? 'enemy2_red' : 'enemy3_red') :
          (Math.random() < 0.5 ? 'enemy2' : 'enemy3'));

      var width = (enemyType === 'enemy2_red' || enemyType === 'enemy2_purple') ? 29 : 50;
      var height = (enemyType === 'enemy2_red' || enemyType === 'enemy2_purple') ? 29 : 50;

      var enemy;
      if (fromSide) {
        // Side entry - upper half only, away from player
        var fromLeft = Math.random() < 0.5;
        enemy = {
          x: fromLeft ? -width : canvas.width,
          y: 100 + Math.random() * 150, // Upper half (100-250)
          width: width,
          height: height,
          baseWidth: width,
          baseHeight: height,
          speed: 0,
          horizontalSpeed: CONFIG.enemyBaseSpeed + 0.5,
          horizontalDirection: fromLeft ? 1 : -1,
          type: enemyType,
          formation: false,
          sideEntry: true,
          breathPhase: Math.random()
        };
      } else {
        // Top entry (edges only, away from boss)
        var spawnX = Math.random() < 0.5 ?
          Math.random() * 150 : // Left edge
          canvas.width - 150 - width + Math.random() * 150; // Right edge

        enemy = {
          x: spawnX,
          y: -height,
          width: width,
          height: height,
          baseWidth: width,
          baseHeight: height,
          speed: CONFIG.enemyBaseSpeed + 0.3,
          type: enemyType,
          formation: false,
          breathPhase: Math.random()
        };

        // Add movement behaviors
        if (CONFIG.zigzagEnemies.indexOf(enemyType) !== -1) {
          enemy.zigzag = true;
          enemy.zigzagDirection = Math.random() < 0.5 ? 1 : -1;
          enemy.zigzagSpeed = 2;
          enemy.zigzagTimer = 0;
          enemy.zigzagInterval = 30;
        }
        if (CONFIG.sideToSideEnemies.indexOf(enemyType) !== -1) {
          enemy.sideToSide = true;
          enemy.horizontalDirection = Math.random() < 0.5 ? 1 : -1;
          enemy.horizontalSpeed = 2;
        }
      }

      enemies.push(enemy);
    }

    /**
     * Spawns a single side-scrolling minion that enters from a random edge and
     * travels across the screen. Minions are distinct from `bossOrbiters` and
     * `enemies`; they are tracked in the `bossMinions` array.
     */
    function createBossMinion() {
      // Spawn from left or right side randomly
      var fromLeft = Math.random() < 0.5;
      var targetY = 100 + Math.random() * 150; // Stay in upper half

      bossMinions.push({
        x: fromLeft ? -50 : canvas.width,
        y: targetY,
        width: 50,
        height: 50,
        speed: CONFIG.bossMinionSpeed,
        direction: fromLeft ? 1 : -1,
        isRedMinion: (currentBoss === 2),
        isPurpleMinion: (currentBoss === 3)
      });
    }

    /**
     * Per-frame update for all boss minions: draws, moves, checks off-screen
     * removal, handles bullet collisions (minion kills chip 1 HP off the boss
     * if the boss is unshielded), and checks player collision. New minions spawn
     * at the rate defined by `CONFIG.bossMinionSpawnChance`.
     * Returns true if a collision resulted in player death.
     * @returns {boolean}
     */
    function updateBossMinions() {
      for (var i = bossMinions.length - 1; i >= 0; i--) {
        var minion = bossMinions[i];

        // Draw minion (enemy2 for boss 1, enemy3_red for boss 2)
        var minionImg = minion.isPurpleMinion ? enemyImg3Purple : (minion.isRedMinion ? enemyImg3Red : enemyImg2);
        ctx.drawImage(minionImg, minion.x, minion.y, minion.width, minion.height);

        // Move horizontally
        minion.x += minion.speed * minion.direction;

        // Remove if off screen on opposite side
        if ((minion.direction > 0 && minion.x > canvas.width) ||
          (minion.direction < 0 && minion.x < -minion.width)) {
          bossMinions.splice(i, 1);
          continue;
        }

        // Check collision with player bullets
        for (var j = playerBullets.length - 1; j >= 0; j--) {
          if (isColliding(playerBullets[j], minion)) {
            playerBullets.splice(j, 1);
            var minionCenterX = minion.x + minion.width / 2;
            var minionCenterY = minion.y + minion.height / 2;
            spawnExplosion(minionCenterX, minionCenterY, false);
            spawnParticles(minionCenterX, minionCenterY, 8); // 8 particles for minion
            bossMinions.splice(i, 1);
            score += 10;
            updateUI();
            playSound('enemyDead');
            // Minion kill chips boss for 1 HP
            if (boss && !boss.shielded) {
              boss.health = Math.max(0, boss.health - 1);
            }
            break;
          }
        }
      }

      // Check collision with player (separate loop since array may have changed)
      for (var i = bossMinions.length - 1; i >= 0; i--) {
        if (isColliding(bossMinions[i], player)) {
          bossMinions.splice(i, 1);
          playerTakeDamage(CONFIG.enemyCollisionDamage);
          if (gameOver) return true; // Signal game over
        }
      }

      // Spawn new minions
      if (Math.random() < CONFIG.bossMinionSpawnChance) {
        createBossMinion();
      }

      return false; // Game continues
    }

    /**
     * Main boss update called every frame. Manages the shield cycle (on/off
     * timer; green boss never regains it), entrance animation, horizontal and
     * optional vertical drift, bullet firing, BPM-synced ripple rendering,
     * golden shield ripple overlay, and the health bar HUD element.
     */
    function updateBoss() {
      if (!boss) return;

      // Update boss shield
      var now = Date.now();
      var timeSinceShieldStart = now - boss.shieldStartTime;

      if (boss.shielded) {
        // Check if shield duration expired
        if (timeSinceShieldStart >= boss.shieldDuration) {
          boss.shielded = false;
          boss.shieldStartTime = now; // Reset timer for cooldown
        }
      } else if (boss.shieldCycling) {
        // Red boss: check if cooldown expired to regenerate shield
        if (timeSinceShieldStart >= boss.shieldCooldown) {
          boss.shielded = true;
          boss.shieldStartTime = now;
        }
      }
      // Green boss: once shield is down, it stays down (shieldCycling = false)

      // Update boss blink effect
      updateBossBlink();

      // Boss entrance animation
      if (boss.entering) {
        boss.y += 1;
        if (boss.y >= 30) {
          boss.entering = false;
        }
      } else {
        // Move side to side
        boss.x += boss.speed * boss.direction;
        if (boss.x <= 0 || boss.x >= canvas.width - boss.width) {
          boss.direction *= -1;
        }

        // Red/purple boss also moves north/south
        if (boss.isRedBoss || boss.isPurpleBoss) {
          boss.y += boss.speed * 0.6 * boss.verticalDirection;
          if (boss.y <= 20) {
            boss.verticalDirection = 1;
          } else if (boss.y >= 100) {
            boss.verticalDirection = -1;
          }
        }

        // Boss shooting
        if (Math.random() < CONFIG.bossShootChance) {
          var bossBulletSpeed = CONFIG.enemyBulletSpeed + 1;
          if (boss.isRedBoss) {
            bossBulletSpeed = CONFIG.enemyBulletSpeed + 3; // Faster for red boss
          } else if (boss.isPurpleBoss) {
            bossBulletSpeed = CONFIG.enemyBulletSpeed + 4; // Fastest for purple boss
          }
          enemyBullets.push({
            x: Math.floor(boss.x + boss.width / 2 - 4),
            y: Math.floor(boss.y + boss.height),
            width: 8,
            height: 15,
            speed: bossBulletSpeed,
            isBossBullet: true
          });
        }
      }

      // Draw boss ripple effect at 123 BPM
      var bossCx = boss.x + boss.width / 2;
      var bossCy = boss.y + boss.height / 2;
      var time = Date.now();
      var beatPhase = (time % BPM_INTERVAL) / BPM_INTERVAL;
      var maxBossRipple = boss.width * 0.8;
      var bossRippleRadius = beatPhase * maxBossRipple;
      var bossRippleAlpha = 1 - beatPhase;

      ctx.save();
      ctx.beginPath();
      ctx.arc(bossCx, bossCy, bossRippleRadius, 0, Math.PI * 2);
      var bossRippleColor = boss.isPurpleBoss ?
        'rgba(160, 50, 255, ' + (bossRippleAlpha * 0.5) + ')' :
        (boss.isRedBoss ?
          'rgba(255, 50, 50, ' + (bossRippleAlpha * 0.5) + ')' :
          'rgba(50, 255, 50, ' + (bossRippleAlpha * 0.5) + ')');
      ctx.strokeStyle = bossRippleColor;
      ctx.lineWidth = 3;
      ctx.stroke();

      // Second boss ripple
      var beatPhase2 = ((time + BPM_INTERVAL / 2) % BPM_INTERVAL) / BPM_INTERVAL;
      var bossRippleRadius2 = beatPhase2 * maxBossRipple;
      var bossRippleAlpha2 = 1 - beatPhase2;
      ctx.beginPath();
      ctx.arc(bossCx, bossCy, bossRippleRadius2, 0, Math.PI * 2);
      var bossRippleColor2 = boss.isPurpleBoss ?
        'rgba(160, 50, 255, ' + (bossRippleAlpha2 * 0.3) + ')' :
        (boss.isRedBoss ?
          'rgba(255, 50, 50, ' + (bossRippleAlpha2 * 0.3) + ')' :
          'rgba(50, 255, 50, ' + (bossRippleAlpha2 * 0.3) + ')');
      ctx.strokeStyle = bossRippleColor2;
      ctx.lineWidth = 2;
      ctx.stroke();

      // Draw golden shield ripple when boss is shielded
      if (boss.shielded) {
        var shieldRippleRadius = beatPhase * maxBossRipple * 1.3;
        ctx.beginPath();
        ctx.arc(bossCx, bossCy, shieldRippleRadius, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(255, 215, 0, ' + (bossRippleAlpha * 0.7) + ')';
        ctx.lineWidth = 5;
        ctx.stroke();

        // Inner shield ripple
        var innerShieldRadius = shieldRippleRadius * 0.6;
        ctx.beginPath();
        ctx.arc(bossCx, bossCy, innerShieldRadius, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(255, 255, 100, ' + (bossRippleAlpha * 0.5) + ')';
        ctx.lineWidth = 3;
        ctx.stroke();
      }
      ctx.restore();

      // Draw boss (only if visible during blink)
      if (bossVisible) {
        var bossImage = boss.isPurpleBoss ? bossImgPurple : (boss.isRedBoss ? bossImgRed : bossImg);
        ctx.drawImage(bossImage, boss.x, boss.y, boss.width, boss.height);
      }

      // Boss health bar - fixed at top of canvas
      var healthPercent = boss.health / boss.maxHealth;
      var barW = 400;
      var barH = 14;
      var barX = (canvas.width - barW) / 2;
      var barY = 22;
      var bossColor = currentBoss === 3 ? '#CC55FF' : currentBoss === 2 ? '#FF4444' : '#4499FF';

      // Dark panel behind bar
      ctx.fillStyle = 'rgba(0, 0, 0, 0.65)';
      ctx.fillRect(barX - 10, barY - 20, barW + 20, barH + 28);

      // Boss label
      var bossLabel = currentBoss === 1 ? 'BOSS I' : currentBoss === 2 ? 'BOSS II' : 'BOSS III';
      ctx.fillStyle = bossColor;
      ctx.font = 'bold 11px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(bossLabel, canvas.width / 2, barY - 6);

      // Bar background
      ctx.fillStyle = '#1a1a1a';
      ctx.fillRect(barX, barY, barW, barH);

      // Bar fill ‚Äî orange at 50%, pulsing red at 25%
      var fillColor = bossColor;
      if (healthPercent < 0.25) {
        fillColor = (Math.sin(Date.now() / 120) > 0) ? '#FF2222' : '#FF7777';
      } else if (healthPercent < 0.5) {
        fillColor = '#FF8800';
      }
      ctx.fillStyle = fillColor;
      ctx.fillRect(barX, barY, barW * healthPercent, barH);

      // Border
      ctx.strokeStyle = bossColor;
      ctx.lineWidth = 1.5;
      ctx.strokeRect(barX, barY, barW, barH);
      ctx.textAlign = 'left';
    }

    /**
     * Registers one player-bullet hit on the boss. Shielded hits deal 0.5 chip
     * damage; unshielded hits deal 1 HP. At 0 HP, triggers screen shake, clears
     * all boss entities, awards a score bonus, and advances the game phase:
     *   Boss 1 ‚Üí red phase (level 5, score set to 800)
     *   Boss 2 ‚Üí purple phase (level 9, score set to 2000)
     *   Boss 3 ‚Üí victory screen
     */
    function damageBoss() {
      if (!boss) return;

      // Check if boss is shielded ‚Äî chip damage still gets through
      if (boss.shielded) {
        boss.health -= 0.5;
        bossBlinking = true;
        bossBlinkTimer = 6;
        return;
      }

      boss.health--;

      // Start boss blinking effect
      bossBlinking = true;
      bossBlinkTimer = 10; // Short blink (10 frames)

      if (boss.health <= 0) {
        // Boss defeated - trigger screen shake and explosion!
        triggerScreenShake(15, 800); // Strong shake for boss death
        var bossCenterX = boss.x + boss.width / 2;
        var bossCenterY = boss.y + boss.height / 2;
        spawnExplosion(bossCenterX, bossCenterY, true);
        spawnParticles(bossCenterX, bossCenterY, 24); // 24 particles for boss - more dramatic!

        bossActive = false;
        boss = null;
        bossMinions = [];
        bossOrbiters = [];
        orbitersInitialized = false;
        enemies = [];
        stopBossMusic();

        if (currentBoss === 1) {
          // Boss 1 defeated - show victory, then start red phase
          boss1Defeated = true;

          // Track boss 1 defeat
          gtag('event', 'boss_defeated', {
            'ab_music_group': userABGroup,
            'platform': 'desktop',
            'boss_number': 1,
            'score': score
          });

          // Calculate bonus and set score to 800 (only if player is under threshold)
          var bonus = 800 - score;
          if (bonus > 0) {
            score = 800;
          }
          redPhaseStartScore = score;
          updateUI();

          // Show victory message
          showAnnouncement("levelDisplay", "Victory!", 2500);

          // Show bonus in yellow (only if player earned one)
          if (bonus > 0) {
            setTimeout(function () {
              showAnnouncement("bonusDisplay", "Bonus +" + bonus + "!", 2000);
            }, 500);
          }

          // After delay, start level 5 with wave reset
          setTimeout(function () {
            redPhase = true;
            level = 5;
            currentWave = 0;
            waveInProgress = false;
            waveCooldown = false;
            powerupsSpawnedThisLevel = { health: false, doubleLaser: false, shield: false };
            lastPowerupSpawnTime = 0;
            updateUI();
            showAnnouncement("levelDisplay", "Level 5", 2000);
          }, 3000);
        } else if (currentBoss === 2) {
          // Boss 2 defeated - start purple phase (levels 9-12)
          boss2Defeated = true;

          // Track boss 2 defeat
          gtag('event', 'boss_defeated', {
            'ab_music_group': userABGroup,
            'platform': 'desktop',
            'boss_number': 2,
            'score': score
          });

          // Calculate bonus and set score to 2000 (only if player is under threshold)
          var bonus = 2000 - score;
          if (bonus > 0) {
            score = 2000;
          }
          purplePhaseStartScore = score;
          updateUI();

          showAnnouncement("levelDisplay", "Victory!", 2500);

          // Show bonus in yellow (only if player earned one)
          if (bonus > 0) {
            setTimeout(function () {
              showAnnouncement("bonusDisplay", "Bonus +" + bonus + "!", 2000);
            }, 500);
          }

          setTimeout(function () {
            purplePhase = true;
            level = 9;
            currentWave = 0;
            waveInProgress = false;
            waveCooldown = false;
            powerupsSpawnedThisLevel = { health: false, doubleLaser: false, shield: false };
            lastPowerupSpawnTime = 0;
            updateUI();
            showAnnouncement("levelDisplay", "Level 9", 2000);
          }, 3000);
        } else if (currentBoss === 3) {
          // Boss 3 defeated - game complete!
          boss3Defeated = true;
          bossDefeated = true;

          // Track boss 3 defeat
          gtag('event', 'boss_defeated', {
            'ab_music_group': userABGroup,
            'platform': 'desktop',
            'boss_number': 3,
            'score': score
          });
          score += 100;
          updateUI();
          showAnnouncement("levelDisplay", "Victory! You Win!", 3000);
          setTimeout(function () {
            showVictory();
          }, 3500);
        }
      }
    }

    /**
     * Handles the boss hit-flash animation. Decrements `bossBlinkTimer` each
     * frame and toggles `bossVisible` to create a rapid strobe effect.
     */
    function updateBossBlink() {
      if (bossBlinking) {
        bossBlinkTimer--;
        bossVisible = Math.floor(bossBlinkTimer / 2) % 2 === 0;
        if (bossBlinkTimer <= 0) {
          bossBlinking = false;
          bossVisible = true;
        }
      }
    }

    /**
     * Ends the game in a victory state. Clears all game objects, checks for a
     * top-10 score, builds the victory HTML (score, optional rank badge, email
     * subscription form, return button), and displays the #victory overlay.
     */
    function showVictory() {
      gameOver = true;
      stopBossMusic();
      // Keep background music playing - don't stop it

      // Clear all game objects from screen
      enemies = [];
      playerBullets = [];
      enemyBullets = [];
      powerups = [];
      bossMinions = [];
      boss = null;

      // Track game completion (victory)
      gtag('event', 'game_complete', {
        'ab_music_group': userABGroup,
        'platform': 'desktop',
        'final_score': score,
        'music_on': localStorage.getItem('nonex_music') !== 'off'
      });

      // Clear the canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Check if top 10 score and save
      var madeTopTen = isTopTenScore(score);
      var rank = getScoreRank(score);
      if (madeTopTen) {
        addHighScore(score);
      }

      // Build victory display
      var victoryEl = document.getElementById("victory");
      var html = "<div style='font-size: 22px; margin-bottom: 15px;'>Thank you for playing NON-X!</div>";
      html += "<div style='font-size: 20px; margin-bottom: 25px;'>Your Score: <strong>" + score + "</strong>";
      if (madeTopTen) {
        html += " <span style='color: #FFD700;'>- TOP 10! Rank #" + rank + "</span>";
      }
      html += "</div>";

      // Leaderboard submission
      html += "<div id='leaderboardSubmit' style='margin-bottom: 20px;'>";
      html += "<div style='font-size: 16px; margin-bottom: 8px;'>Submit to Global Leaderboard:</div>";
      html += "<input type='text' id='igInput' placeholder='Instagram handle (optional)' style='padding: 8px; font-size: 14px; width: 200px; border-radius: 4px; border: none; margin-bottom: 8px;'><br>";
      html += "<button onclick='submitToLeaderboard()' style='padding: 8px 16px; font-size: 14px; border-radius: 4px; border: none; background: #00FFFF; color: #000; cursor: pointer; font-weight: bold;'>Submit Score</button>";
      html += "</div>";

      // Leaderboard display
      html += "<div id='leaderboardDisplay' style='margin-bottom: 25px;'></div>";

      // Buttons row (mute + return home)
      html += "<div style='margin-bottom: 20px;'>";
      html += "<button id='victoryMuteBtn' onclick='toggleMusic()' style='padding: 12px 20px; font-size: 16px; border-radius: 4px; border: none; background: #00FFFF; color: #000; cursor: pointer; margin-right: 10px; font-weight: bold;'>" + (bgMusic.paused ? 'üîá' : 'üîä') + "</button>";
      html += "<button onclick='returnToHomeScreen()' style='padding: 12px 24px; font-size: 16px; border-radius: 4px; border: none; background: #4CAF50; color: white; cursor: pointer;'>Return to Home Screen</button>";
      html += "</div>";

      html += "<div style='margin-top: 15px; font-size: 14px;'>&copy; <a href='https://modmotif.com/' target='_blank' style='color: #00FFFF; text-decoration: underline;'>Modmotif</a> 2026</div>";

      victoryEl.innerHTML = html;
      victoryEl.style.display = "block";
      document.getElementById("startButton").style.display = "none";
    }

    /** Stops all audio and navigates back to `index.html`. */
    function returnToHomeScreen() {
      stopBackgroundMusic();
      stopBossMusic();
      stopCreditsMusic();
      window.location.href = 'index.html';
    }

    // ============================================
    // BULLETS
    // ============================================
    /**
     * Fires one or more player bullets from the ship's current position,
     * based on the active laser level:
     *   1 ‚Üí single centre bullet
     *   2 ‚Üí dual side-by-side bullets (double laser)
     *   3 ‚Üí three evenly spread bullets (triple laser, purple phase)
     *   4 ‚Üí four evenly spread bullets (quad laser, purple phase rare upgrade)
     */
    function shootBullet() {
      playSound('playerBullet');
      if (laserLevel >= 4) {
        // Quad laser - four bullets spread across ship width (rare upgrade)
        var offsets = [0.15, 0.38, 0.62, 0.85];
        for (var q = 0; q < 4; q++) {
          playerBullets.push({
            x: Math.floor(player.x + player.width * offsets[q] - 2),
            y: Math.floor(player.y),
            width: 5,
            height: 10,
            speed: CONFIG.bulletSpeed
          });
        }
      } else if (laserLevel === 3) {
        // Triple laser - three bullets spread across ship width (purple phase)
        var offsets = [0.2, 0.5, 0.8];
        for (var t = 0; t < 3; t++) {
          playerBullets.push({
            x: Math.floor(player.x + player.width * offsets[t] - 2),
            y: Math.floor(player.y),
            width: 5,
            height: 10,
            speed: CONFIG.bulletSpeed
          });
        }
      } else if (hasDoubleLaser) {
        // Double laser - two side-by-side bullets
        playerBullets.push({
          x: Math.floor(player.x + player.width / 4 - 2),
          y: Math.floor(player.y),
          width: 5,
          height: 10,
          speed: CONFIG.bulletSpeed
        });
        playerBullets.push({
          x: Math.floor(player.x + (player.width * 3 / 4) - 2),
          y: Math.floor(player.y),
          width: 5,
          height: 10,
          speed: CONFIG.bulletSpeed
        });
      } else {
        // Single bullet
        playerBullets.push({
          x: Math.floor(player.x + player.width / 2 - 2),
          y: Math.floor(player.y),
          width: 5,
          height: 10,
          speed: CONFIG.bulletSpeed
        });
      }
    }

    /**
     * Fires one bullet downward from the bottom-centre of the given enemy.
     * Bullet speed scales with the current game phase (red: +40%, purple: +65%).
     * @param {Object} enemy - The firing enemy object.
     */
    function shootEnemyBullet(enemy) {
      var bulletSpeed = CONFIG.enemyBulletSpeed;
      if (purplePhase) {
        bulletSpeed *= 1.65; // 65% faster in purple phase
      } else if (redPhase) {
        bulletSpeed *= 1.4; // 40% faster in red phase
      }
      enemyBullets.push({
        x: Math.floor(enemy.x + enemy.width / 2 - 2),
        y: Math.floor(enemy.y + enemy.height),
        width: 5,
        height: 10,
        speed: bulletSpeed
      });
    }

    // ============================================
    // COLLISION DETECTION
    // ============================================
    /**
     * Axis-Aligned Bounding Box (AABB) collision test between two rect objects.
     * @param {{x:number, y:number, width:number, height:number}} a
     * @param {{x:number, y:number, width:number, height:number}} b
     * @returns {boolean} True when the two rects overlap.
     */
    function isColliding(a, b) {
      return a.x < b.x + b.width &&
        a.x + a.width > b.x &&
        a.y < b.y + b.height &&
        a.y + a.height > b.y;
    }

    // ============================================
    // PLAYER DAMAGE
    // ============================================
    /**
     * Applies damage to the player, accounting for the shield power-up:
     *   ‚Ä¢ Purple phase with shield: damage fully blocked.
     *   ‚Ä¢ Earlier phases with shield: damage reduced to 5; absorbed entirely
     *     when health ‚â§ 15.
     *   ‚Ä¢ No shield in red/purple phase: downgrades laser level on hit.
     * Triggers the player blink effect, updates the HUD, and ends the game
     * (showing the Game Over overlay) if health reaches 0.
     * @param {number} damage - HP to subtract before shield mitigation.
     */
    function playerTakeDamage(damage) {
      if (hasShield) {
        shieldHitsRemaining--;
        if (shieldHitsRemaining <= 0) {
          hasShield = false;
          showAnnouncement("powerupDisplay", "Shield Broken!", 1500);
        } else {
          showAnnouncement("powerupDisplay", "Shield: " + shieldHitsRemaining + " hits left", 800);
        }
        if (purplePhase) {
          // Purple phase: shield fully blocks all damage, no health loss
          return;
        }
        // Earlier phases: shield reduces damage to 5, protects health at low HP
        damage = 5;
        if (health <= 15) {
          showAnnouncement("powerupDisplay", "Shield absorbed damage!", 800);
          return;
        }
      } else {
        // Lose laser power when hit without shield (red and purple phases)
        if ((redPhase || purplePhase) && hasDoubleLaser) {
          if (laserLevel >= 4) {
            laserLevel = 3; // Quad -> triple
            showAnnouncement("powerupDisplay", "Lost Quad Laser!", 1500);
          } else if (laserLevel === 3) {
            laserLevel = 2; // Triple -> double
            showAnnouncement("powerupDisplay", "Lost Triple Laser!", 1500);
          } else {
            hasDoubleLaser = false;
            laserLevel = 1;
          }
        }
      }

      health -= damage;
      updateUI();

      // Start blinking effect
      playerBlinking = true;
      playerBlinkTimer = 30; // Blink for 30 frames (~0.5 seconds)

      if (health <= 0) {
        health = 0;
        updateUI();
        gameOver = true;
        playSound('playerDead');
        stopBossMusic();
        // Keep background music playing - don't stop it

        // Check if top 10 score and save
        var madeTopTen = isTopTenScore(score);
        var rank = getScoreRank(score);
        if (madeTopTen) {
          addHighScore(score);
        }

        // Build game over display
        var gameOverEl = document.getElementById("gameOver");
        var html = "Game Over!<br><br>Your Score: " + score;
        if (madeTopTen) {
          html += "<br><span style='color: #FFD700;'>TOP 10! Rank #" + rank + "</span>";
        }
        html += "<br><br>";
        html += "<div style='margin-bottom: 20px;'>";
        html += "<button id='gameOverMuteBtn' onclick='toggleMusic()' style='padding: 12px 20px; font-size: 16px; border-radius: 4px; border: none; background: #00FFFF; color: #000; cursor: pointer; margin-right: 10px; font-weight: bold;'>" + (bgMusic.paused ? 'üîá' : 'üîä') + "</button>";
        html += "<button onclick='returnToHomeScreen()' style='padding: 10px 20px; font-size: 16px; border-radius: 4px; border: none; background: #4CAF50; color: white; cursor: pointer;'>Return to Home Screen</button>";
        html += "</div>";
        gameOverEl.innerHTML = html;
        gameOverEl.style.display = "block";
        document.getElementById("startButton").style.display = "none";

        // Track game over
        gtag('event', 'game_over', {
          'ab_music_group': userABGroup,
          'platform': 'desktop',
          'level_reached': level,
          'score': score
        });
      } else {
        playSound('playerHit');
      }
    }

    /**
     * Handles the player hit-flash animation. Decrements `playerBlinkTimer`
     * each frame and toggles `playerVisible` every 3 frames to create a
     * strobe effect lasting ~0.5 s (30 frames).
     */
    function updatePlayerBlink() {
      if (playerBlinking) {
        playerBlinkTimer--;
        // Toggle visibility every 3 frames
        playerVisible = Math.floor(playerBlinkTimer / 3) % 2 === 0;
        if (playerBlinkTimer <= 0) {
          playerBlinking = false;
          playerVisible = true;
        }
      }
    }

    /**
     * Spawns an explosion effect at the given coordinates.
     * @param {number} x - Center X position
     * @param {number} y - Center Y position
     * @param {boolean} isBoss - True for boss explosion (triple rings)
     */
    function spawnExplosion(x, y, isBoss) {
      explosions.push({
        x: x,
        y: y,
        startTime: Date.now(),
        duration: isBoss ? 500 : 300,
        isBoss: isBoss || false
      });
    }

    /**
     * Updates and draws all active explosions.
     * Regular enemies: Single expanding ring
     * Boss enemies: Triple concentric rings
     */
    function updateExplosions() {
      var now = Date.now();

      for (var i = explosions.length - 1; i >= 0; i--) {
        var exp = explosions[i];
        var elapsed = now - exp.startTime;

        if (elapsed >= exp.duration) {
          explosions.splice(i, 1);
          continue;
        }

        var progress = elapsed / exp.duration;
        var alpha = 1.0 - progress;
        var color = purplePhase ? '138, 43, 226' : (redPhase ? '255, 69, 0' : '0, 255, 255');

        if (exp.isBoss) {
          // Boss: Triple rings
          var radius1 = 30 + (progress * 70);
          ctx.beginPath();
          ctx.arc(exp.x, exp.y, radius1, 0, Math.PI * 2);
          ctx.strokeStyle = 'rgba(' + color + ', ' + (alpha * 0.8) + ')';
          ctx.lineWidth = 3;
          ctx.stroke();

          var radius2 = 20 + (progress * 55);
          ctx.beginPath();
          ctx.arc(exp.x, exp.y, radius2, 0, Math.PI * 2);
          ctx.strokeStyle = 'rgba(' + color + ', ' + (alpha * 0.6) + ')';
          ctx.lineWidth = 2;
          ctx.stroke();

          var radius3 = 10 + (progress * 40);
          ctx.beginPath();
          ctx.arc(exp.x, exp.y, radius3, 0, Math.PI * 2);
          ctx.strokeStyle = 'rgba(' + color + ', ' + (alpha * 0.4) + ')';
          ctx.lineWidth = 2;
          ctx.stroke();
        } else {
          // Regular enemy: Single ring
          var radius = 10 + (progress * 30);
          ctx.beginPath();
          ctx.arc(exp.x, exp.y, radius, 0, Math.PI * 2);
          ctx.strokeStyle = 'rgba(' + color + ', ' + alpha + ')';
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      }
    }

    /**
     * Spawns explosion particles at the given coordinates.
     * @param {number} x - Center X position
     * @param {number} y - Center Y position
     * @param {number} count - Number of particles to spawn
     */
    function spawnParticles(x, y, count) {
      var color = '255, 215, 0'; // Golden color - like shield breaking

      for (var i = 0; i < count; i++) {
        var angle = (Math.PI * 2 * i) / count + (Math.random() - 0.5) * 0.5;
        var speed = 2 + Math.random() * 3;

        particles.push({
          x: x,
          y: y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          startTime: Date.now(),
          duration: 400 + Math.random() * 200,
          size: 2 + Math.random() * 2,
          color: color
        });
      }
    }

    /**
     * Updates and draws all active particles.
     * Particles fly outward and fade over time.
     */
    function updateParticles() {
      var now = Date.now();

      for (var i = particles.length - 1; i >= 0; i--) {
        var p = particles[i];
        var elapsed = now - p.startTime;

        if (elapsed >= p.duration) {
          particles.splice(i, 1);
          continue;
        }

        var progress = elapsed / p.duration;
        var alpha = 1.0 - progress;

        // Update position
        p.x += p.vx;
        p.y += p.vy;

        // Apply gravity
        p.vy += 0.1;

        // Draw particle
        ctx.fillStyle = 'rgba(' + p.color + ', ' + alpha + ')';
        ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
      }
    }

    // ============================================
    // INPUT HANDLING
    // ============================================
    document.addEventListener("keydown", function (e) {
      // Debug: Victory screen (V key)
      if (e.key === "v" || e.key === "V") {
        showVictory();
        return;
      }

      // Pause toggle (P or Escape)
      if (e.key === "p" || e.key === "P" || e.key === "Escape") {
        if (!gameOver) {
          paused = !paused;
          document.getElementById("pauseDisplay").style.display = paused ? "block" : "none";
          document.getElementById("startButton").innerText = paused ? "Resume" : "Pause";
          if (paused) {
            bgMusic.pause();
          } else {
            bgMusic.play();
          }
        }
        return;
      }

      // Ignore other keys if paused
      if (paused) return;

      if (e.key === "Right" || e.key === "ArrowRight") rightPressed = true;
      else if (e.key === "Left" || e.key === "ArrowLeft") leftPressed = true;
      else if (e.key === " ") {
        e.preventDefault();
        spacebarPressed = true;
        var now = Date.now();
        if (now - lastShotTime >= FIRE_COOLDOWN) {
          shootBullet();
          lastShotTime = now;
        }
      }
      // Debug: jump to level (Shift+1 through Shift+9 = levels 1-9, Shift+0 = level 12)
      else if (e.shiftKey && !gameOver && !bossActive) {
        var jumpLevel = null;
        if (e.key === '!') jumpLevel = 1;
        else if (e.key === '@') jumpLevel = 2;
        else if (e.key === '#') jumpLevel = 3;
        else if (e.key === '$') jumpLevel = 4;
        else if (e.key === '%') jumpLevel = 5;
        else if (e.key === '^') jumpLevel = 6;
        else if (e.key === '&') jumpLevel = 7;
        else if (e.key === '*') jumpLevel = 8;
        else if (e.key === '(') jumpLevel = 9;
        else if (e.key === ')') jumpLevel = 12;
        if (jumpLevel !== null) {
          enemies = [];
          waveInProgress = false;
          waveCooldown = false;
          currentWave = 0;
          bossActive = false;
          boss = null;
          level = jumpLevel;
          redPhase = jumpLevel >= 5;
          purplePhase = jumpLevel >= 9;
          boss1Defeated = jumpLevel >= 5;
          boss2Defeated = jumpLevel >= 9;
          health = CONFIG.maxHealth;
          score = jumpLevel >= 9 ? 2000 : (jumpLevel >= 5 ? 800 : 0);
          powerupsSpawnedThisLevel = { health: false, doubleLaser: false, shield: false };
          updateUI();
          showAnnouncement("levelDisplay", "DEBUG: Level " + jumpLevel, 2000);
        }
      }
    });

    document.addEventListener("keyup", function (e) {
      if (e.key === "Right" || e.key === "ArrowRight") rightPressed = false;
      else if (e.key === "Left" || e.key === "ArrowLeft") leftPressed = false;
      else if (e.key === " ") spacebarPressed = false;
    });

    // ============================================
    // MOUSE CONTROLS (DESKTOP)
    // ============================================
    canvas.addEventListener("mousemove", function (e) {
      var rect = canvas.getBoundingClientRect();
      mouseX = e.clientX - rect.left;
      mouseY = e.clientY - rect.top;
      mouseActive = true;
    });

    canvas.addEventListener("mousedown", function (e) {
      if (e.button === 0) { // Left click
        mouseDown = true;
      }
    });

    canvas.addEventListener("mouseup", function (e) {
      if (e.button === 0) {
        mouseDown = false;
      }
    });

    canvas.addEventListener("mouseleave", function () {
      mouseActive = false;
      mouseDown = false;
    });

    // ============================================
    // MAIN GAME LOOP
    // ============================================
    /**
     * Main game loop, called via `requestAnimationFrame`. Each frame:
     *   1. Early-returns if game is over; keeps rAF alive while paused.
     *   2. Clears the canvas and updates screen shake.
     *   3. Draws the player ship (with blink) and processes keyboard movement.
     *   4. Updates player bullets (upward movement, off-screen removal, collision
     *      with boss/enemies, shield interaction).
     *   5. Updates enemy bullets (downward, player collision, damage application).
     *   6. Updates power-ups (fall, player collection).
     *   7. Delegates to the boss subsystem or the wave-formation subsystem.
     *   8. Schedules the next frame with requestAnimationFrame.
     */
    function draw() {
      if (gameOver) return;

      // If paused, just keep the animation frame going but don't update
      if (paused) {
        requestAnimationFrame(draw);
        return;
      }

      // Update screen shake effect
      updateScreenShake();

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Update player blink effect
      updatePlayerBlink();

      // Update explosions and particles
      updateExplosions();
      updateParticles();

      // Draw shield ripple effect if active
      if (hasShield) {
        var playerCx = player.x + player.width / 2;
        var playerCy = player.y + player.height / 2;
        var time = Date.now();
        var beatPhase = (time % BPM_INTERVAL) / BPM_INTERVAL;
        var maxShieldRipple = player.width * 0.9;
        var shieldRippleRadius = beatPhase * maxShieldRipple;
        var shieldRippleAlpha = 1 - beatPhase;

        ctx.save();
        ctx.beginPath();
        ctx.arc(playerCx, playerCy, shieldRippleRadius, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(0, 255, 255, ' + (shieldRippleAlpha * 0.6) + ')';
        ctx.lineWidth = 3;
        ctx.stroke();

        // Second ripple
        var beatPhase2 = ((time + BPM_INTERVAL / 2) % BPM_INTERVAL) / BPM_INTERVAL;
        var shieldRippleRadius2 = beatPhase2 * maxShieldRipple;
        var shieldRippleAlpha2 = 1 - beatPhase2;
        ctx.beginPath();
        ctx.arc(playerCx, playerCy, shieldRippleRadius2, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(0, 255, 255, ' + (shieldRippleAlpha2 * 0.4) + ')';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.restore();
      }

      // Draw quad laser glow when player has quad lasers
      if (!gameOver && !paused && laserLevel >= 4) {
        var playerCenterX = player.x + player.width / 2;
        var playerCenterY = player.y + player.height / 2;
        var gradient = ctx.createRadialGradient(playerCenterX, playerCenterY, 0, playerCenterX, playerCenterY, player.width);
        gradient.addColorStop(0, 'rgba(0, 255, 255, 0.4)');
        gradient.addColorStop(0.5, 'rgba(0, 255, 255, 0.2)');
        gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(player.x - player.width / 2, player.y - player.height / 2, player.width * 2, player.height * 2);
      }

      // Draw and move player (only if visible during blink)
      if (playerVisible) {
        ctx.drawImage(playerImg, player.x, player.y, player.width, player.height);
      }
      // Mouse movement (prioritize over keyboard)
      if (mouseActive && !gameOver && !paused) {
        var targetX = mouseX - player.width / 2;
        targetX = Math.max(0, Math.min(targetX, canvas.width - player.width));
        player.x += (targetX - player.x) * 0.3; // Smooth follow

        // Mouse shooting with cooldown
        if (mouseDown) {
          var now = Date.now();
          if (now - lastShotTime >= FIRE_COOLDOWN) {
            shootBullet();
            lastShotTime = now;
          }
        }
      }
      // Keyboard movement (fallback)
      else if (rightPressed && player.x < canvas.width - player.width) {
        player.x += CONFIG.playerSpeed;
      } else if (leftPressed && player.x > 0) {
        player.x -= CONFIG.playerSpeed;
      }

      // Update player bullets
      for (var i = playerBullets.length - 1; i >= 0; i--) {
        var bullet = playerBullets[i];

        ctx.fillStyle = "#00FF00";
        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
        bullet.y -= bullet.speed;

        if (bullet.y < 0) {
          playerBullets.splice(i, 1);
          continue;
        }

        // Check collision with boss
        if (boss && isColliding(bullet, boss)) {
          playerBullets.splice(i, 1);
          damageBoss();
          continue;
        }

        // Check collision with enemies
        for (var j = enemies.length - 1; j >= 0; j--) {
          var enemy = enemies[j];
          if (isColliding(bullet, enemy)) {
            // Check if enemy is shielded
            if (enemy.shielded) {
              // Track shield hits - shield breaks after 25 hits
              if (typeof enemy.shieldHits === 'undefined') {
                enemy.shieldHits = 0;
              }
              enemy.shieldHits++;

              // Break shield permanently - 15 hits for levels 1-8, 25 for levels 9+
              var shieldBreakThreshold = level >= 9 ? 25 : 15;
              if (enemy.shieldHits >= shieldBreakThreshold) {
                enemy.shielded = false;
                enemy.shieldBroken = true; // Mark as broken so cascade doesn't restore it
              }

              // Bullet stops at shield - destroy bullet but enemy survives
              playerBullets.splice(i, 1);
              // Optional: play shield hit sound here later
              break;
            } else {
              // No shield - destroy both bullet and enemy
              var centerX = enemy.x + enemy.width / 2;
              var centerY = enemy.y + enemy.height / 2;
              spawnExplosion(centerX, centerY, false);
              spawnParticles(centerX, centerY, 8); // 8 particles for regular enemy
              playerBullets.splice(i, 1);
              enemies.splice(j, 1);
              score += 10;
              updateUI();
              playSound('enemyDead');
              checkLevelUp();
              break;
            }
          }
        }
      }

      // Update enemy bullets
      for (var i = enemyBullets.length - 1; i >= 0; i--) {
        var bullet = enemyBullets[i];

        ctx.fillStyle = "#FF0000";
        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
        bullet.y += bullet.speed;

        if (bullet.y > canvas.height) {
          enemyBullets.splice(i, 1);
          continue;
        }

        if (isColliding(bullet, player)) {
          enemyBullets.splice(i, 1);
          var damage = bullet.isBossBullet ? CONFIG.bossDamage : CONFIG.enemyBulletDamage;
          playerTakeDamage(damage);
          if (gameOver) return;
        }
      }

      // Update power-ups
      for (var i = powerups.length - 1; i >= 0; i--) {
        var powerup = powerups[i];

        drawPowerup(powerup);
        powerup.y += powerup.speed;

        if (powerup.y > canvas.height) {
          powerups.splice(i, 1);
          continue;
        }

        if (isColliding(powerup, player)) {
          collectPowerup(powerup);
          powerups.splice(i, 1);
        }
      }

      // Boss mode
      if (bossActive) {
        updateBoss();

        // Update orbiting soldiers
        var orbiterGameOver = updateBossOrbiters();
        if (orbiterGameOver) return;

        // Update side-scrolling minions (enemy2)
        var minionGameOver = updateBossMinions();
        if (minionGameOver) return;

        // Smart filler spawning (beat-synced, capped)
        spawnBossFiller();

        // Random powerup spawn during boss fight
        if (!powerupsSpawnedThisLevel.health && !powerupsSpawnedThisLevel.doubleLaser) {
          if (Math.random() < 0.0008) {
            var powerupType = Math.random() < 0.6 ? POWERUP_TYPES.HEALTH : POWERUP_TYPES.DOUBLE_LASER;
            if (createPowerup(powerupType)) {
              if (powerupType === POWERUP_TYPES.HEALTH) {
                powerupsSpawnedThisLevel.health = true;
              } else {
                powerupsSpawnedThisLevel.doubleLaser = true;
              }
            }
          }
        }

        // Update filler enemies during boss fight
        for (var i = enemies.length - 1; i >= 0; i--) {
          var enemy = enemies[i];

          drawEnemy(enemy);

          // Side entry enemies move horizontally
          if (enemy.sideEntry) {
            enemy.x += enemy.horizontalSpeed * enemy.horizontalDirection;
            enemy.y += 0.3; // Slight downward drift

            // Remove if crossed screen
            if ((enemy.horizontalDirection > 0 && enemy.x > canvas.width) ||
              (enemy.horizontalDirection < 0 && enemy.x < -enemy.width)) {
              enemies.splice(i, 1);
              continue;
            }
          } else {
            // Top entry enemies
            enemy.y += enemy.speed;

            // Zigzag movement
            if (enemy.zigzag) {
              enemy.x += enemy.zigzagSpeed * enemy.zigzagDirection;
              enemy.zigzagTimer++;
              if (enemy.zigzagTimer >= enemy.zigzagInterval) {
                enemy.zigzagTimer = 0;
                enemy.zigzagDirection *= -1;
              }
              if (enemy.x <= 0) {
                enemy.x = 0;
                enemy.zigzagDirection = 1;
              } else if (enemy.x >= canvas.width - enemy.width) {
                enemy.x = canvas.width - enemy.width;
                enemy.zigzagDirection = -1;
              }
            }

            // Side-to-side movement
            if (enemy.sideToSide) {
              enemy.x += enemy.horizontalSpeed * enemy.horizontalDirection;
              if (enemy.x <= 0) {
                enemy.x = 0;
                enemy.horizontalDirection = 1;
              } else if (enemy.x >= canvas.width - enemy.width) {
                enemy.x = canvas.width - enemy.width;
                enemy.horizontalDirection = -1;
              }
            }
          }

          // Check collision with player
          if (isColliding(enemy, player)) {
            enemies.splice(i, 1);
            playerTakeDamage(CONFIG.enemyCollisionDamage);
            if (gameOver) return;
            continue;
          }

          // Remove if off screen (bottom)
          if (enemy.y > canvas.height) {
            enemies.splice(i, 1);
            continue;
          }

          // Check collision with player bullets
          for (var j = playerBullets.length - 1; j >= 0; j--) {
            if (isColliding(playerBullets[j], enemy)) {
              var centerX = enemy.x + enemy.width / 2;
              var centerY = enemy.y + enemy.height / 2;
              spawnExplosion(centerX, centerY, false);
              spawnParticles(centerX, centerY, 8); // 8 particles for regular enemy
              playerBullets.splice(j, 1);
              enemies.splice(i, 1);
              score += 10;
              updateUI();
              playSound('enemyDead');
              break;
            }
          }
        }

        // Check boss collision with player
        if (boss && isColliding(boss, player)) {
          playerTakeDamage(CONFIG.bossDamage);
          if (gameOver) return;
        }
      } else {
        // Regular enemy mode - wave-based formations
        var time = Date.now();

        // Start first wave if not started
        if (currentWave === 0 && !waveCooldown) {
          startWave(1);
        }

        // Update morphing formations
        if (waveInProgress) {
          // Move formation center smoothly as a unit
          if (!formationEntered) {
            formationCurrentCenterY += formationEntrySpeed;
            if (formationCurrentCenterY >= formationTargetCenterY) {
              formationCurrentCenterY = formationTargetCenterY;
              formationEntered = true;
              // Show shield warning (brief after level 1 - players already know)
              var warningEl = document.getElementById("warningDisplay");
              warningEl.style.display = "block";
              if (level > 1) {
                // Brief 2-second warning for experienced players
                setTimeout(function () {
                  warningEl.style.display = "none";
                }, 2000);
              }
              // Mark all formation enemies as reached
              enemies.forEach(function (e) {
                if (e.formation && e.formationType === 'morphing') {
                  e.reachedTarget = true;
                  e.centerY = formationCurrentCenterY;
                }
              });
            }
          }
          updateMorphingFormation(time);
          updateShieldCascade();
          updateKamikazeEntry();
        }

        // Update barrier reinforcements
        updateBarriers();

        for (var i = enemies.length - 1; i >= 0; i--) {
          var enemy = enemies[i];

          drawEnemy(enemy);

          // Formation enemies - position relative to formation center
          if (enemy.formation) {
            // During entry, update position based on moving formation center
            if (!formationEntered && enemy.formationType === 'morphing') {
              var baseX = enemy.centerX + enemy.currentPos.x * enemy.spreadRadius;
              var baseY = formationCurrentCenterY + enemy.currentPos.y * enemy.spreadRadius * 0.8;
              enemy.x = baseX - enemy.width / 2;
              enemy.y = baseY - enemy.height / 2;
            }

            // Legacy formation types (spiral, pincer, sineWave) for variety
            var beatPhase = ((time + (enemy.breathPhase || 0) * BPM_INTERVAL) % BPM_INTERVAL) / BPM_INTERVAL;

            if (enemy.formationType === 'spiral' && enemy.reachedTarget) {
              enemy.spiralAngle += 0.02;
              var pulseFactor = 1 + Math.sin(beatPhase * Math.PI * 2) * 0.3;
              var currentRadius = enemy.spiralBaseRadius * pulseFactor;
              enemy.x = enemy.spiralCenterX + Math.cos(enemy.spiralAngle) * currentRadius - enemy.width / 2;
              enemy.y = enemy.spiralCenterY + Math.sin(enemy.spiralAngle) * currentRadius - enemy.height / 2;
            }

            if (enemy.formationType === 'pincer') {
              if (!enemy.reachedTarget) {
                if (enemy.pincerSide === 'left' && enemy.x < enemy.pincerTargetX) {
                  enemy.x += enemy.pincerSpeed;
                  if (enemy.x >= enemy.pincerTargetX) enemy.reachedTarget = true;
                } else if (enemy.pincerSide === 'right' && enemy.x > enemy.pincerTargetX) {
                  enemy.x -= enemy.pincerSpeed;
                  if (enemy.x <= enemy.pincerTargetX) enemy.reachedTarget = true;
                }
              } else {
                var pulseDist = Math.sin(beatPhase * Math.PI * 2) * 30;
                if (enemy.pincerSide === 'left') {
                  enemy.x = enemy.pincerBaseX + pulseDist;
                } else {
                  enemy.x = enemy.pincerBaseX - pulseDist;
                }
              }
            }

            if (enemy.formationType === 'sineWave' && enemy.reachedTarget) {
              var wavePhase = (time / BPM_INTERVAL) * Math.PI * 2;
              enemy.x = enemy.baseX + Math.sin(wavePhase + enemy.sinePhase) * enemy.sineAmplitude;
              var vertBounce = Math.abs(Math.sin(beatPhase * Math.PI)) * 15;
              enemy.y = enemy.baseY + vertBounce;
              if (enemy.x < 0) enemy.x = 0;
              if (enemy.x > canvas.width - enemy.width) enemy.x = canvas.width - enemy.width;
            }

            // Morphing formations are handled by updateMorphingFormation()
          } else {
            // Regular non-formation enemies (fillers and kamikazes)

            // Kamikaze enemies dive toward player
            if (enemy.kamikaze) {
              // Still descending with the group center ‚Äî position handled by updateKamikazeEntry
              if (enemy.kamikazeEntering) continue;

              enemy.x += enemy.kamikazeVelX;
              enemy.y += enemy.kamikazeVelY;

              // Remove if off screen
              if (enemy.y > canvas.height || enemy.x < -enemy.width || enemy.x > canvas.width) {
                enemies.splice(i, 1);
                continue;
              }
            }
            // Side entry enemies move horizontally across screen
            else if (enemy.sideEntry) {
              enemy.x += enemy.horizontalSpeed * enemy.horizontalDirection;
              enemy.y += 0.3; // Slight downward drift

              // Remove if crossed screen
              if ((enemy.horizontalDirection > 0 && enemy.x > canvas.width) ||
                (enemy.horizontalDirection < 0 && enemy.x < -enemy.width)) {
                enemies.splice(i, 1);
                continue;
              }
            } else {
              // Top entry enemies move down
              enemy.y += enemy.speed;

              // Zigzag movement
              if (enemy.zigzag) {
                enemy.x += enemy.zigzagSpeed * enemy.zigzagDirection;
                enemy.zigzagTimer++;
                if (enemy.zigzagTimer >= enemy.zigzagInterval) {
                  enemy.zigzagTimer = 0;
                  enemy.zigzagDirection *= -1;
                }
                if (enemy.x <= 0) {
                  enemy.x = 0;
                  enemy.zigzagDirection = 1;
                } else if (enemy.x >= canvas.width - enemy.width) {
                  enemy.x = canvas.width - enemy.width;
                  enemy.zigzagDirection = -1;
                }
              }

              // Side-to-side movement
              if (enemy.sideToSide) {
                enemy.x += enemy.horizontalSpeed * enemy.horizontalDirection;
                if (enemy.x <= 0) {
                  enemy.x = 0;
                  enemy.horizontalDirection = 1;
                } else if (enemy.x >= canvas.width - enemy.width) {
                  enemy.x = canvas.width - enemy.width;
                  enemy.horizontalDirection = -1;
                }
              }
            }
          }

          if (isColliding(enemy, player)) {
            enemies.splice(i, 1);
            playerTakeDamage(CONFIG.enemyCollisionDamage);
            if (gameOver) return;
            continue;
          }

          // Remove non-formation enemies (barriers, kamikazes) if off screen
          if (!enemy.formation && enemy.y > canvas.height) {
            enemies.splice(i, 1);
            continue;
          }

          // Enemy shooting (level 2+)
          // Shielded enemies don't shoot
          var canShoot = level >= 2 && !enemy.shielded && !enemy.kamikaze;
          if (canShoot) {
            var now = Date.now();
            if (enemy.nextShootTime && now >= enemy.nextShootTime) {
              shootEnemyBullet(enemy);
              // Cooldown: random interval based on level
              // Purple phase: shorter gaps (more aggressive), earlier phases: slower
              var minGap = purplePhase ? 1200 : (redPhase ? 1800 : 2500);
              var maxGap = purplePhase ? 3000 : (redPhase ? 4500 : 6000);
              enemy.nextShootTime = now + minGap + Math.random() * (maxGap - minGap);
            } else if (!enemy.nextShootTime) {
              // Fallback for enemies that didn't get nextShootTime on spawn (fillers, barriers)
              var shootChance = CONFIG.enemyShootChance + (level - 2) * CONFIG.enemyShootIncrease;
              if (Math.random() < shootChance) {
                shootEnemyBullet(enemy);
              }
            }
          }
        }

        // Check wave completion
        checkWaveCompletion();

        // Spawn power-ups
        trySpawnPowerup();
      }

      requestAnimationFrame(draw);
    }

    // ============================================
    // GAME START
    // ============================================
    /**
     * Renders the four power-up icon previews into the intro card's small
     * `<canvas>` elements using the same shapes as the in-game pickups.
     * Called once at page load so the icons are visible before any game starts.
     */
    function drawCardPowerupIcons() {
      // Health ‚Äî red diamond with white plus
      (function () {
        var c = document.getElementById('puHealth');
        var g = c.getContext('2d');
        var w = c.width, h = c.height;
        g.fillStyle = '#FF3333';
        g.beginPath(); g.moveTo(w / 2, 0); g.lineTo(w, h / 2); g.lineTo(w / 2, h); g.lineTo(0, h / 2); g.closePath(); g.fill();
        g.strokeStyle = '#FF0000'; g.lineWidth = 2; g.stroke();
        g.fillStyle = '#FFFFFF';
        g.fillRect(w / 2 - 2, h / 4, 4, h / 2);
        g.fillRect(w / 4, h / 2 - 2, w / 2, 4);
      })();
      // Double Laser ‚Äî purple hexagon with double bars
      (function () {
        var c = document.getElementById('puLaser');
        var g = c.getContext('2d');
        var w = c.width, h = c.height, cx = w / 2, cy = h / 2, r = w / 2 - 1;
        g.fillStyle = '#9933FF';
        g.beginPath();
        for (var i = 0; i < 6; i++) {
          var a = (Math.PI / 3) * i - Math.PI / 2;
          if (i === 0) g.moveTo(cx + r * Math.cos(a), cy + r * Math.sin(a));
          else g.lineTo(cx + r * Math.cos(a), cy + r * Math.sin(a));
        }
        g.closePath(); g.fill();
        g.strokeStyle = '#6600CC'; g.lineWidth = 2; g.stroke();
        g.fillStyle = '#FFFFFF';
        g.fillRect(cx - 7, cy - 7, 3, 14);
        g.fillRect(cx + 4, cy - 7, 3, 14);
      })();
      // Shield ‚Äî aqua triangle with circle
      (function () {
        var c = document.getElementById('puShield');
        var g = c.getContext('2d');
        var w = c.width, h = c.height;
        g.fillStyle = '#00FFFF';
        g.beginPath(); g.moveTo(w / 2, 0); g.lineTo(w, h); g.lineTo(0, h); g.closePath(); g.fill();
        g.strokeStyle = '#00CCCC'; g.lineWidth = 2; g.stroke();
        g.beginPath(); g.arc(w / 2, h / 2 + 5, 6, 0, Math.PI * 2);
        g.strokeStyle = '#FFFFFF'; g.lineWidth = 2; g.stroke();
      })();
      // Quad Laser ‚Äî purple hexagon with four bars
      (function () {
        var c = document.getElementById('puQuad');
        var g = c.getContext('2d');
        var w = c.width, h = c.height, cx = w / 2, cy = h / 2, r = w / 2 - 1;
        g.fillStyle = '#9933FF';
        g.beginPath();
        for (var i = 0; i < 6; i++) {
          var a = (Math.PI / 3) * i - Math.PI / 2;
          if (i === 0) g.moveTo(cx + r * Math.cos(a), cy + r * Math.sin(a));
          else g.lineTo(cx + r * Math.cos(a), cy + r * Math.sin(a));
        }
        g.closePath(); g.fill();
        g.strokeStyle = '#6600CC'; g.lineWidth = 2; g.stroke();
        g.fillStyle = '#FFFFFF';
        var offsets = [-9, -3, 3, 9];
        for (var j = 0; j < 4; j++) { g.fillRect(cx + offsets[j], cy - 6, 2, 12); }
      })();
    }

    drawCardPowerupIcons();

    /**
     * Called by the intro card's "Start Game" button. Hides the card, shows the
     * Pause button in game-active state, then programmatically clicks the start
     * button to begin the first game session.
     */
    function startFromCard() {
      document.getElementById('introCard').style.display = 'none';
      var sb = document.getElementById('startButton');
      sb.style.display = 'block';
      sb.innerText = 'Pause';
      sb.classList.add('game-active');
      // Trigger the game start branch (gameOver is true on page load)
      sb.click();
    }

    // ‚îÄ‚îÄ Start / Pause button listener ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // Dual-purpose: when `gameOver` is true it fully resets and starts a new
    // game session; otherwise it toggles the pause state. All mutable game
    // state variables are explicitly reset here to avoid leftover values from
    // the previous run affecting the new session.
    var startButton = document.getElementById("startButton");
    startButton.addEventListener("click", function () {
      this.blur();

      if (gameOver) {
        // Reset game state
        stopBossMusic();
        stopCreditsMusic();
        gameOver = false;
        score = 0;
        level = 1;
        health = CONFIG.startingHealth;
        hasDoubleLaser = false;
        laserLevel = 1;
        hasShield = false;
        shieldHitsRemaining = 0;
        powerupsSpawnedThisLevel = { health: false, doubleLaser: false, shield: false };
        lastPowerupSpawnTime = 0;
        playerBlinking = false;
        playerVisible = true;
        bossActive = false;
        bossDefeated = false;
        boss = null;
        bossBlinking = false;
        bossVisible = true;

        // Reset phase tracking
        currentBoss = 0;
        boss1Defeated = false;
        boss2Defeated = false;
        boss3Defeated = false;
        redPhase = false;
        redPhaseStartScore = 0;
        purplePhase = false;
        purplePhaseStartScore = 0;

        // Reset wave state
        currentWave = 0;
        waveEnemiesRemaining = 0;
        waveInProgress = false;
        waveCooldown = false;
        lastWaveEndTime = 0;
        morphStartTime = 0;
        currentMorphShape = 0;
        formationRotation = 0;
        targetFormationRotation = 0;
        lastMorphTime = 0;
        morphCount = 0;
        barrierSpawned = false;
        barrierEnemies = [];
        pendingKamikazeCount = 0;
        kamikazesLaunched = false;
        kamikazeCenterY = -80;
        kamikazeCenterActive = false;
        formationEntered = false;
        formationCurrentCenterY = -200;
        shieldCascadeStarted = false;
        shieldCascadeTime = 0;
        shieldsDropped = 0;
        allShieldsDown = false;
        shieldRegenTime = 0;

        player.x = canvas.width / 2;
        player.y = canvas.height - 100;
        enemies = [];
        playerBullets = [];
        enemyBullets = [];
        powerups = [];
        bossMinions = [];
        bossOrbiters = [];
        orbitersInitialized = false;
        lastOrbiterDeathTime = 0;
        lastBossFillerBeat = 0;

        // Update UI
        updateUI();
        document.getElementById("levelDisplay").style.display = "none";
        document.getElementById("powerupDisplay").style.display = "none";
        document.getElementById("bonusDisplay").style.display = "none";
        document.getElementById("warningDisplay").style.display = "none";
        document.getElementById("pauseDisplay").style.display = "none";
        document.getElementById("gameOver").style.display = "none";
        document.getElementById("victory").style.display = "none";
        paused = false;

        startButton.innerText = "Pause";
        startButton.classList.add('game-active');

        // Track game start with A/B group and platform
        gtag('event', 'game_start', {
          'ab_music_group': userABGroup,
          'platform': 'desktop',
          'music_on': localStorage.getItem('nonex_music') !== 'off'
        });

        showAnnouncement("levelDisplay", "Level 1", 2000);
        startBackgroundMusic();
        draw();
      } else {
        // Game is running - toggle pause
        paused = !paused;
        document.getElementById("pauseDisplay").style.display = paused ? "block" : "none";
        startButton.innerText = paused ? "Resume" : "Pause";
        if (paused) {
          bgMusic.pause();
        } else {
          bgMusic.play();
        }
      }
    });


    // ‚îÄ‚îÄ Mute button listener ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    var muteButton = document.getElementById("muteButton");
    muteButton.addEventListener("click", function () {
      this.blur();
      toggleMusic();
    });
  </script>
</body>

</html>