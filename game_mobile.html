<!--
  ============================================================
  game_mobile.html â€” NON-X Mobile Game
  ============================================================
  Mobile build of the NON-X top-scrolling space shooter.
  Targets a portrait 9:19.5 canvas (480Ã—1040 px) that is
  scaled via CSS transform to fill the device viewport while
  preserving the intended aspect ratio.

  Controls:
    Touch & drag  â€” Move player ship (follows finger x)
    Hold touch    â€” Auto-fire cycle (1.8 s on / 0.4 s reload)
    P or Escape   â€” Pause (keyboard, for dev use)

  Game Structure: (identical to game.html desktop build)
    â€¢ 12 levels split across 3 phases (Original / Red / Purple)
    â€¢ Wave-based formation system with morphing shapes
    â€¢ 3 boss encounters at score thresholds:
        Boss 1 at score 400  (end of level 4)
        Boss 2 at score 1200 (end of level 8, red phase)
        Boss 3 at score 2000 (end of level 12, purple phase)
    â€¢ Power-up drops: Health (+10 HP), Double Laser, Shield,
      Quad Shot
    â€¢ High score leaderboard stored in localStorage (top 10)

  Mobile-specific additions vs game.html:
    â€¢ resizeCanvas()        â€” scales canvas to fit any device
    â€¢ getTouchCanvasX()     â€” converts touch CSS px â†’ canvas px
    â€¢ updateTouchControls() â€” movement + auto-fire shoot cycle
    â€¢ Touch event listeners on canvas (touchstart/move/end/cancel)
    â€¢ Touch state vars: touchActive, touchTargetX, TOUCH_SHOOT_*

  Image Assets (all in project root, paths use  prefix):
    player.png, enemy.png, enemy2â€“4.png, Boss.png,
    enemy1â€“4_Red.png, boss_Red.png,
    enemy1â€“4_purple.png, boss_purple.png

  Audio Assets (in sfx/):
    NonexFullSong.mp3, bossIntro.mp3,
    playerBullet.mp3, playerHit.mp3, playerDead.mp3,
    enemyDead.mp3, powerUp.mp3

  Audio Implementation:
    â€¢ Sound effects use intelligent throttling for mobile optimization
    â€¢ playerBullet: Waits for previous play to finish (no overlap)
    â€¢ enemyDead: Limited to 3 plays/second via time-based cooldown
    â€¢ Other SFX: Play immediately without throttling
    â€¢ No audio pools required (simple, clean, performant approach)
    â€¢ All sounds preloaded on game start to satisfy autoplay policies

  Dependencies: None (no external libraries or frameworks).
  Entry point: index.html â†’ launchGame() â†’ game_mobile.html
  ============================================================
-->
<!DOCTYPE html>
<html lang="en">

<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-9ECFZ9JBE5"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){window.dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-9ECFZ9JBE5', {
      'send_page_view': true,
      'page_title': 'NON-X Mobile Game',
      'page_location': window.location.href
    });
  </script>

  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NON-X - Mobile</title>
  <style>
    /* Prevent pull-to-refresh (mobile) and swipe-to-navigate (desktop touchpads) */
    html,
    body {
      overscroll-behavior: none;
      touch-action: none;
    }

    /* Full-screen black background; overflow hidden prevents any scroll */
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100vw;
      height: 100vh;
    }

    /* Full-viewport flex container â€” centres the scaled canvas */
    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    /* Canvas is rendered at native 480Ã—1040 and scaled by resizeCanvas() */
    canvas {
      border: none;
      display: block;
      background-color: rgb(0, 0, 0);
      touch-action: none;
      flex-shrink: 0;
    }

    /* UI overlays */
    #score,
    #levelIndicator,
    #health {
      font-size: 14px;
    }

    #startButton {
      position: absolute;
      top: 12px;
      left: 12px;
      padding: 10px 20px;
      font-size: 16px;
      z-index: 10;
      cursor: pointer;
      background: #00FFFF;
      color: #000;
      border: none;
      border-radius: 4px;
      font-weight: bold;
    }

    #muteButton {
      position: absolute;
      top: 12px;
      right: 12px;
      padding: 10px 15px;
      font-size: 20px;
      z-index: 10;
      cursor: pointer;
      background: #00FFFF;
      color: #000;
      border: none;
      border-radius: 4px;
      font-weight: bold;
      display: block;
    }

    #introCard {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 10;
      background: rgba(0, 0, 0, 0.88);
      border: 1px solid #00FFFF;
      border-radius: 12px;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.25);
      padding: 28px 30px;
      width: 340px;
      color: #ccc;
      font-family: Arial, sans-serif;
      text-align: left;
    }

    #introCard h2 {
      color: #00FFFF;
      font-size: 20px;
      letter-spacing: 2px;
      text-transform: uppercase;
      text-align: center;
      margin-bottom: 24px;
      text-shadow: 0 0 10px #00FFFF;
    }

    #introCard h3 {
      color: #fff;
      font-size: 13px;
      letter-spacing: 1px;
      text-transform: uppercase;
      margin-bottom: 8px;
      margin-top: 18px;
    }

    #introCard ul {
      list-style: none;
      padding: 0;
      margin: 0;
      font-size: 13px;
      line-height: 1.9;
      color: #bbb;
    }

    #introCard ul li::before {
      content: "â€” ";
      color: #00FFFF;
    }

    .powerup-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 4px;
    }

    .powerup-item {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 13px;
      color: #bbb;
    }

    .pu-icon {
      flex-shrink: 0;
      display: block;
    }

    #introCard .card-start-btn {
      display: block;
      width: 100%;
      margin-top: 26px;
      padding: 14px 0;
      font-size: 18px;
      font-family: Arial, sans-serif;
      font-weight: bold;
      letter-spacing: 2px;
      text-transform: uppercase;
      background: #00FFFF;
      color: #000;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
    }

    #score {
      color: white;
      position: absolute;
      top: 60px;
      right: 10px;
      font-size: 18px;
      z-index: 2;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
    }

    #gameOver {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 24px;
      color: #00FFFF;
      text-shadow: 0 0 10px #00FFFF;
      z-index: 2;
      text-align: center;
      line-height: 1.6;
    }

    #levelDisplay {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      color: #00FF00;
      text-shadow: 0 0 20px #00FF00, 0 0 40px #00FF00;
      z-index: 3;
      animation: levelPulse 0.5s ease-in-out;
    }

    @keyframes levelPulse {
      0% {
        transform: translate(-50%, -50%) scale(0.5);
        opacity: 0;
      }

      50% {
        transform: translate(-50%, -50%) scale(1.2);
        opacity: 1;
      }

      100% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
      }
    }

    #levelIndicator {
      display: none;
    }

    #health {
      color: white;
      position: absolute;
      top: 60px;
      left: 10px;
      font-size: 16px;
      z-index: 2;
    }

    #powerupDisplay {
      display: none;
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 32px;
      color: #FFD700;
      text-shadow: 0 0 15px #FFD700;
      z-index: 3;
      white-space: nowrap;
      text-align: center;
    }

    #bonusDisplay {
      display: none;
      position: absolute;
      top: 65%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 32px;
      color: #FFD700;
      text-shadow: 0 0 15px #FFD700;
      z-index: 3;
    }

    #warningDisplay {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 24px;
      color: #FFD700;
      text-shadow: 0 0 10px #FFD700, 0 0 20px #FFD700;
      z-index: 3;
      text-align: center;
      line-height: 1;
      animation: warningPulse 0.5s ease-in-out infinite;
    }

    #warningDisplay br {
      display: block;
      margin-top: 16px;
    }

    @keyframes warningPulse {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.6;
      }
    }

    #pauseDisplay {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      color: #FFFFFF;
      text-shadow: 0 0 20px #FFFFFF;
      z-index: 4;
    }

    #victory {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 18px;
      color: #00FFFF;
      text-shadow: 0 0 15px #00FFFF;
      z-index: 3;
      text-align: center;
      line-height: 1.4;
      max-width: 700px;
      width: 90%;
    }
  </style>
</head>

<body>
  <div id="container">

    <button id="startButton">Pause</button>
    <button id="muteButton">ðŸ”Š</button>

    <div id="introCard">
      <h2>NON-X</h2>
      <p>Can you defeat all 3 Alien Bosses?</p>

      <h3>Controls</h3>
      <ul>
        <li>Drag to move your ship</li>
        <li>Auto-fire enabled</li>
        <li>Tap Pause to pause</li>
      </ul>

      <h3>Power-ups</h3>
      <div class="powerup-list">
        <div class="powerup-item">
          <canvas class="pu-icon" id="puHealth" width="32" height="32"></canvas>
          <span>Health â€” restores 10 HP</span>
        </div>
        <div class="powerup-item">
          <canvas class="pu-icon" id="puLaser" width="32" height="32"></canvas>
          <span>Double Laser â€” dual shots</span>
        </div>
        <div class="powerup-item">
          <canvas class="pu-icon" id="puShield" width="32" height="32"></canvas>
          <span>Shield â€” absorbs hits</span>
        </div>
        <div class="powerup-item">
          <canvas class="pu-icon" id="puQuad" width="32" height="32"></canvas>
          <span>Triple/Quad Laser â€” three or four simultaneous shots</span>
        </div>
      </div>

      <button class="card-start-btn" onclick="startFromCard()">Start Game</button>
    </div>

    <div id="score">Score: 0</div>
    <canvas id="gameCanvas" width="480" height="1040"></canvas>
    <div id="levelIndicator">Level: 1</div>
    <div id="health">Health: 50</div>
    <div id="levelDisplay">Level 1</div>
    <div id="powerupDisplay"></div>
    <div id="bonusDisplay"></div>
    <div id="warningDisplay">Warning!<br><br>Shielded Enemy!</div>
    <div id="pauseDisplay">PAUSED</div>
    <div id="victory">Thank you for playing!<br><br>Special thanks to Modmotif for the music.<br><br>Please submit your
      email to download the song for remix.<br><br>&copy; 2026</div>
    <div id="gameOver">Game Over!</div>
  </div>

  <script>
    // ============================================
    // GAME CONFIGURATION
    // ============================================
    // Central tuning object. All gameplay-affecting numbers live here
    // so difficulty, feel, and balance can be adjusted in one place.
    // Values are identical to game.html unless noted otherwise.
    var CONFIG = {
      // Player settings
      playerSpeed: 5,
      bulletSpeed: 12,
      startingHealth: 100,
      maxHealth: 250,

      // Damage values
      enemyBulletDamage: 10,
      enemyCollisionDamage: 20,
      bossDamage: 25,
      healthPowerupAmount: 10,

      // Enemy settings
      enemyBaseSpeed: 1.5,
      enemySpeedIncrease: 0.3,
      enemySpawnRate: 0.01,
      enemySpawnIncrease: 0.005,

      // Enemy shooting (starts at level 2)
      enemyShootChance: 0.003,
      enemyShootIncrease: 0.001,
      enemyBulletSpeed: 5,

      // Boss settings
      boss1ScoreThreshold: 400,
      boss2ScoreThreshold: 1200,
      boss3ScoreThreshold: 2000,
      bossHealth: 50,
      bossSpeed: 1,
      bossShootChance: 0.02,

      // Level thresholds
      // Levels 1-4: original enemies, Boss 1 at 400
      // Levels 5-8: red enemies (start after Boss 1 defeated)
      // Level thresholds are calculated dynamically after Boss 1
      levelThresholds: [0, 100, 200, 300],

      // Red level speed multiplier (faster than original)
      redLevelSpeedMultiplier: 1.3,

      // Power-up settings
      powerupSpeed: 4,  // Twice as fast as enemies
      powerupSpawnChance: 0.003,

      // Boss minion settings
      bossMinionSpeed: 2,
      bossMinionSpawnChance: 0.015,

      // Enemy types per level (each level adds a new enemy)
      levelEnemyTypes: {
        1: ['enemy1'],
        2: ['enemy1', 'enemy2'],
        3: ['enemy1', 'enemy2', 'enemy3'],
        4: ['enemy1', 'enemy2', 'enemy3', 'enemy4'],
        5: ['enemy1_red'],
        6: ['enemy1_red', 'enemy2_red'],
        7: ['enemy1_red', 'enemy2_red', 'enemy3_red'],
        8: ['enemy1_red', 'enemy2_red', 'enemy3_red', 'enemy4_red'],
        9: ['enemy1_purple'],
        10: ['enemy1_purple', 'enemy2_purple'],
        11: ['enemy1_purple', 'enemy2_purple', 'enemy3_purple'],
        12: ['enemy1_purple', 'enemy2_purple', 'enemy3_purple', 'enemy4_purple']
      },

      // Enemies that zigzag
      zigzagEnemies: ['enemy3', 'enemy3_red', 'enemy4_red', 'enemy3_purple', 'enemy4_purple'],

      // Enemies that move side to side (horizontal)
      sideToSideEnemies: ['enemy2_red', 'enemy2_purple']
    };

    // ============================================
    // CANVAS AND IMAGE SETUP
    // ============================================
    // Native canvas dimensions: 480 Ã— 1040 (portrait 9:19.5).
    // resizeCanvas() scales it to fill the device viewport via CSS transform.
    var canvas = document.getElementById("gameCanvas");
    var ctx = canvas.getContext("2d");

    var playerImg = new Image();
    playerImg.src = "player.webp";

    var enemyImg1 = new Image();
    enemyImg1.src = "enemy.webp";

    var enemyImg2 = new Image();
    enemyImg2.src = "enemy2.webp";

    var enemyImg3 = new Image();
    enemyImg3.src = "enemy3.webp";

    var enemyImg4 = new Image();
    enemyImg4.src = "enemy4.webp";

    var bossImg = new Image();
    bossImg.src = "Boss.webp";

    // Red enemy images (levels 5-8)
    var enemyImg1Red = new Image();
    enemyImg1Red.src = "enemy1_Red.webp";

    var enemyImg2Red = new Image();
    enemyImg2Red.src = "enemy2_Red.webp";

    var enemyImg3Red = new Image();
    enemyImg3Red.src = "enemy3_Red.webp";

    var enemyImg4Red = new Image();
    enemyImg4Red.src = "enemy4_Red.webp";

    var bossImgRed = new Image();
    bossImgRed.src = "boss_Red.webp";

    // Purple enemy images (levels 9-12)
    var enemyImg1Purple = new Image();
    enemyImg1Purple.src = "enemy1_purple.webp";

    var enemyImg2Purple = new Image();
    enemyImg2Purple.src = "enemy2_purple.webp";

    var enemyImg3Purple = new Image();
    enemyImg3Purple.src = "enemy3_purple.webp";

    var enemyImg4Purple = new Image();
    enemyImg4Purple.src = "enemy4_purple.webp";

    var bossImgPurple = new Image();
    bossImgPurple.src = "boss_purple.webp";

    // ============================================
    // SOUND SETUP
    // ============================================
    var sounds = {
      playerBullet: new Audio("sfx/playerBullet.mp3"),
      playerHit: new Audio("sfx/playerHit.mp3"),
      playerDead: new Audio("sfx/playerDead.mp3"),
      enemyDead: new Audio("sfx/enemyDead.mp3"),
      bossIntro: new Audio("sfx/bossIntro.mp3"),
      powerUp: new Audio("sfx/powerUp.mp3")
    };

    // Background music (full song, looped)
    var bgMusic = new Audio("sfx/NonexFullSong.mp3");
    bgMusic.loop = true;
    bgMusic.volume = 0.79;

    // Credits music
    var creditsMusic = new Audio("sfx/NonexFullSong.mp3");
    creditsMusic.volume = 0.79;

    // Set sound effect volumes (all at 0.4)
    sounds.playerBullet.volume = 0.4;
    sounds.playerHit.volume = 0.4;
    sounds.playerDead.volume = 0.4;
    sounds.enemyDead.volume = 0.4;
    sounds.bossIntro.volume = 0.4;
    sounds.powerUp.volume = 0.4;

    // Boss intro music interval reference
    var bossIntroInterval = null;

    // Sound throttling for performance optimization
    var lastEnemyDeadTime = 0;
    var ENEMY_DEAD_COOLDOWN = 333; // Limit to 3 plays per second (1000ms / 3)

    /**
     * Plays a one-shot sound effect with intelligent throttling to optimize performance.
     *
     * Throttling strategy:
     * - playerBullet: Waits for previous instance to finish (prevents audio overlap)
     * - enemyDead: Time-based cooldown limiting to 3 plays per second
     * - All others: Play immediately without throttling
     *
     * This approach eliminates the need for audio pools while maintaining smooth
     * performance on mobile devices during high-frequency events.
     *
     * @param {string} soundName - Key in the `sounds` object ('playerBullet',
     *                             'playerHit', 'playerDead', 'enemyDead',
     *                             'bossIntro', 'powerUp').
     */
    function playSound(soundName) {
      var sound = sounds[soundName];
      if (!sound) return;

      // playerBullet: Prevent overlap by checking if previous play has finished
      if (soundName === 'playerBullet') {
        if (!sound.paused && sound.currentTime > 0 && !sound.ended) {
          return;
        }
      }

      // enemyDead: Time-based throttling (max 3 plays per second)
      if (soundName === 'enemyDead') {
        var now = Date.now();
        if (now - lastEnemyDeadTime < ENEMY_DEAD_COOLDOWN) {
          return;
        }
        lastEnemyDeadTime = now;
      }

      // Ensure audio is loaded before attempting playback
      if (sound.readyState < 2) {
        sound.load();
      }

      // Reset to beginning and play
      sound.currentTime = 0;
      sound.play().catch(function (e) {
        // Silently handle autoplay restrictions (browser policy)
      });
    }

    /**
     * Initiates boss encounter music sequence.
     *
     * Plays the boss intro sting immediately, then establishes a 10-second
     * interval that continues playing the sting throughout the boss fight
     * (until stopBossMusic() is called or game ends).
     */
    function startBossMusic() {
      playSound('bossIntro');
      bossIntroInterval = setInterval(function () {
        if (bossActive && !gameOver) {
          playSound('bossIntro');
        }
      }, 10000);
    }

    /**
     * Stops boss music playback and clears the repeat interval.
     *
     * Cleans up the interval timer and resets the boss intro audio element
     * to the beginning, ready for the next boss encounter.
     */
    function stopBossMusic() {
      if (bossIntroInterval) {
        clearInterval(bossIntroInterval);
        bossIntroInterval = null;
      }
      sounds.bossIntro.pause();
      sounds.bossIntro.currentTime = 0;
    }

    // ============================================
    // A/B TESTING - MUSIC DEFAULT
    // ============================================
    /**
     * Assigns user to A/B test group for music default setting.
     * Group A: Music ON by default
     * Group B: Music OFF by default
     * Assignment is random and persists in localStorage.
     */
    function initMusicABTest() {
      // Check if user already assigned to a group
      var abGroup = localStorage.getItem('nonx_ab_music_group');

      if (!abGroup) {
        // New user - randomly assign to group A or B
        abGroup = Math.random() < 0.5 ? 'A' : 'B';
        localStorage.setItem('nonx_ab_music_group', abGroup);

        // Set default music preference based on group
        // Only set if user hasn't manually changed it from main menu
        if (!localStorage.getItem('nonex_music')) {
          if (abGroup === 'A') {
            localStorage.setItem('nonex_music', 'on');
          } else {
            localStorage.setItem('nonex_music', 'off');
          }
        }
      }

      return abGroup;
    }

    // Initialize A/B test on page load
    var userABGroup = initMusicABTest();

    // â”€â”€ Developer Mode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Toggle with Shift+D. Never persists â€” resets on every page load.
    // Hotkeys active only while devMode is ON:
    //   Shift+V  â†’ skip to victory screen
    //   Shift+G  â†’ skip to game over screen
    // All analytics are suppressed and logged to console instead.
    var devMode = false;

    /**
     * Wrapper for all GA4 event calls. In devMode, logs to console instead of
     * sending to GA4 so analytics are never skewed during development/testing.
     * @param {string} eventName - GA4 event name
     * @param {Object} params    - Event parameters
     */
    function fireEvent(eventName, params) {
      if (devMode) {
        console.log(
          '%c[DEV MODE] Event suppressed: ' + eventName,
          'color:#00FFFF;font-weight:bold;background:#111;padding:2px 6px;border-radius:3px;',
          params
        );
        return;
      }
      gtag('event', eventName, params);
    }

    // â”€â”€ Session & User Identity Events â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    (function fireSessionEvents() {
      var isFirstVisit = !localStorage.getItem('nonx_has_visited');
      var musicVariant = localStorage.getItem('nonex_music') !== 'off' ? 'on' : 'off';

      // Always fire session_start on every page load
      fireEvent('session_start', {
        'ab_music_group': userABGroup,
        'platform': 'mobile',
        'music_variant': musicVariant
      });

      if (isFirstVisit) {
        fireEvent('first_visit', {
          'ab_music_group': userABGroup,
          'platform': 'mobile',
          'music_variant': musicVariant
        });
        localStorage.setItem('nonx_has_visited', 'true');
        localStorage.setItem('nonx_visit_count', '1');
      } else {
        var visitCount = parseInt(localStorage.getItem('nonx_visit_count') || '1', 10) + 1;
        localStorage.setItem('nonx_visit_count', String(visitCount));
        fireEvent('returning_user', {
          'ab_music_group': userABGroup,
          'platform': 'mobile',
          'music_variant': musicVariant,
          'visit_count': visitCount
        });
      }
    })();

    /**
     * Starts the looping background music track from the beginning.
     *
     * Respects user preference stored in localStorage ('nonex_music').
     * If music is disabled, this function returns without starting playback.
     */
    function startBackgroundMusic() {
      if (localStorage.getItem('nonex_music') === 'off') return;
      bgMusic.currentTime = 0;
      bgMusic.play().catch(function (e) {
        // Silently handle autoplay restrictions
      });
    }

    /**
     * Stops and resets the background music track to the beginning.
     */
    function stopBackgroundMusic() {
      bgMusic.pause();
      bgMusic.currentTime = 0;
    }

    /**
     * Toggles the background music on/off and updates the mute button icon.
     * Saves the preference to localStorage for persistence across sessions.
     * Music preference now persists whether changed in-game, victory, game over, or main menu.
     */
    function toggleMusic() {
      var muteBtn = document.getElementById('muteButton');
      var victoryMuteBtn = document.getElementById('victoryMuteBtn');
      var gameOverMuteBtn = document.getElementById('gameOverMuteBtn');

      if (bgMusic.paused) {
        bgMusic.play().catch(function (e) {
          // Silently handle autoplay restrictions
        });
        localStorage.setItem('nonex_music', 'on');
        if (muteBtn) muteBtn.textContent = 'ðŸ”Š';
        if (victoryMuteBtn) victoryMuteBtn.textContent = 'ðŸ”Š';
        if (gameOverMuteBtn) gameOverMuteBtn.textContent = 'ðŸ”Š';
      } else {
        bgMusic.pause();
        localStorage.setItem('nonex_music', 'off');
        if (muteBtn) muteBtn.textContent = 'ðŸ”‡';
        if (victoryMuteBtn) victoryMuteBtn.textContent = 'ðŸ”‡';
        if (gameOverMuteBtn) gameOverMuteBtn.textContent = 'ðŸ”‡';
      }
    }

    /**
     * Plays the credits music track (used on victory screen).
     *
     * Starts from the beginning and handles autoplay restrictions gracefully.
     */
    function startCreditsMusic() {
      creditsMusic.currentTime = 0;
      creditsMusic.play().catch(function (e) {
        // Silently handle autoplay restrictions
      });
    }

    /** Pauses and resets the credits music track. */
    function stopCreditsMusic() {
      creditsMusic.pause();
      creditsMusic.currentTime = 0;
    }

    /**
     * Submits score to the global leaderboard with optional Instagram handle.
     * Leaderboard is stored in localStorage and can sync to backend.
     */
    function submitToLeaderboard() {
      var igHandle = document.getElementById('igInput').value.trim();

      // Sanitize Instagram handle (remove @ and special chars)
      var sanitized = igHandle.replace(/[@<>'"]/g, '').substring(0, 30);

      // Get current leaderboard
      var leaderboard = JSON.parse(localStorage.getItem('nonx_leaderboard')) || [];

      // Add this score
      leaderboard.push({
        score: score,
        instagram: sanitized || 'Anonymous',
        date: new Date().toISOString(),
        platform: 'mobile' // or detect from user agent
      });

      // Sort by score descending and keep top 100
      leaderboard.sort(function (a, b) { return b.score - a.score; });
      leaderboard = leaderboard.slice(0, 100);

      // Save
      localStorage.setItem('nonx_leaderboard', JSON.stringify(leaderboard));

      // Track Leaderboard submissions
      fireEvent('leaderboard_submit', {
        'ab_music_group': userABGroup,
        'platform': 'mobile',
        'score': score,
        'instagram_provided': sanitized !== '',
        'music_variant': localStorage.getItem('nonex_music') !== 'off' ? 'on' : 'off'
      });

      // Show confirmation
      alert('Score submitted! You rank #' + (leaderboard.findIndex(function (e) { return e.score === score; }) + 1) + ' globally!');

      // Hide submit button, show leaderboard
      document.getElementById('leaderboardSubmit').style.display = 'none';
      showLeaderboard();
    }

    /**
     * Displays top 10 global leaderboard scores
     */
    function showLeaderboard() {
      var leaderboard = JSON.parse(localStorage.getItem('nonx_leaderboard')) || [];
      var top10 = leaderboard.slice(0, 10);

      var html = '<div style="margin-top: 20px; text-align: left; display: inline-block;"><strong>Top 10 Global Scores:</strong><br>';
      for (var i = 0; i < top10.length; i++) {
        var entry = top10[i];
        var igText = entry.instagram !== 'Anonymous' ? '@' + entry.instagram : entry.instagram;
        html += (i + 1) + '. ' + entry.score + ' - ' + igText + '<br>';
      }
      html += '</div>';

      document.getElementById('leaderboardDisplay').innerHTML = html;
    }

    // ============================================
    // GAME STATE
    // ============================================
    // â”€â”€ MOBILE TUNING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Adjust these after reviewing on a real device
    var PLAYER_START_Y_OFFSET = 350;  // px from bottom of canvas
    var PLAYER_SPRITE_W = 75;         // player sprite width
    var PLAYER_SPRITE_H = 75;         // player sprite height
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    var player = {
      x: canvas.width / 2,
      y: canvas.height - PLAYER_START_Y_OFFSET,
      width: PLAYER_SPRITE_W,
      height: PLAYER_SPRITE_H
    };

    var playerBullets = [];
    var enemyBullets = [];

    // ============================================
    // OBJECT POOLING (Phase 2)
    // ============================================
    // Reuses bullet objects to avoid GC stutter
    var BulletPool = {
      pool: [],
      init: function () {
        for (var i = 0; i < 200; i++) {
          this.pool.push({});
        }
      },
      get: function (x, y, w, h, speed) {
        var b = this.pool.length > 0 ? this.pool.pop() : {};
        b.x = x;
        b.y = y;
        b.width = w;
        b.height = h;
        b.speed = speed;
        b.isBossBullet = false; // Reset flag
        return b;
      },
      release: function (b) {
        this.pool.push(b);
      }
    };
    BulletPool.init();

    // Pool for Enemy objects to reduce GC
    var EnemyPool = {
      pool: [],
      init: function () {
        for (var i = 0; i < 100; i++) this.pool.push({});
      },
      get: function (config) {
        var e = this.pool.length > 0 ? this.pool.pop() : {};

        // RESET ALL FLAGS to safe defaults
        e.formation = false;
        e.kamikaze = false;
        e.kamikazeEntering = false;
        e.barrier = false;
        e.orbitEntering = false;
        e.sideEntry = false;
        e.zigzag = false;
        e.sideToSide = false;
        e.shielded = false;
        e.shieldHits = 0;
        e.shieldBroken = false;
        e.reachedTarget = false;
        e.nextShootTime = 0;
        e.breathPhase = 0;

        // Optional properties that might linger if not overwritten
        e.waveShapes = null;
        e.targetPos = null;
        e.startPos = null;
        e.currentPos = null;

        // Apply new config
        return Object.assign(e, config);
      },
      release: function (e) {
        this.pool.push(e);
      }
    };
    EnemyPool.init();

    // ============================================
    // SPATIAL PARTITIONING (Phase 3)
    // ============================================
    // Grid for O(1) collision lookups instead of O(N*M)
    var SpatialGrid = {
      cellSize: 100,
      cols: 0,
      rows: 0,
      grid: [],

      init: function () {
        this.cols = Math.ceil(canvas.width / this.cellSize) + 1; // +1 buffer
        this.rows = Math.ceil(canvas.height / this.cellSize) + 1;
        var size = this.cols * this.rows;
        for (var i = 0; i < size; i++) {
          this.grid.push([]);
        }
      },

      clear: function () {
        for (var i = 0; i < this.grid.length; i++) {
          this.grid[i].length = 0; // Fast clear
        }
      },

      insert: function (enemy) {
        // Skip enemies vastly off screen
        if (enemy.y < -150 || enemy.y > canvas.height + 50) return;

        var startCol = Math.floor(enemy.x / this.cellSize);
        var endCol = Math.floor((enemy.x + enemy.width) / this.cellSize);
        var startRow = Math.floor(enemy.y / this.cellSize);
        var endRow = Math.floor((enemy.y + enemy.height) / this.cellSize);

        // Clamping to known grid bounds (handling off-screen slightly)
        if (startCol < 0) startCol = 0;
        if (endCol >= this.cols) endCol = this.cols - 1;
        if (startRow < 0) startRow = 0;
        if (endRow >= this.rows) endRow = this.rows - 1;

        for (var c = startCol; c <= endCol; c++) {
          for (var r = startRow; r <= endRow; r++) {
            this.grid[r * this.cols + c].push(enemy);
          }
        }
      },

      // Returns potential collision candidates (deduplication needed if multi-cell)
      retrieve: function (bullet) {
        if (bullet.y < 0 || bullet.y > canvas.height) return [];

        var startCol = Math.floor(bullet.x / this.cellSize);
        var endCol = Math.floor((bullet.x + bullet.width) / this.cellSize);
        var startRow = Math.floor(bullet.y / this.cellSize);
        var endRow = Math.floor((bullet.y + bullet.height) / this.cellSize);

        if (startCol < 0) startCol = 0;
        if (endCol >= this.cols) endCol = this.cols - 1;
        if (startRow < 0) startRow = 0;
        if (endRow >= this.rows) endRow = this.rows - 1;

        var candidates = [];

        // Simple dedupe: check if already in candidates
        // Actually, with simple arrays and indexOf check it's likely faster for small N
        for (var c = startCol; c <= endCol; c++) {
          for (var r = startRow; r <= endRow; r++) {
            var cell = this.grid[r * this.cols + c];
            for (var k = 0; k < cell.length; k++) {
              if (candidates.indexOf(cell[k]) === -1) {
                candidates.push(cell[k]);
              }
            }
          }
        }
        return candidates;
      }
    };
    SpatialGrid.init();

    var enemies = [];
    var powerups = [];
    var explosions = []; // Simple array for enemy death explosions
    var score = 0;
    var level = 1;
    var health = 50;
    var gameOver = true;
    var paused = false;
    // Load top 10 high scores from localStorage
    var highScores = JSON.parse(localStorage.getItem('xenonHighScores')) || [];

    /**
     * Inserts a score into the top-10 leaderboard, sorts descending, trims to
     * 10 entries, and persists to `localStorage` under `xenonHighScores`.
     * @param {number} newScore - The score to add.
     */
    function addHighScore(newScore) {
      highScores.push(newScore);
      highScores.sort(function (a, b) { return b - a; }); // Sort descending
      highScores = highScores.slice(0, 10); // Keep only top 10
      localStorage.setItem('xenonHighScores', JSON.stringify(highScores));
    }

    /**
     * Returns true if `newScore` would make it into the current top-10 list.
     * Always returns true when fewer than 10 scores have been recorded.
     * @param {number} newScore
     * @returns {boolean}
     */
    function isTopTenScore(newScore) {
      if (highScores.length < 10) return true;
      return newScore > highScores[highScores.length - 1];
    }

    /**
     * Returns the 1-based rank position that `newScore` would occupy in the
     * existing sorted leaderboard (lower rank = better).
     * @param {number} newScore
     * @returns {number} Rank, from 1 (best) to highScores.length + 1 (last).
     */
    function getScoreRank(newScore) {
      for (var i = 0; i < highScores.length; i++) {
        if (newScore >= highScores[i]) return i + 1;
      }
      return highScores.length + 1;
    }
    var rightPressed = false;
    var leftPressed = false;

    // Mobile touch state
    var touchActive = false;
    var touchTargetX = 0;           // canvas-space x the player should follow
    var touchShootActive = false;   // currently in shoot window
    var touchShootCycleStart = 0;   // when the current cycle began
    var TOUCH_SHOOT_DURATION = 1800;  // 1.8 seconds shooting
    var TOUCH_SHOOT_COOLDOWN = 400;   // 0.4 second reload
    var touchLastShot = 0;
    var TOUCH_SHOOT_INTERVAL = 130;   // fire every 130ms while active

    // Power-up state
    var hasDoubleLaser = false;
    var laserLevel = 1; // 1 = single, 2 = double, 3 = triple, 4 = quad (purple phase only)
    var powerupsSpawnedThisLevel = { health: false, doubleLaser: false, shield: false };
    var lastPowerupSpawnTime = 0;
    var powerupSpawnCooldown = 5000; // 5 seconds minimum between power-ups

    // Player blink state (when damaged)
    var playerBlinking = false;
    var playerBlinkTimer = 0;
    var playerVisible = true;

    // Boss state
    var boss = null;
    var bossActive = false;
    var bossDefeated = false;
    var bossMinions = [];  // Side-scrolling enemies during boss fight
    var bossBlinking = false;
    var bossBlinkTimer = 0;
    var bossVisible = true;

    // Screen shake state
    var screenShakeActive = false;
    var screenShakeIntensity = 0;
    var screenShakeDuration = 0;
    var screenShakeTimer = 0;

    // Game phase tracking
    var currentBoss = 0;        // 0 = no boss yet, 1 = boss 1, 2 = boss 2, 3 = boss 3
    var boss1Defeated = false;
    var boss2Defeated = false;
    var boss3Defeated = false;
    var redPhase = false;       // True after boss 1 is defeated (levels 5-8)
    var redPhaseStartScore = 0; // Score when red phase started
    var purplePhase = false;    // True after boss 2 is defeated (levels 9-12)
    var purplePhaseStartScore = 0;

    // Power-up types
    var POWERUP_TYPES = {
      HEALTH: 'health',       // Red diamond - restore health
      DOUBLE_LASER: 'laser',  // Purple hexagon - double lasers
      SHIELD: 'shield'        // Aqua triangle - damage shield
    };

    // Shield state
    var hasShield = false;
    var shieldHitsRemaining = 0;

    // ============================================
    // UI UPDATES
    // ============================================
    /**
     * Syncs the score, level, and health DOM elements with current game state.
     * Called after any change to those values.
     */
    function updateUI() {
      document.getElementById("score").innerText = "Score: " + score;
      document.getElementById("levelIndicator").innerText = "Level: " + level;
      document.getElementById("health").innerText = "Health: " + health;
    }

    /**
     * Briefly shows a HUD overlay element with the given text, then hides it
     * after `duration` milliseconds (default 2000 ms).
     * @param {string} element  - DOM element ID (e.g. 'levelDisplay').
     * @param {string} text     - Text to display.
     * @param {number} [duration=2000] - Display duration in milliseconds.
     */
    function showAnnouncement(element, text, duration) {
      var el = document.getElementById(element);
      el.innerText = text;
      el.style.display = "block";
      setTimeout(function () {
        el.style.display = "none";
      }, duration || 2000);
    }

    // Screen shake effect
    /**
     * Initiates a screen-shake effect by translating the canvas element with
     * random offsets that decay over the specified duration.
     * @param {number} [intensity=10] - Maximum pixel offset in each direction.
     * @param {number} [duration=500] - Total shake duration in milliseconds.
     */
    function triggerScreenShake(intensity, duration) {
      screenShakeActive = true;
      screenShakeIntensity = intensity || 10;
      screenShakeDuration = duration || 500;
      screenShakeTimer = Date.now();
    }

    /**
     * Called every frame. Applies or clears the CSS transform that produces
     * the screen-shake effect, with intensity decaying linearly over time.
     */
    function updateScreenShake() {
      if (!screenShakeActive) {
        canvas.style.transform = '';
        return;
      }

      var elapsed = Date.now() - screenShakeTimer;
      if (elapsed >= screenShakeDuration) {
        screenShakeActive = false;
        canvas.style.transform = '';
        return;
      }

      // Decrease intensity over time for decay effect
      var progress = elapsed / screenShakeDuration;
      var currentIntensity = screenShakeIntensity * (1 - progress);

      // Random shake offset
      var offsetX = (Math.random() - 0.5) * 2 * currentIntensity;
      var offsetY = (Math.random() - 0.5) * 2 * currentIntensity;

      canvas.style.transform = 'translate(' + offsetX + 'px, ' + offsetY + 'px)';
    }

    // ============================================
    // LEVEL MANAGEMENT
    // ============================================
    /**
     * Refreshes UI after each enemy kill. Level progression itself is handled
     * by the wave system (see `advanceLevel`); this is purely a UI sync hook.
     */
    function checkLevelUp() {
      // Wave-based system handles level progression via advanceLevel()
      // This function is only used for additional score tracking
      updateUI();
    }

    // ============================================
    // POWER-UP SYSTEM
    // ============================================
    /**
     * Spawns a power-up of the specified type at a random horizontal position
     * along the top of the canvas, avoiding collision with existing enemies.
     * Up to 10 placement attempts are made; returns false if no safe spot found.
     * @param {string} type - One of POWERUP_TYPES (HEALTH, DOUBLE_LASER, SHIELD).
     * @returns {boolean} True if the power-up was successfully added.
     */
    function createPowerup(type) {
      // Double laser moves slightly slower (3.5) than health powerup (4)
      var speed = (type === POWERUP_TYPES.DOUBLE_LASER) ? 3.5 : CONFIG.powerupSpeed;
      var width = 48; // Increased by 20% (was 40)
      var height = 48;

      // Clamp spawn x to the visible canvas strip (cover-scaled), with 20px
      // inward margin to prevent edge-spawned powerups clipping off-screen
      // when the breathing animation scales them up.
      var POWERUP_MARGIN = 20;
      var scale = Math.max(window.innerWidth / canvas.width, window.innerHeight / canvas.height);
      var visibleHalf = (window.innerWidth / scale) / 2;
      var spawnMinX = Math.max(0, canvas.width / 2 - visibleHalf) + POWERUP_MARGIN;
      var spawnMaxX = Math.min(canvas.width - width, canvas.width / 2 + visibleHalf - width) - POWERUP_MARGIN;

      // Find a non-overlapping spawn position (try up to 10 times)
      var x, y = 0;
      var attempts = 0;
      do {
        x = spawnMinX + Math.random() * (spawnMaxX - spawnMinX);
        attempts++;
      } while (isOverlappingEnemy(x, y, width, height) && attempts < 10);

      // If we couldn't find a spot, skip spawning
      if (attempts >= 10 && isOverlappingEnemy(x, y, width, height)) {
        return false; // Indicate spawn failed
      }

      powerups.push({
        x: x,
        y: y,
        width: width,
        height: height,
        speed: speed,
        type: type
      });
      return true;
    }

    // 123 BPM = 488ms per beat
    var BPM_INTERVAL = 60000 / 123; // ~488ms

    /**
     * Renders a single power-up to the canvas with a BPM-synced breathing scale
     * and two expanding ripple rings. Each type has a distinct shape and color:
     *   HEALTH      â†’ red diamond with white plus
     *   DOUBLE_LASER â†’ purple hexagon with double bars
     *   SHIELD      â†’ aqua triangle with inner circle
     * @param {Object} powerup - Power-up object from the `powerups` array.
     */
    function drawPowerup(powerup) {
      if (!powerup) return;
      var time = Date.now();

      // OPTIMIZATION: Use pre-rendered sprite instead of drawing shapes.
      // 1. Calculate breathing scale.
      // 2. Draw pre-rendered ripple frames.
      // 3. Draw pre-rendered powerup icon.

      // Breathing effect
      var breathInterval = BPM_INTERVAL * 2;
      var breathProgress = (time % breathInterval) / breathInterval;
      var breathScale = 1 + Math.sin(breathProgress * Math.PI) * 0.15;

      var baseSize = 64; // Size of pre-rendered asset
      // Original powerup width/height is 40.
      // We want to draw it at ~48px size (20% larger).
      // 64px asset -> 48px target.
      var targetSize = 48 * breathScale;

      var cx = powerup.x + powerup.width / 2;
      var cy = powerup.y + powerup.height / 2;

      // Draw Ripple (PRE-RENDERED)
      var beatPhase = (time % BPM_INTERVAL) / BPM_INTERVAL;
      var rippleAlpha = 1 - beatPhase;

      if (rippleAlpha > 0.05) {
        var rippleKey = 'purple'; // Default
        if (powerup.type === 'health') rippleKey = 'red';
        else if (powerup.type === 'shield') rippleKey = 'blue'; // Use Blue (Sky) for Shield (Aqua)
        else rippleKey = 'purple';

        var frames = preRenderedRipples[rippleKey + '_regular'];
        if (frames) {
          var frameIndex = Math.floor(beatPhase * (frames.length - 1));
          var rippleCanvas = frames[frameIndex];
          if (rippleCanvas) {
            // Powerup ripple size?
            // Original: maxRadius = w * 1.5 (~60px).
            // Regular ripple maxRadius = 55 (Dia 110).
            // Draw regular ripple centered.
            ctx.globalAlpha = rippleAlpha * 0.5;
            ctx.drawImage(rippleCanvas, cx - rippleCanvas.width / 2, cy - rippleCanvas.height / 2);
            ctx.globalAlpha = 1.0;

            // Second ripple
            var beatPhase2 = ((time + BPM_INTERVAL / 2) % BPM_INTERVAL) / BPM_INTERVAL;
            var frameIndex2 = Math.floor(beatPhase2 * (frames.length - 1));
            var rippleCanvas2 = frames[frameIndex2];
            if (rippleCanvas2) {
              ctx.globalAlpha = (1 - beatPhase2) * 0.3;
              ctx.drawImage(rippleCanvas2, cx - rippleCanvas2.width / 2, cy - rippleCanvas2.height / 2);
              ctx.globalAlpha = 1.0;
            }
          }
        }
      }

      // Draw Powerup Sprite
      var sprite = preRenderedPowerups[powerup.type];
      if (sprite) {
        ctx.drawImage(sprite, cx - targetSize / 2, cy - targetSize / 2, targetSize, targetSize);
      }
    }

    /**
     * Applies the effect of a collected power-up to the player and shows the
     * appropriate HUD announcement. Collecting any power-up also awards 5 pts.
     * @param {Object} powerup - The power-up object being collected.
     */
    function collectPowerup(powerup) {
      playSound('powerUp');
      score += 5;
      updateUI();
      if (powerup.type === POWERUP_TYPES.HEALTH) {
        health = Math.min(health + CONFIG.healthPowerupAmount, CONFIG.maxHealth);
        updateUI();
        showAnnouncement("powerupDisplay", "+10 Health!", 1500);
      } else if (powerup.type === POWERUP_TYPES.DOUBLE_LASER) {
        if (purplePhase && hasDoubleLaser) {
          if (laserLevel === 2) {
            laserLevel = 3;
            showAnnouncement("powerupDisplay", "TRIPLE LASER!", 1500);
          } else if (laserLevel === 3) {
            laserLevel = 4;
            showAnnouncement("powerupDisplay", "QUAD LASER!", 1500);
          } else {
            // Already at max power
            score += 50;
            showAnnouncement("powerupDisplay", "MAX POWER +50", 1500);
          }
        } else {
          hasDoubleLaser = true;
          laserLevel = 2;
          showAnnouncement("powerupDisplay", "Double Laser!", 1500);
        }
      } else if (powerup.type === POWERUP_TYPES.SHIELD) {
        hasShield = true;
        shieldHitsRemaining = 5;
        showAnnouncement("powerupDisplay", "Shield Active!", 1500);
      }
    }

    // ============================================
    // EXPLOSION EFFECTS
    // ============================================
    /**
     * Creates an expanding ring explosion effect when an enemy dies.
     * Regular enemies: Single ring, 300ms duration.
     * Boss enemies: Triple concentric rings, 500ms duration for dramatic effect.
     * @param {number} x - Center X position of explosion
     * @param {number} y - Center Y position of explosion
     * @param {boolean} isBoss - If true, creates a larger triple-ring boss explosion
     */
    function spawnExplosion(x, y, isBoss) {
      explosions.push({
        x: x,
        y: y,
        startTime: Date.now(),
        duration: isBoss ? 500 : 300, // Boss explosions last longer
        isBoss: isBoss || false
      });
    }

    /**
     * Updates and draws all active explosions. Removes completed ones.
     * Regular enemies: Single expanding ring.
     * Boss enemies: Triple concentric rings expanding at different rates.
     * Color is based on current game phase (cyan/red/purple).
     */
    function updateExplosions() {
      var now = Date.now();

      for (var i = explosions.length - 1; i >= 0; i--) {
        var exp = explosions[i];
        var elapsed = now - exp.startTime;

        // Remove completed explosions
        if (elapsed >= exp.duration) {
          explosions.splice(i, 1);
          continue;
        }

        // Calculate animation progress (0 to 1)
        var progress = elapsed / exp.duration;

        // Fading alpha (1.0 to 0)
        var alpha = 1.0 - progress;

        // Color based on phase
        var color = purplePhase ? '138, 43, 226' : (redPhase ? '255, 69, 0' : '0, 255, 255');

        if (exp.isBoss) {
          // Boss explosion: Triple concentric rings at different speeds
          // Ring 1 (outer, fastest): 30px â†’ 100px
          var radius1 = 30 + (progress * 70);
          ctx.beginPath();
          ctx.arc(exp.x, exp.y, radius1, 0, Math.PI * 2);
          ctx.strokeStyle = 'rgba(' + color + ', ' + (alpha * 0.8) + ')';
          ctx.lineWidth = 3;
          ctx.stroke();

          // Ring 2 (middle, medium speed): 20px â†’ 75px
          var radius2 = 20 + (progress * 55);
          ctx.beginPath();
          ctx.arc(exp.x, exp.y, radius2, 0, Math.PI * 2);
          ctx.strokeStyle = 'rgba(' + color + ', ' + alpha + ')';
          ctx.lineWidth = 3;
          ctx.stroke();

          // Ring 3 (inner, slowest): 10px â†’ 50px
          var radius3 = 10 + (progress * 40);
          ctx.beginPath();
          ctx.arc(exp.x, exp.y, radius3, 0, Math.PI * 2);
          ctx.strokeStyle = 'rgba(' + color + ', ' + (alpha * 1.2) + ')';
          ctx.lineWidth = 4;
          ctx.stroke();
        } else {
          // Regular enemy explosion: Single ring (10px â†’ 30px)
          var radius = 10 + (progress * 20);
          ctx.beginPath();
          ctx.arc(exp.x, exp.y, radius, 0, Math.PI * 2);
          ctx.strokeStyle = 'rgba(' + color + ', ' + alpha + ')';
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      }
    }

    /**
     * Attempts to spawn a power-up based on random chance, respecting a 5-second
     * minimum cooldown between drops and a per-level one-of-each limit.
     * Priority: health (40%) â†’ double laser (70%) â†’ shield (level 3+) â†’ health fallback.
     */
    function trySpawnPowerup() {
      // Stagger power-ups - minimum 5 seconds between spawns
      var now = Date.now();
      if (now - lastPowerupSpawnTime < powerupSpawnCooldown) return;
      if (Math.random() > CONFIG.powerupSpawnChance) return;

      // Randomly choose which power-up to try spawning
      // Only mark as spawned if createPowerup succeeds
      var rand = Math.random();
      var spawned = false;

      if (!powerupsSpawnedThisLevel.health && rand < 0.4) {
        if (createPowerup(POWERUP_TYPES.HEALTH)) {
          powerupsSpawnedThisLevel.health = true;
          spawned = true;
        }
      } else if (!powerupsSpawnedThisLevel.doubleLaser && rand < 0.7) {
        if (createPowerup(POWERUP_TYPES.DOUBLE_LASER)) {
          powerupsSpawnedThisLevel.doubleLaser = true;
          spawned = true;
        }
      } else if (!powerupsSpawnedThisLevel.shield && level >= 3) {
        // Shield only spawns level 3+
        if (createPowerup(POWERUP_TYPES.SHIELD)) {
          powerupsSpawnedThisLevel.shield = true;
          spawned = true;
        }
      } else if (!powerupsSpawnedThisLevel.health) {
        if (createPowerup(POWERUP_TYPES.HEALTH)) {
          powerupsSpawnedThisLevel.health = true;
          spawned = true;
        }
      }

      if (spawned) {
        lastPowerupSpawnTime = now;
      }
    }

    // ============================================
    // ENEMY CREATION AND DRAWING
    // ============================================
    /**
     * Randomly selects an enemy sprite type from the roster unlocked for the
     * current level (defined in `CONFIG.levelEnemyTypes`).
     * @returns {string} Enemy type key (e.g. 'enemy1', 'enemy3_red').
     */
    function getEnemyType() {
      var availableTypes = CONFIG.levelEnemyTypes[level] || CONFIG.levelEnemyTypes[4];
      var randomIndex = Math.floor(Math.random() * availableTypes.length);
      return availableTypes[randomIndex];
    }

    /**
     * AABB overlap test between a candidate rect and all current enemies.
     * Used to find non-colliding spawn positions for enemies and power-ups.
     * @param {number} x      - Candidate rect left edge.
     * @param {number} y      - Candidate rect top edge.
     * @param {number} width  - Candidate rect width.
     * @param {number} height - Candidate rect height.
     * @returns {boolean} True if the rect overlaps any existing enemy.
     */
    function isOverlappingEnemy(x, y, width, height) {
      for (var i = 0; i < enemies.length; i++) {
        var e = enemies[i];
        if (x < e.x + e.width &&
          x + width > e.x &&
          y < e.y + e.height &&
          y + height > e.y) {
          return true;
        }
      }
      return false;
    }

    /**
     * Creates a single freeform (non-formation) enemy at a random top-edge x
     * position, with speed, type, and movement behaviour determined by the
     * current level and phase. Zigzag and side-to-side behaviours are assigned
     * based on `CONFIG.zigzagEnemies` / `CONFIG.sideToSideEnemies`.
     * Returns early (no-op) if no non-overlapping position is found in 10 tries.
     */
    function createEnemy() {
      var speedVariation = 1;
      var effectiveLevel = redPhase ? (level - 4) : level; // Levels 5-8 map to 1-4 for speed calc
      var baseSpeed = CONFIG.enemyBaseSpeed + (effectiveLevel - 1) * CONFIG.enemySpeedIncrease;

      // Apply speed multiplier for red phase
      if (redPhase) {
        baseSpeed *= CONFIG.redLevelSpeedMultiplier;
      }

      var enemyType = getEnemyType();
      var width = 50;
      var height = 50;

      // enemy2_red is 50% smaller than normal enemies
      if (enemyType === 'enemy2_red') {
        width = 29;
        height = 29;
      }

      // Find a non-overlapping spawn position (try up to 10 times)
      var x, y = 0;
      var attempts = 0;
      do {
        x = Math.random() * (canvas.width - width);
        attempts++;
      } while (isOverlappingEnemy(x, y, width, height) && attempts < 10);

      // If we couldn't find a spot after 10 tries, skip spawning
      if (attempts >= 10 && isOverlappingEnemy(x, y, width, height)) {
        return;
      }

      var enemy = {
        x: x,
        y: y,
        width: width,
        height: height,
        baseWidth: width,
        baseHeight: height,
        speed: baseSpeed + Math.random() * speedVariation,
        type: enemyType,
        breathPhase: Math.random() // Random phase for breathing effect
      };

      // Add zigzag properties based on config
      if (CONFIG.zigzagEnemies.indexOf(enemyType) !== -1) {
        enemy.zigzag = true;
        enemy.zigzagDirection = Math.random() < 0.5 ? 1 : -1;
        enemy.zigzagSpeed = 2;
        enemy.zigzagTimer = 0;
        enemy.zigzagInterval = 30; // Change direction every 30 frames
      }

      // Add side-to-side movement for enemy2_red
      if (CONFIG.sideToSideEnemies.indexOf(enemyType) !== -1) {
        enemy.sideToSide = true;
        enemy.horizontalDirection = Math.random() < 0.5 ? 1 : -1;
        enemy.horizontalSpeed = 2;
      }

      enemies.push(enemy);
    }

    // ============================================
    // WAVE-BASED FORMATION SYSTEM
    // ============================================

    // Wave state tracking
    var currentWave = 0;        // 0 = not started, 1 = wave 1, 2 = wave 2
    var waveEnemiesRemaining = 0;
    var waveInProgress = false;
    var waveCooldown = false;
    var lastWaveEndTime = 0;
    var morphStartTime = 0;     // When current formation started (for morphing)
    var currentMorphShape = 0;  // Index into formation shapes

    // Formation shapes - each has a collapsed and exploded version
    // Dance pattern: exploded (enter) -> collapsed -> exploded (repeat)
    var FORMATION_SHAPES = {
      // 3x3 Grid - collapsed
      grid3x3: function (count) {
        var positions = [];
        var cols = 3, rows = 3;
        var spacing = 0.35;
        for (var row = 0; row < rows; row++) {
          for (var col = 0; col < cols; col++) {
            if (positions.length >= count) break;
            positions.push({ x: (col - 1) * spacing, y: (row - 1) * spacing });
          }
        }
        return positions;
      },
      // 3x3 Grid - exploded
      grid3x3Exploded: function (count) {
        var positions = [];
        var cols = 3, rows = 3;
        var spacing = 0.35;
        var explode = 2.5;
        for (var row = 0; row < rows; row++) {
          for (var col = 0; col < cols; col++) {
            if (positions.length >= count) break;
            var x = (col - 1) * spacing;
            var y = (row - 1) * spacing;
            var dist = Math.sqrt(x * x + y * y);
            if (dist > 0.01) { x *= explode; y *= explode; }
            positions.push({ x: x, y: y });
          }
        }
        return positions;
      },
      // Diamond - 9 enemies (4 corners + 4 edges + 1 center)
      diamond: function (count) {
        var positions = [];
        var size = 0.4;
        // Center
        positions.push({ x: 0, y: 0 });
        // 4 cardinal points
        positions.push({ x: 0, y: -size });      // top
        positions.push({ x: size, y: 0 });       // right
        positions.push({ x: 0, y: size });       // bottom
        positions.push({ x: -size, y: 0 });      // left
        // 4 diagonal points (outer)
        positions.push({ x: -size * 0.7, y: -size * 0.7 }); // top-left
        positions.push({ x: size * 0.7, y: -size * 0.7 });  // top-right
        positions.push({ x: size * 0.7, y: size * 0.7 });   // bottom-right
        positions.push({ x: -size * 0.7, y: size * 0.7 });  // bottom-left
        return positions.slice(0, count);
      },
      // Diamond - exploded
      diamondExploded: function (count) {
        var positions = [];
        var size = 1.0;
        positions.push({ x: 0, y: 0 });
        positions.push({ x: 0, y: -size });
        positions.push({ x: size, y: 0 });
        positions.push({ x: 0, y: size });
        positions.push({ x: -size, y: 0 });
        positions.push({ x: -size * 0.7, y: -size * 0.7 });
        positions.push({ x: size * 0.7, y: -size * 0.7 });
        positions.push({ x: size * 0.7, y: size * 0.7 });
        positions.push({ x: -size * 0.7, y: size * 0.7 });
        return positions.slice(0, count);
      },
      // Circle - evenly spaced ring
      circle: function (count) {
        var positions = [];
        var radius = 0.45;
        for (var i = 0; i < count; i++) {
          var angle = (i / count) * Math.PI * 2 - Math.PI / 2;
          positions.push({ x: Math.cos(angle) * radius, y: Math.sin(angle) * radius });
        }
        return positions;
      },
      // Circle - exploded
      circleExploded: function (count) {
        var positions = [];
        var radius = 1.1;
        for (var i = 0; i < count; i++) {
          var angle = (i / count) * Math.PI * 2 - Math.PI / 2;
          positions.push({ x: Math.cos(angle) * radius, y: Math.sin(angle) * radius });
        }
        return positions;
      },
      // Flying V - point facing down
      flyingV: function (count) {
        var positions = [];
        var spacing = 0.25;
        var half = Math.floor(count / 2);
        // Tip at bottom center
        positions.push({ x: 0, y: spacing * half * 0.7 });
        // Left arm going up-left
        for (var i = 1; i <= half; i++) {
          positions.push({ x: -spacing * i, y: spacing * (half - i) * 0.7 });
        }
        // Right arm going up-right â€” fixed: use <= to match left arm count
        for (var i = 1; i <= count - half - 1; i++) {
          positions.push({ x: spacing * i, y: spacing * (half - i) * 0.7 });
        }
        return positions.slice(0, count);
      },
      // Flying V - exploded
      flyingVExploded: function (count) {
        var positions = [];
        var spacing = 0.5;
        var half = Math.floor(count / 2);
        positions.push({ x: 0, y: spacing * half * 0.7 });
        for (var i = 1; i <= half; i++) {
          positions.push({ x: -spacing * i, y: spacing * (half - i) * 0.7 });
        }
        // Right arm going up-right â€” fixed: use <= to match left arm count
        for (var i = 1; i <= count - half - 1; i++) {
          positions.push({ x: spacing * i, y: spacing * (half - i) * 0.7 });
        }
        return positions.slice(0, count);
      },
      // 4x4 Square grid
      grid4x4: function (count) {
        var positions = [];
        var spacing = 0.28;
        for (var row = 0; row < 4; row++) {
          for (var col = 0; col < 4; col++) {
            if (positions.length >= count) break;
            positions.push({ x: (col - 1.5) * spacing, y: (row - 1.5) * spacing });
          }
        }
        return positions;
      },
      // 4x4 Square - exploded
      grid4x4Exploded: function (count) {
        var positions = [];
        var spacing = 0.28;
        var explode = 2.2;
        for (var row = 0; row < 4; row++) {
          for (var col = 0; col < 4; col++) {
            if (positions.length >= count) break;
            var x = (col - 1.5) * spacing;
            var y = (row - 1.5) * spacing;
            var dist = Math.sqrt(x * x + y * y);
            if (dist > 0.01) { x *= explode; y *= explode; }
            positions.push({ x: x, y: y });
          }
        }
        return positions;
      },
      // Double Diamond - inner (5) + outer (8)
      doubleDiamond: function (count) {
        var positions = [];
        var innerSize = 0.25;
        var outerSize = 0.55;
        // Inner diamond (5)
        positions.push({ x: 0, y: 0 });
        positions.push({ x: 0, y: -innerSize });
        positions.push({ x: innerSize, y: 0 });
        positions.push({ x: 0, y: innerSize });
        positions.push({ x: -innerSize, y: 0 });
        // Outer diamond (8)
        positions.push({ x: 0, y: -outerSize });
        positions.push({ x: outerSize, y: 0 });
        positions.push({ x: 0, y: outerSize });
        positions.push({ x: -outerSize, y: 0 });
        positions.push({ x: -outerSize * 0.7, y: -outerSize * 0.7 });
        positions.push({ x: outerSize * 0.7, y: -outerSize * 0.7 });
        positions.push({ x: outerSize * 0.7, y: outerSize * 0.7 });
        positions.push({ x: -outerSize * 0.7, y: outerSize * 0.7 });
        return positions.slice(0, count);
      },
      // Double Diamond - exploded
      doubleDiamondExploded: function (count) {
        var positions = [];
        var innerSize = 0.5;
        var outerSize = 1.1;
        positions.push({ x: 0, y: 0 });
        positions.push({ x: 0, y: -innerSize });
        positions.push({ x: innerSize, y: 0 });
        positions.push({ x: 0, y: innerSize });
        positions.push({ x: -innerSize, y: 0 });
        positions.push({ x: 0, y: -outerSize });
        positions.push({ x: outerSize, y: 0 });
        positions.push({ x: 0, y: outerSize });
        positions.push({ x: -outerSize, y: 0 });
        positions.push({ x: -outerSize * 0.7, y: -outerSize * 0.7 });
        positions.push({ x: outerSize * 0.7, y: -outerSize * 0.7 });
        positions.push({ x: outerSize * 0.7, y: outerSize * 0.7 });
        positions.push({ x: -outerSize * 0.7, y: outerSize * 0.7 });
        return positions.slice(0, count);
      },
      // Double V - front V (5) + rear V (6)
      doubleV: function (count) {
        var positions = [];
        var spacing = 0.22;
        // Front V (closer to bottom, 5 enemies)
        positions.push({ x: 0, y: 0.3 }); // tip
        positions.push({ x: -spacing, y: 0.1 });
        positions.push({ x: spacing, y: 0.1 });
        positions.push({ x: -spacing * 2, y: -0.1 });
        positions.push({ x: spacing * 2, y: -0.1 });
        // Rear V (further back, 6 enemies)
        positions.push({ x: 0, y: -0.15 }); // tip
        positions.push({ x: -spacing, y: -0.35 });
        positions.push({ x: spacing, y: -0.35 });
        positions.push({ x: -spacing * 2, y: -0.55 });
        positions.push({ x: spacing * 2, y: -0.55 });
        positions.push({ x: 0, y: -0.55 }); // extra center back
        return positions.slice(0, count);
      },
      // Double V - exploded
      doubleVExploded: function (count) {
        var positions = [];
        var spacing = 0.45;
        positions.push({ x: 0, y: 0.6 });
        positions.push({ x: -spacing, y: 0.2 });
        positions.push({ x: spacing, y: 0.2 });
        positions.push({ x: -spacing * 2, y: -0.2 });
        positions.push({ x: spacing * 2, y: -0.2 });
        positions.push({ x: 0, y: -0.3 });
        positions.push({ x: -spacing, y: -0.7 });
        positions.push({ x: spacing, y: -0.7 });
        positions.push({ x: -spacing * 2, y: -1.1 });
        positions.push({ x: spacing * 2, y: -1.1 });
        positions.push({ x: 0, y: -1.1 });
        return positions.slice(0, count);
      },
      // Dual Sine Waves - two parallel wavy lines
      dualSineWave: function (count) {
        var positions = [];
        var half = Math.floor(count / 2);
        var xSpacing = 0.2;
        var amplitude = 0.15;
        // Top wave
        for (var i = 0; i < half; i++) {
          var x = (i - (half - 1) / 2) * xSpacing;
          var y = Math.sin(i * 0.8) * amplitude - 0.25;
          positions.push({ x: x, y: y });
        }
        // Bottom wave (offset phase)
        for (var i = 0; i < count - half; i++) {
          var x = (i - (count - half - 1) / 2) * xSpacing;
          var y = Math.sin(i * 0.8 + Math.PI) * amplitude + 0.25;
          positions.push({ x: x, y: y });
        }
        return positions;
      },
      // Dual Sine Waves - exploded
      dualSineWaveExploded: function (count) {
        var positions = [];
        var half = Math.floor(count / 2);
        var xSpacing = 0.35;
        var amplitude = 0.3;
        for (var i = 0; i < half; i++) {
          var x = (i - (half - 1) / 2) * xSpacing;
          var y = Math.sin(i * 0.8) * amplitude - 0.55;
          positions.push({ x: x, y: y });
        }
        for (var i = 0; i < count - half; i++) {
          var x = (i - (count - half - 1) / 2) * xSpacing;
          var y = Math.sin(i * 0.8 + Math.PI) * amplitude + 0.55;
          positions.push({ x: x, y: y });
        }
        return positions;
      },

      // Spiral - Archimedean spiral (collapsed)
      // Min radius 0.56 ensures arc-spacing >= enemy width at spreadRadius=175
      spiral: function (count) {
        var positions = [];
        for (var i = 0; i < count; i++) {
          var t = (i / count) * Math.PI * 3.5; // 1.75 full turns
          var r = 0.56 + 0.32 * (i / count);   // range 0.56â€“0.88
          positions.push({ x: Math.cos(t) * r, y: Math.sin(t) * r * 0.55 });
        }
        return positions;
      },
      // Spiral - exploded (wide scatter along spiral arms)
      spiralExploded: function (count) {
        var positions = [];
        for (var i = 0; i < count; i++) {
          var t = (i / count) * Math.PI * 3.5;
          var r = 0.62 + 0.36 * (i / count);   // range 0.62â€“0.98, all start wide
          positions.push({ x: Math.cos(t) * r, y: Math.sin(t) * r * 0.45 });
        }
        return positions;
      },

      // Hex Grid - honeycomb layout (collapsed)
      hexGrid: function (count) {
        var positions = [];
        var spacing = 0.28;
        // Offset rows to form hex grid â€” 20 positions to cover max count
        var layout = [
          [-1, -0.5], [0, -0.5], [1, -0.5],
          [-0.5, 0],  [0.5, 0],
          [-1, 0.5],  [0, 0.5],  [1, 0.5],
          [-0.5, -1], [0.5, -1],
          [-0.5, 1],  [0.5, 1],
          [0, -1.5],  [0, 1.5],
          [-1, -1.5], [1, -1.5],
          [-1, 1.5],  [1, 1.5],
          [-1.5, 0],  [1.5, 0]
        ];
        for (var i = 0; i < Math.min(count, layout.length); i++) {
          positions.push({ x: layout[i][0] * spacing, y: layout[i][1] * spacing });
        }
        return positions.slice(0, count);
      },
      // Hex Grid - exploded
      hexGridExploded: function (count) {
        var positions = [];
        var spacing = 0.28;
        var explode = 2.8;
        var layout = [
          [-1, -0.5], [0, -0.5], [1, -0.5],
          [-0.5, 0],  [0.5, 0],
          [-1, 0.5],  [0, 0.5],  [1, 0.5],
          [-0.5, -1], [0.5, -1],
          [-0.5, 1],  [0.5, 1],
          [0, -1.5],  [0, 1.5],
          [-1, -1.5], [1, -1.5],
          [-1, 1.5],  [1, 1.5],
          [-1.5, 0],  [1.5, 0]
        ];
        for (var i = 0; i < Math.min(count, layout.length); i++) {
          var x = layout[i][0] * spacing;
          var y = layout[i][1] * spacing;
          var dist = Math.sqrt(x * x + y * y);
          if (dist > 0.01) { x *= explode; y *= explode; }
          positions.push({ x: x, y: y });
        }
        return positions.slice(0, count);
      },

      // Twin Circles - two concentric rings (collapsed)
      twinCircles: function (count) {
        var positions = [];
        var innerCount = Math.floor(count * 0.45);
        var outerCount = count - innerCount;
        var innerR = 0.25;
        var outerR = 0.55;
        for (var i = 0; i < innerCount; i++) {
          var a = (i / innerCount) * Math.PI * 2;
          positions.push({ x: Math.cos(a) * innerR, y: Math.sin(a) * innerR * 0.7 });
        }
        for (var i = 0; i < outerCount; i++) {
          var a = (i / outerCount) * Math.PI * 2;
          positions.push({ x: Math.cos(a) * outerR, y: Math.sin(a) * outerR * 0.7 });
        }
        return positions;
      },
      // Twin Circles - exploded
      twinCirclesExploded: function (count) {
        var positions = [];
        var innerCount = Math.floor(count * 0.45);
        var outerCount = count - innerCount;
        var innerR = 0.6;
        var outerR = 1.2;
        for (var i = 0; i < innerCount; i++) {
          var a = (i / innerCount) * Math.PI * 2;
          positions.push({ x: Math.cos(a) * innerR, y: Math.sin(a) * innerR * 0.7 });
        }
        for (var i = 0; i < outerCount; i++) {
          var a = (i / outerCount) * Math.PI * 2;
          positions.push({ x: Math.cos(a) * outerR, y: Math.sin(a) * outerR * 0.7 });
        }
        return positions;
      },

      // Arrowhead - filled triangle pointing down (collapsed)
      arrowhead: function (count) {
        var positions = [];
        var rows = Math.ceil(Math.sqrt(count * 2));
        for (var row = 0; row < rows && positions.length < count; row++) {
          var cols = rows - row;
          var yPos = -0.45 + row * (0.9 / (rows - 1));
          for (var col = 0; col < cols && positions.length < count; col++) {
            var xPos = cols === 1 ? 0 : (col / (cols - 1) - 0.5) * (cols * 0.28);
            positions.push({ x: xPos, y: yPos });
          }
        }
        return positions.slice(0, count);
      },
      // Arrowhead - exploded (wide fan)
      arrowheadExploded: function (count) {
        var positions = [];
        var rows = Math.ceil(Math.sqrt(count * 2));
        var explode = 2.4;
        for (var row = 0; row < rows && positions.length < count; row++) {
          var cols = rows - row;
          var yPos = -0.45 + row * (0.9 / (rows - 1));
          for (var col = 0; col < cols && positions.length < count; col++) {
            var xPos = cols === 1 ? 0 : (col / (cols - 1) - 0.5) * (cols * 0.28);
            positions.push({ x: xPos * explode, y: yPos * explode });
          }
        }
        return positions.slice(0, count);
      }
    };

    // Level definitions - single wave per level
    // Dance pattern: exploded (enter) -> collapsed -> exploded (repeat)
    // Barriers: circle, horizontalLine, arrow, orbitingShield, dualLines
    var LEVEL_WAVES = {
      1: {
        enemyType: 'enemy1',
        waves: [
          { count: 9, kamikazes: 2, shapes: ['grid3x3Exploded', 'grid3x3'], barrier: 'circle', barrierCount: 5 }
        ]
      },
      2: {
        enemyType: 'enemy2',
        waves: [
          { count: 9, kamikazes: 2, shapes: ['diamondExploded', 'diamond'], barrier: 'horizontalLine', barrierCount: 5 }
        ]
      },
      3: {
        enemyType: 'enemy3',
        waves: [
          { count: 10, kamikazes: 2, shapes: ['circleExploded', 'circle'], barrier: null }
        ]
      },
      4: {
        enemyType: 'enemy4',
        waves: [
          { count: 9, kamikazes: 2, shapes: ['flyingVExploded', 'flyingV'], barrier: 'arrow', barrierCount: 5 }
        ]
      },
      5: {
        enemyType: 'enemy1_red',
        waves: [
          { count: 16, kamikazes: 2, shapes: ['grid4x4Exploded', 'grid4x4'], barrier: null }
        ]
      },
      6: {
        enemyType: 'enemy2_red',
        waves: [
          { count: 13, kamikazes: 2, shapes: ['doubleDiamondExploded', 'doubleDiamond'], barrier: 'orbitingShield', barrierCount: 6 }
        ]
      },
      7: {
        enemyType: 'enemy3_red',
        waves: [
          { count: 11, kamikazes: 3, shapes: ['doubleVExploded', 'doubleV'], barrier: null }
        ]
      },
      8: {
        enemyType: 'enemy4_red',
        waves: [
          { count: 12, kamikazes: 3, shapes: ['dualSineWaveExploded', 'dualSineWave'], barrier: 'dualLines', barrierCount: 8 }
        ]
      },
      9: {
        enemyType: 'enemy1_purple',
        waves: [
          { count: 18, kamikazes: 3, shapes: ['spiralExploded', 'spiral'], barrier: 'orbitingShield', barrierCount: 8 }
        ]
      },
      10: {
        enemyType: 'enemy2_purple',
        waves: [
          { count: 20, kamikazes: 4, shapes: ['hexGridExploded', 'hexGrid'], barrier: 'dualLines', barrierCount: 10 }
        ]
      },
      11: {
        enemyType: 'enemy3_purple',
        waves: [
          { count: 22, kamikazes: 4, shapes: ['twinCirclesExploded', 'twinCircles'], barrier: 'circle', barrierCount: 8 }
        ]
      },
      12: {
        enemyType: 'enemy4_purple',
        waves: [
          { count: 25, kamikazes: 5, shapes: ['arrowheadExploded', 'arrowhead'], barrier: 'arrow', barrierCount: 8 }
        ]
      }
    };

    // Barrier reinforcement tracking
    var morphCount = 0;
    var barrierSpawned = false;
    var barrierEnemies = []; // Track barrier enemies separately

    /**
     * Initialises and begins a numbered wave for the current level. Resets all
     * formation and barrier tracking state, then delegates to
     * `spawnMorphingFormation()` to create the enemy group.
     * @param {number} waveNum - 1-based wave index within the current level.
     */
    function startWave(waveNum) {
      var levelData = LEVEL_WAVES[level];
      if (!levelData || waveNum > levelData.waves.length) return;

      currentWave = waveNum;
      waveInProgress = true;
      waveCooldown = false;
      morphStartTime = Date.now();
      currentMorphShape = 0;

      // Track highest wave reached
      fireEvent('wave_reached', {
        'ab_music_group': userABGroup,
        'platform': 'mobile',
        'wave_number': level,
        'music_variant': localStorage.getItem('nonex_music') !== 'off' ? 'on' : 'off'
      });

      // Reset formation and barrier tracking
      formationRotation = 0;
      targetFormationRotation = 0;
      lastMorphTime = Date.now();
      morphCount = 0;
      barrierSpawned = false;
      barrierEnemies = [];
      pendingKamikazeCount = 0;
      kamikazesLaunched = false;

      var waveData = levelData.waves[waveNum - 1];
      waveEnemiesRemaining = waveData.count;

      spawnMorphingFormation(waveData);

      showAnnouncement("levelDisplay", "Level " + level, 1500);
    }

    // Formation center tracking - moves as a unit
    var formationCurrentCenterY = -200;
    var formationTargetCenterY = 320;
    var formationEntrySpeed = 1.8;
    var formationEntered = false;

    // Kamikaze wave tracking (separate from formation)
    var pendingKamikazeCount = 0;
    var kamikazesLaunched = false;
    var kamikazeCenterY = -80;
    var kamikazeCenterTargetY = 320;
    var kamikazeCenterActive = false;

    // Shield cascade system
    var shieldCascadeStarted = false;
    var shieldCascadeTime = 0;
    var shieldsDropped = 0;
    var allShieldsDown = false;
    var shieldRegenTime = 0;

    /**
     * Instantiates all formation enemies for the current wave. Enemies enter
     * from above the canvas in the first (exploded) shape and are marked
     * `formation: true`. Each enemy carries its `waveShapes` list so
     * `updateMorphingFormation()` knows what to cycle through. All formation
     * enemies start shielded.
     * @param {Object} waveData - Wave descriptor from `LEVEL_WAVES[level].waves`.
     */
    function spawnMorphingFormation(waveData) {
      var count = waveData.count;
      var centerX = canvas.width / 2;
      var targetY = 320;
      var spreadRadius = purplePhase ? 175 : 140;

      // Store kamikaze count to be launched separately after formation settles
      pendingKamikazeCount = waveData.kamikazes || 2;
      kamikazesLaunched = false;

      // Reset formation center - starts well above screen so all enemies enter from top
      formationCurrentCenterY = -200;
      formationTargetCenterY = targetY;
      formationEntered = false;

      var levelData = LEVEL_WAVES[level];
      var enemyType = levelData.enemyType;

      // Get initial shape positions (exploded - enters spread out)
      var shapeFunc = FORMATION_SHAPES[waveData.shapes[0]];
      if (typeof shapeFunc !== 'function') {
        console.error('Formation shape not found:', waveData.shapes[0]);
        shapeFunc = FORMATION_SHAPES['grid3x3']; // safe fallback
      }
      var positions = shapeFunc(count);

      for (var i = 0; i < count; i++) {
        var pos = positions[i];
        if (!pos) {
          console.error('No position for formation enemy index', i, 'â€” shape returned', positions.length, 'positions for count', count);
          break; // stop spawning rather than crash
        }
        var width = 50;
        var height = 50;

        if (enemyType === 'enemy2_red' || enemyType === 'enemy2_purple') {
          width = 35;
          height = 35;
        }

        // Position relative to formation center (which will move)
        var enemy = {
          x: centerX + pos.x * spreadRadius - width / 2,
          y: formationCurrentCenterY + pos.y * spreadRadius * 0.8 - height / 2,
          width: width,
          height: height,
          baseWidth: width,
          baseHeight: height,
          speed: formationEntrySpeed,
          type: enemyType,
          formation: true,
          formationType: 'morphing',
          targetY: targetY,
          reachedTarget: false,
          formationIndex: i,
          formationCount: count,
          waveShapes: waveData.shapes,
          spreadRadius: spreadRadius,
          centerX: centerX,
          centerY: targetY,
          breathPhase: i * 0.12,
          startPos: { x: pos.x, y: pos.y },
          currentPos: { x: pos.x, y: pos.y },
          targetPos: { x: pos.x, y: pos.y },
          shielded: true,  // Start with shield
          shieldOrder: i,  // Order for cascade (lower = drops first)
          nextShootTime: Date.now() + 2000 + Math.random() * 4000  // Staggered random shoot times
        };

        enemies.push(EnemyPool.get(enemy));
      }

      // Reset shield cascade tracking
      shieldCascadeStarted = false;
      shieldCascadeTime = 0;
      shieldsDropped = 0;
      allShieldsDown = false;
      shieldRegenTime = 0;
    }

    /**
     * Spawns a group of kamikaze enemies that first enter from the top in a
     * horizontal spread, then dive toward the player's position once the group
     * center has reached its target Y (handled by `updateKamikazeEntry`).
     * @param {number} count - Number of kamikaze enemies to spawn.
     */
    function spawnKamikazeWave(count) {
      var levelData = LEVEL_WAVES[level];
      var enemyType = levelData ? levelData.enemyType : 'enemy1';
      var width = 50, height = 50;
      if (enemyType === 'enemy2_red' || enemyType === 'enemy2_purple') { width = 35; height = 35; }

      // Set up center that will scroll down, all kamikazes follow it
      kamikazeCenterY = -80;
      kamikazeCenterTargetY = 320;
      kamikazeCenterActive = true;

      // Spread evenly across screen width, with slight random jitter
      var spacing = (canvas.width - 80) / (count + 1);
      for (var k = 0; k < count; k++) {
        var centerOffsetX = (spacing * (k + 1) + 40) - canvas.width / 2;
        centerOffsetX += (Math.random() - 0.5) * 30;
        enemies.push(EnemyPool.get({
          x: canvas.width / 2 + centerOffsetX - width / 2,
          y: kamikazeCenterY - height / 2,
          width: width,
          height: height,
          baseWidth: width,
          baseHeight: height,
          type: enemyType,
          formation: false,
          kamikaze: true,
          kamikazeEntering: true,
          kamikazeCenterOffsetX: centerOffsetX,
          shielded: false,
          breathPhase: Math.random()
        }));
      }
    }

    /**
     * Moves the invisible kamikaze group center downward each frame. Once it
     * reaches its target Y, all kamikazes are given a velocity vector aimed at
     * the player's current position and begin their dive.
     */
    function updateKamikazeEntry() {
      if (!kamikazeCenterActive) return;

      // Faster entry animation for smoother kamikaze descent (was 0.045)
      kamikazeCenterY += (kamikazeCenterTargetY - kamikazeCenterY) * 0.08;

      if (kamikazeCenterTargetY - kamikazeCenterY < 1) {
        kamikazeCenterY = kamikazeCenterTargetY;
        kamikazeCenterActive = false;

        // Center has landed â€” trigger all kamikazes to dive
        for (var i = 0; i < enemies.length; i++) {
          var e = enemies[i];
          if (e.kamikaze && e.kamikazeEntering) {
            e.kamikazeEntering = false;
            var speed = (purplePhase ? 4.5 : 4) + Math.random() * 2;
            var dx = player.x + player.width / 2 - (e.x + e.width / 2);
            var dy = player.y + player.height / 2 - (e.y + e.height / 2);
            var dist = Math.sqrt(dx * dx + dy * dy) || 1;
            e.kamikazeVelX = (dx / dist) * speed;
            e.kamikazeVelY = (dy / dist) * speed;
            e.kamikazeSpeed = speed;
          }
        }
      } else {
        // Update all entering kamikaze positions relative to descending center
        for (var i = 0; i < enemies.length; i++) {
          var e = enemies[i];
          if (e.kamikaze && e.kamikazeEntering) {
            e.x = canvas.width / 2 + e.kamikazeCenterOffsetX - e.width / 2;
            e.y = kamikazeCenterY - e.height / 2;
          }
        }
      }
    }

    // Track formation for simple dance
    var formationRotation = 0;
    var targetFormationRotation = 0;
    var lastMorphTime = 0;

    /**
     * Cubic ease-in-out interpolation for smooth, natural formation movement.
     * @param {number} t - Progress from 0.0 (start) to 1.0 (end).
     * @returns {number} Eased value in the same 0â€“1 range.
     */
    function easeInOutCubic(t) {
      return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }

    /**
     * Drives the formation dance cycle. Every 6 BPM beats (~3 s) the formation
     * switches to the next shape in `waveShapes`, updating each enemy's
     * `targetPos`. Enemy positions are smoothly lerped using `easeInOutCubic`
     * over 70% of the morph interval, then held. Also triggers kamikaze launch
     * after the second morph and shield cascade after the third.
     * @param {number} time - Current timestamp from `Date.now()`.
     */
    function updateMorphingFormation(time) {
      // Dance timing: morph every 6 beats (~3 seconds at 123 BPM)
      var morphInterval = BPM_INTERVAL * 6;
      var timeSinceStart = Math.max(0, time - morphStartTime); // clamp to avoid negative
      var newShapeIndex = Math.floor(timeSinceStart / morphInterval);

      // Get formation enemies
      var formationEnemies = enemies.filter(function (e) { return e.formation && e.formationType === 'morphing'; });
      if (formationEnemies.length === 0) return;

      var waveShapes = formationEnemies[0].waveShapes;
      if (!waveShapes || waveShapes.length === 0) return;

      // Cycle through shapes â€” use ((n % len) + len) % len to guarantee positive index in JS
      newShapeIndex = ((newShapeIndex % waveShapes.length) + waveShapes.length) % waveShapes.length;

      // If shape changed, update target positions
      if (newShapeIndex !== currentMorphShape) {
        currentMorphShape = newShapeIndex;
        morphCount++;
        lastMorphTime = time;

        // Hide shield warning after 3 morphs (enemies now vulnerable)
        if (morphCount === 3) {
          document.getElementById("warningDisplay").style.display = "none";
        }

        // Spawn barrier after first collapse (morphCount 1 = collapsed state)
        if (morphCount === 1 && !barrierSpawned) {
          var levelData = LEVEL_WAVES[level];
          var waveData = levelData.waves[currentWave - 1];
          if (waveData.barrier) {
            spawnBarrier(waveData.barrier, waveData.barrierCount || 5);
          }
        }

        var shapeName = waveShapes[newShapeIndex];
        var shapeFunc = FORMATION_SHAPES[shapeName];
        if (typeof shapeFunc !== 'function') {
          console.error('Morph shape not found:', shapeName, '(index', newShapeIndex, ')');
          shapeFunc = FORMATION_SHAPES['grid3x3']; // safe fallback
        }
        var count = formationEnemies[0].formationCount;
        var newPositions = shapeFunc(count);

        // Store starting positions and update targets
        formationEnemies.forEach(function (enemy, idx) {
          if (newPositions[idx]) {
            enemy.startPos = { x: enemy.currentPos.x, y: enemy.currentPos.y };
            enemy.targetPos = { x: newPositions[idx].x, y: newPositions[idx].y };
          }
        });

        // Launch kamikaze wave separately after formation has settled (morphCount 2)
        if (morphCount === 2 && !kamikazesLaunched && pendingKamikazeCount > 0) {
          kamikazesLaunched = true;
          spawnKamikazeWave(pendingKamikazeCount);
        }
      }

      // Calculate eased progress (use 70% of interval for transition, hold for rest)
      var morphDuration = morphInterval * 0.7;
      var timeSinceMorph = time - lastMorphTime;
      var morphProgress = Math.min(timeSinceMorph / morphDuration, 1);
      var easedProgress = easeInOutCubic(morphProgress);

      formationEnemies.forEach(function (enemy) {
        if (!enemy.reachedTarget) return;

        // Smooth interpolation between positions
        if (enemy.startPos) {
          enemy.currentPos.x = enemy.startPos.x + (enemy.targetPos.x - enemy.startPos.x) * easedProgress;
          enemy.currentPos.y = enemy.startPos.y + (enemy.targetPos.y - enemy.startPos.y) * easedProgress;
        } else {
          enemy.currentPos.x = enemy.targetPos.x;
          enemy.currentPos.y = enemy.targetPos.y;
        }

        // Calculate actual position (no rotation - clean dance)
        var baseX = enemy.centerX + enemy.currentPos.x * enemy.spreadRadius;
        var baseY = enemy.centerY + enemy.currentPos.y * enemy.spreadRadius * 0.8;

        enemy.x = baseX - enemy.width / 2;
        enemy.y = baseY - enemy.height / 2;

        // Keep in bounds
        if (enemy.x < 20) enemy.x = 20;
        if (enemy.x > canvas.width - enemy.width - 20) enemy.x = canvas.width - enemy.width - 20;
        if (enemy.y < 30) enemy.y = 30;
        if (enemy.y > canvas.height * 0.5) enemy.y = canvas.height * 0.5;
      });
    }

    /**
     * Manages the rolling shield cascade for formation enemies. After 3 morphs,
     * shields drop 2-at-a-time every 2 seconds (ordered by `shieldOrder`).
     * Once all shields are down they regenerate after 5 seconds. Shields
     * permanently broken by 15+ hits (25+ at level 9+) are excluded from regen.
     */
    // Shield cascade system - shields drop 2 at a time, then regenerate
    function updateShieldCascade() {
      var formationEnemies = enemies.filter(function (e) {
        return e.formation && e.formationType === 'morphing';
      });
      if (formationEnemies.length === 0) return;

      var now = Date.now();

      // Start cascade after 3 morphs
      if (morphCount >= 3 && !shieldCascadeStarted) {
        shieldCascadeStarted = true;
        shieldCascadeTime = now;
        shieldsDropped = 0;
        allShieldsDown = false;
      }

      if (!shieldCascadeStarted) return;

      // If all shields are down, check for regeneration
      if (allShieldsDown) {
        if (now - shieldRegenTime >= 5000) {
          // Regenerate all shields (except those broken by 25 hits)
          formationEnemies.forEach(function (e) {
            if (!e.shieldBroken) {
              e.shielded = true;
              e.shieldHits = 0; // Reset hit counter on regen
            }
          });
          // Reset cascade
          shieldCascadeStarted = true;
          shieldCascadeTime = now;
          shieldsDropped = 0;
          allShieldsDown = false;
          // Show brief warning for shield regen
          var warningEl = document.getElementById("warningDisplay");
          warningEl.style.display = "block";
          setTimeout(function () {
            warningEl.style.display = "none";
          }, 1500);
        }
        return;
      }

      // Drop shields every 2 seconds (2 enemies at a time)
      var timeSinceCascadeStart = now - shieldCascadeTime;
      var shouldHaveDropped = Math.floor(timeSinceCascadeStart / 2000) * 2;

      if (shouldHaveDropped > shieldsDropped) {
        // Find shielded enemies sorted by shieldOrder
        var shieldedEnemies = formationEnemies
          .filter(function (e) { return e.shielded; })
          .sort(function (a, b) { return a.shieldOrder - b.shieldOrder; });

        // Drop shields from next 2 enemies
        var toDrop = Math.min(2, shieldedEnemies.length);
        for (var i = 0; i < toDrop; i++) {
          shieldedEnemies[i].shielded = false;
        }
        shieldsDropped += toDrop;

        // Check if all shields are now down
        var remainingShielded = formationEnemies.filter(function (e) { return e.shielded; });
        if (remainingShielded.length === 0) {
          allShieldsDown = true;
          shieldRegenTime = now;
        }
      }
    }

    // Spawn barrier reinforcements (4-8 enemies forming a protective barrier)
    // Barriers stay between player and formation, no further than halfway down screen
    function spawnBarrier(barrierType, count) {
      if (barrierSpawned) return;
      barrierSpawned = true;

      var levelData = LEVEL_WAVES[level];
      var enemyType = levelData ? levelData.enemyType : 'enemy1';
      var width = 50;
      var height = 50;
      if (enemyType === 'enemy2_red' || enemyType === 'enemy2_purple') { width = 35; height = 35; }

      var centerX = canvas.width / 2;
      var barrierY = canvas.height * 0.45; // Halfway down screen max

      if (barrierType === 'circle' || barrierType === 'orbitingShield') {
        // Circle/orbiting barrier â€” enemies drop from above screen to their orbit start position
        var radius = 180;
        var orbitSpeed = barrierType === 'orbitingShield' ? 0.015 : 0.01;
        for (var i = 0; i < count; i++) {
          var angle = (i / count) * Math.PI * 2;
          var orbitX = centerX + Math.cos(angle) * radius - width / 2;
          var orbitY = 160 + Math.sin(angle) * radius * 0.6 - height / 2;
          var enemy = {
            x: orbitX,
            y: -height,           // start above screen
            targetY: orbitY,      // drop to orbit start position
            width: width,
            height: height,
            baseWidth: width,
            baseHeight: height,
            speed: 2.5,
            type: enemyType,
            formation: false,
            barrier: true,
            barrierType: 'orbit',
            orbitEntering: true,  // entering phase before orbiting begins
            orbitAngle: angle,
            orbitRadius: radius,
            orbitSpeed: orbitSpeed,
            orbitCenterX: centerX,
            orbitCenterY: 160,
            breathPhase: i * 0.3
          };
          enemies.push(EnemyPool.get(enemy));
          barrierEnemies.push(enemy);
        }
      } else if (barrierType === 'horizontalLine') {
        // Horizontal line that moves side to side
        var lineWidth = (count - 1) * 70;
        var startX = centerX - lineWidth / 2;
        for (var i = 0; i < count; i++) {
          var enemy = {
            x: startX + i * 70 - width / 2,
            y: -height, // Enter from top
            targetY: barrierY,
            width: width,
            height: height,
            baseWidth: width,
            baseHeight: height,
            speed: 2.5,
            type: enemyType,
            formation: false,
            barrier: true,
            barrierType: 'horizontalLine',
            lineIndex: i,
            lineDirection: 1,
            lineSpeed: 1.5,
            breathPhase: i * 0.2
          };
          enemies.push(EnemyPool.get(enemy));
          barrierEnemies.push(enemy);
        }
      } else if (barrierType === 'arrow') {
        // Arrow/V formation entering from top
        var spacing = 55;
        var half = Math.floor(count / 2);
        for (var i = 0; i < count; i++) {
          var xOffset, yOffset;
          if (i === 0) {
            xOffset = 0; yOffset = 0; // Tip
          } else if (i <= half) {
            xOffset = -spacing * i;
            yOffset = -spacing * i * 0.6;
          } else {
            xOffset = spacing * (i - half);
            yOffset = -spacing * (i - half) * 0.6;
          }
          var enemy = {
            x: centerX + xOffset - width / 2,
            y: -height - Math.abs(yOffset), // Stagger entry
            targetY: barrierY + yOffset,
            width: width,
            height: height,
            baseWidth: width,
            baseHeight: height,
            speed: 2.0,
            type: enemyType,
            formation: false,
            barrier: true,
            barrierType: 'arrow',
            arrowOffset: xOffset,
            breathPhase: i * 0.25
          };
          enemies.push(EnemyPool.get(enemy));
          barrierEnemies.push(enemy);
        }
      } else if (barrierType === 'dualLines') {
        // Two horizontal lines
        var lineCount = Math.floor(count / 2);
        var lineWidth = (lineCount - 1) * 70;
        var startX = centerX - lineWidth / 2;
        for (var line = 0; line < 2; line++) {
          var lineY = barrierY - 40 + line * 80;
          for (var i = 0; i < lineCount; i++) {
            if (enemies.filter(function (e) { return e.barrier; }).length >= count) break;
            var enemy = {
              x: startX + i * 70 - width / 2,
              y: -height - line * 50,
              targetY: lineY,
              width: width,
              height: height,
              baseWidth: width,
              baseHeight: height,
              speed: 2.5,
              type: enemyType,
              formation: false,
              barrier: true,
              barrierType: 'horizontalLine',
              lineIndex: i,
              lineDirection: line === 0 ? 1 : -1,
              lineSpeed: 1.2,
              breathPhase: (line * lineCount + i) * 0.15
            };
            enemies.push(EnemyPool.get(enemy));
            barrierEnemies.push(enemy);
          }
        }
      }
    }

    // Update barrier enemy positions
    function updateBarriers() {
      enemies.forEach(function (enemy) {
        if (!enemy.barrier) return;

        if (enemy.barrierType === 'orbit') {
          // Entry phase: drop from above screen to orbit start position
          if (enemy.orbitEntering) {
            if (enemy.y < enemy.targetY) {
              enemy.y += enemy.speed;
            } else {
              enemy.y = enemy.targetY;
              enemy.orbitEntering = false;
            }
          } else {
            // Orbit around formation center
            enemy.orbitAngle += enemy.orbitSpeed;
            enemy.x = enemy.orbitCenterX + Math.cos(enemy.orbitAngle) * enemy.orbitRadius - enemy.width / 2;
            enemy.y = enemy.orbitCenterY + Math.sin(enemy.orbitAngle) * enemy.orbitRadius * 0.6 - enemy.height / 2;
          }
        } else if (enemy.barrierType === 'horizontalLine') {
          // Move down to target then oscillate side to side
          if (enemy.y < enemy.targetY) {
            enemy.y += enemy.speed;
          } else {
            enemy.y = enemy.targetY;
            enemy.x += enemy.lineDirection * enemy.lineSpeed;
            // Bounce off screen edges
            if (enemy.x < 30 || enemy.x > canvas.width - enemy.width - 30) {
              enemy.lineDirection *= -1;
            }
          }
        } else if (enemy.barrierType === 'arrow') {
          // Move down to target position
          if (enemy.y < enemy.targetY) {
            enemy.y += enemy.speed;
          }
        }

        // Keep active (non-entering) barriers in upper half of screen
        if (!enemy.orbitEntering && enemy.y > canvas.height * 0.5) {
          enemy.y = canvas.height * 0.5;
        }
      });
    }

    /**
     * Polls whether all formation enemies have been destroyed. When the wave
     * is cleared, either starts the next wave within the level (after 3 s) or
     * calls `advanceLevel()` to move to the next level (after 2 s).
     */
    function checkWaveCompletion() {
      if (!waveInProgress) return;

      // Count remaining formation enemies
      var formationCount = enemies.filter(function (e) { return e.formation; }).length;

      if (formationCount === 0) {
        waveInProgress = false;
        waveCooldown = true;
        lastWaveEndTime = Date.now();

        var levelData = LEVEL_WAVES[level];
        if (currentWave < levelData.waves.length) {
          // Start next wave after delay
          setTimeout(function () {
            if (!gameOver && !bossActive) {
              startWave(currentWave + 1);
            }
          }, 3000);
        } else {
          // Level complete - advance to next level or boss
          setTimeout(function () {
            if (!gameOver && !bossActive) {
              advanceLevel();
            }
          }, 2000);
        }
      }
    }

    /**
     * Progresses the game to the next level or triggers a boss encounter.
     * Boss checks happen at level/score thresholds; phase caps prevent
     * skipping to a phase whose boss hasn't been defeated yet. Resets per-level
     * power-up tracking and starts the first wave of the new level.
     */
    function advanceLevel() {
      // Check for boss triggers
      if (!redPhase && level >= 4 && score >= CONFIG.boss1ScoreThreshold && !boss1Defeated) {
        currentBoss = 1;
        spawnBoss();
        return;
      }

      if (redPhase && !purplePhase && level >= 8 && score >= CONFIG.boss2ScoreThreshold && !boss2Defeated) {
        currentBoss = 2;
        spawnBoss();
        return;
      }

      if (purplePhase && level >= 12 && score >= CONFIG.boss3ScoreThreshold && !boss3Defeated) {
        currentBoss = 3;
        spawnBoss();
        return;
      }

      // Advance to next level
      var nextLevel = level + 1;

      // Handle level caps
      if (!redPhase && nextLevel > 4) {
        // Wait for boss 1
        return;
      }
      if (redPhase && !purplePhase && nextLevel > 8) {
        // Wait for boss 2
        return;
      }
      if (purplePhase && nextLevel > 12) {
        // Wait for boss 3
        return;
      }

      level = nextLevel;
      currentWave = 0;
      powerupsSpawnedThisLevel = { health: false, doubleLaser: false, shield: false };
      lastPowerupSpawnTime = 0; // Reset power-up cooldown for new level
      updateUI();
      showAnnouncement("levelDisplay", "Level " + level, 2000);

      // Start first wave of new level
      setTimeout(function () {
        if (!gameOver && !bossActive) {
          startWave(1);
        }
      }, 2500);
    }

    // Legacy formation functions (kept for boss fight variety)
    // Note: spawnSpiralFormation, spawnPincerFormation, spawnSineWaveFormation
    // are defined here but currently unused in the live wave system.
    // They are available for future boss-fight scripted sequences.

    /** Spawns 6 enemies at staggered intervals, each entering at the top center
     *  and then orbiting in a circular formation around y=150. */
    function spawnSpiralFormation() {
      var enemyType = getEnemyType();
      var count = 6;
      var centerX = canvas.width / 2;
      var targetY = 150;

      for (var i = 0; i < count; i++) {
        (function (index) {
          setTimeout(function () {
            var angle = (index / count) * Math.PI * 2;

            var enemy = {
              x: centerX,
              y: -50 - (index * 30),
              width: 50,
              height: 50,
              baseWidth: 50,
              baseHeight: 50,
              speed: 2,
              type: enemyType,
              formation: true,
              formationType: 'spiral',
              targetY: targetY,
              reachedTarget: false,
              spiralAngle: angle,
              spiralBaseRadius: 80,
              spiralCenterX: centerX,
              spiralCenterY: targetY,
              breathPhase: index * 0.3
            };
            enemies.push(enemy);
          }, index * 150);
        })(i);
      }
    }

    /**
     * Spawns a 3+3 pincer: three enemies enter from the left and three from the
     * right, sliding to fixed x targets then bouncing rhythmically in time with
     * the beat.
     */
    function spawnPincerFormation() {
      var enemyType = getEnemyType();
      var count = 3;
      var targetY = 120;

      for (var i = 0; i < count; i++) {
        (function (index) {
          setTimeout(function () {
            var enemy = {
              x: -50,
              y: targetY + index * 70,
              width: 50,
              height: 50,
              baseWidth: 50,
              baseHeight: 50,
              speed: 0,
              type: enemyType,
              formation: true,
              formationType: 'pincer',
              pincer: true,
              pincerSide: 'left',
              pincerSpeed: 3,
              pincerTargetX: 150,
              pincerBaseX: 150,
              reachedTarget: false,
              breathPhase: index * 0.4
            };
            enemies.push(enemy);
          }, index * 200);
        })(i);
      }

      for (var i = 0; i < count; i++) {
        (function (index) {
          setTimeout(function () {
            var enemy = {
              x: canvas.width,
              y: targetY + index * 70,
              width: 50,
              height: 50,
              baseWidth: 50,
              baseHeight: 50,
              speed: 0,
              type: enemyType,
              formation: true,
              formationType: 'pincer',
              pincer: true,
              pincerSide: 'right',
              pincerSpeed: 3,
              pincerTargetX: canvas.width - 200,
              pincerBaseX: canvas.width - 200,
              reachedTarget: false,
              breathPhase: index * 0.4
            };
            enemies.push(enemy);
          }, index * 200);
        })(i);
      }
    }

    /**
     * Spawns 8 enemies evenly spread across the screen width that descend to
     * y=100, then undulate horizontally in a sine-wave pattern synced to the
     * background music BPM.
     */
    function spawnSineWaveFormation() {
      var enemyType = getEnemyType();
      var count = 8;
      var targetY = 100;

      for (var i = 0; i < count; i++) {
        (function (index) {
          setTimeout(function () {
            var enemy = {
              x: 50 + index * ((canvas.width - 100) / count),
              y: -50,
              width: 50,
              height: 50,
              baseWidth: 50,
              baseHeight: 50,
              speed: 2,
              type: enemyType,
              formation: true,
              formationType: 'sineWave',
              sineWave: true,
              targetY: targetY,
              reachedTarget: false,
              sinePhase: index * 0.8,
              sineAmplitude: 60,
              baseX: 50 + index * ((canvas.width - 100) / count),
              baseY: targetY,
              breathPhase: index * 0.2
            };
            enemies.push(enemy);
          }, index * 100);
        })(i);
      }
    }

    // ============================================
    // PRE-RENDERING OPTIMIZATION (Phase 1)
    // ============================================
    // To reduce CPU load on mobile, we pre-draw complex vector shapes (ripples, powerups)
    // into small off-screen canvases. This allows us to use fast `ctx.drawImage` calls
    // in the main loop instead of expensive `ctx.arc` and `ctx.stroke` operations.
    var preRenderedRipples = {};
    var preRenderedPowerups = {};

    /**
     * Generates all static visual assets at startup.
     * 1. Creates 32-frame animation sheets for enemy/boss ripples (regular & shielded).
     * 2. Draws static icons for powerups (Health, Laser, Shield) at high res.
     */
    function initPreRenderedAssets() {
      // 1. RIPPLES ---------------------------
      // Generate animation frames for ripples to preserve line width scaling
      var rippleColors = [
        { key: 'red', color: '#FF5050' },
        { key: 'green', color: '#64FF64' },
        { key: 'blue', color: '#64C8FF' },
        { key: 'orange', color: '#FFC864' },
        { key: 'purple', color: '#C864FF' },
        { key: 'shield_outer', color: '#FFD700' }, // Standard shield
        { key: 'shield_inner', color: '#FFFF64' }  // Inner shield
      ];

      // Configuration for different ripple sizes/styles
      var rippleStyles = [
        { name: 'regular', maxRadius: 55, lineWidth: 2 }, // Enemies
        { name: 'boss', maxRadius: 130, lineWidth: 3 }    // Bosses
      ];

      var frames = 32; // Smoothness

      rippleColors.forEach(function (rc) {
        rippleStyles.forEach(function (style) {
          var storageKey = rc.key + '_' + style.name;
          preRenderedRipples[storageKey] = [];

          var size = (style.maxRadius * 2) + (style.lineWidth * 2) + 4; // Padding
          var center = size / 2;

          for (var i = 0; i < frames; i++) {
            var progress = i / (frames - 1);
            var radius = progress * style.maxRadius;
            if (radius < 0.5) radius = 0.5;

            var c = document.createElement('canvas');
            c.width = size;
            c.height = size;
            var ctx2 = c.getContext('2d');

            // If shield, use specific line widths from config if present?
            // The original code uses LW 5 for shield.
            var lw = style.lineWidth;
            if (rc.key === 'shield_outer') lw = (style.name === 'boss') ? 5 : 5; // Always thick?
            if (rc.key === 'shield_inner') lw = 3;

            ctx2.beginPath();
            ctx2.arc(center, center, radius, 0, Math.PI * 2);
            ctx2.strokeStyle = rc.color;
            ctx2.lineWidth = lw;
            ctx2.stroke();

            preRenderedRipples[storageKey].push(c);
          }
        });
      });

      // 2. POWERUPS --------------------------
      // Pre-render the static shapes (Diamond, Hexagon, Triangle) + Icons
      var powerupTypes = ['health', 'laser', 'shield'];
      powerupTypes.forEach(function (type) {
        var size = 64; // Powerups are usually ~30-40px, give room for glow
        var c = document.createElement('canvas');
        c.width = size;
        c.height = size;
        var ctx2 = c.getContext('2d');
        var cx = size / 2;
        var cy = size / 2;

        if (type === 'health') {
          // Red Diamond - restore health
          ctx2.fillStyle = "#FF3333";
          ctx2.strokeStyle = "#FF0000";
          ctx2.lineWidth = 2;
          ctx2.beginPath();
          ctx2.moveTo(cx, cy - 20);
          ctx2.lineTo(cx + 20, cy);
          ctx2.lineTo(cx, cy + 20);
          ctx2.lineTo(cx - 20, cy);
          ctx2.closePath();
          ctx2.fill();
          ctx2.stroke();
          // Plus symbol
          ctx2.fillStyle = "#FFFFFF";
          ctx2.fillRect(cx - 3, cy - 10, 6, 20);
          ctx2.fillRect(cx - 10, cy - 3, 20, 6);
        } else if (type === 'laser') {
          // Purple hexagon - double laser
          var r = 20;
          ctx2.fillStyle = "#9933FF";
          ctx2.beginPath();
          for (var i = 0; i < 6; i++) {
            var angle = (Math.PI / 3) * i - Math.PI / 2;
            var px = cx + r * Math.cos(angle);
            var py = cy + r * Math.sin(angle);
            if (i === 0) ctx2.moveTo(px, py);
            else ctx2.lineTo(px, py);
          }
          ctx2.closePath();
          ctx2.fill();
          ctx2.strokeStyle = "#6600CC";
          ctx2.lineWidth = 3;
          ctx2.stroke();
          // Double bar symbol
          ctx2.fillStyle = "#FFFFFF";
          ctx2.fillRect(cx - 8, cy - 8, 4, 16);
          ctx2.fillRect(cx + 4, cy - 8, 4, 16);
        } else if (type === 'shield') {
          // Aqua triangle - shield
          ctx2.fillStyle = "#00FFFF";
          ctx2.strokeStyle = "#00CCCC";
          ctx2.lineWidth = 2;
          ctx2.beginPath();
          ctx2.moveTo(cx, cy - 20);
          ctx2.lineTo(cx + 20, cy + 15);
          ctx2.lineTo(cx - 20, cy + 15);
          ctx2.closePath();
          ctx2.fill();
          ctx2.stroke();
          // Shield symbol (small circle)
          ctx2.beginPath();
          ctx2.arc(cx, cy + 5, 8, 0, Math.PI * 2);
          ctx2.strokeStyle = "#FFFFFF";
          ctx2.lineWidth = 2;
          ctx2.stroke();
        }

        preRenderedPowerups[type] = c;
      });
    }

    // Initialize immediately
    initPreRenderedAssets();
    window.addEventListener('resize', initPreRenderedAssets); // Re-init on resize just in case? No, canvas size unrelated to screen size.
    // Actually, no need to re-init on resize.

    /**
     * (enemy2 variants only) and a colour-coded ripple ring that expands at
     * 123 BPM. Shielded enemies show a brighter, wider gold ripple with an
     * additional inner ring. The ripple colour reflects the enemy's type/phase.
     * @param {Object} enemy - Enemy object from the `enemies` array.
     */
    function drawEnemy(enemy) {
      if (!enemy) return;
      var img;
      switch (enemy.type) {
        case 'enemy1': img = enemyImg1; break;
        case 'enemy2': img = enemyImg2; break;
        case 'enemy3': img = enemyImg3; break;
        case 'enemy4': img = enemyImg4; break;
        case 'enemy1_red': img = enemyImg1Red; break;
        case 'enemy2_red': img = enemyImg2Red; break;
        case 'enemy3_red': img = enemyImg3Red; break;
        case 'enemy4_red': img = enemyImg4Red; break;
        case 'enemy1_purple': img = enemyImg1Purple; break;
        case 'enemy2_purple': img = enemyImg2Purple; break;
        case 'enemy3_purple': img = enemyImg3Purple; break;
        case 'enemy4_purple': img = enemyImg4Purple; break;
        default: img = enemyImg1;
      }

      var time = Date.now();
      var cx = enemy.x + enemy.width / 2;
      var cy = enemy.y + enemy.height / 2;

      // Breathing effect - ONLY for enemy2 and enemy2_red
      var drawWidth = enemy.baseWidth || enemy.width;
      var drawHeight = enemy.baseHeight || enemy.height;

      if (enemy.type === 'enemy2' || enemy.type === 'enemy2_red' || enemy.type === 'enemy2_purple') {
        var breathInterval = BPM_INTERVAL * 2;
        var breathPhaseOffset = (enemy.breathPhase || 0) * breathInterval;
        var breathProgress = ((time + breathPhaseOffset) % breathInterval) / breathInterval;
        var breathScale = 1 + Math.sin(breathProgress * Math.PI) * 0.18;
        drawWidth = drawWidth * breathScale;
        drawHeight = drawHeight * breathScale;
      }

      var drawX = cx - drawWidth / 2;
      var drawY = cy - drawHeight / 2;

      // Check if enemy is shielded
      var isShielded = enemy.shielded === true;

      // Draw ripple effect (PRE-RENDERED)
      // Uses the pre-generated animation frames from `initPreRenderedAssets`
      // based on the current beat phase.
      var beatPhase = (time % BPM_INTERVAL) / BPM_INTERVAL;
      var rippleAlpha = 1 - beatPhase;

      if (rippleAlpha > 0.05) {
        // Identify Style (regular vs boss)
        // Bosses are usually > 100px width
        var style = (enemy.width > 80) ? 'boss' : 'regular';
        var key = 'green'; // Default

        if (isShielded) {
          key = 'shield_outer';
        } else if (enemy.type.indexOf('_red') !== -1) {
          key = 'red';
        } else if (enemy.type === 'enemy1') {
          key = 'green';
        } else if (enemy.type === 'enemy2') {
          key = 'blue';
        } else if (enemy.type === 'enemy3') {
          key = 'orange';
        } else {
          key = 'purple';
        }

        var storageKey = key + '_' + style;
        var frames = preRenderedRipples[storageKey];
        if (frames && frames.length > 0) {
          // Map beatPhase (0..1) to frame index (0..frames.length-1)
          var frameIndex = Math.floor(beatPhase * (frames.length - 1));
          var rippleCanvas = frames[frameIndex];

          if (rippleCanvas) {
            // Center the ripple canvas
            // Note: pre-rendered canvases are fixed size (114px regular, 264px boss)
            // We draw them unscaled to preserve line width?
            // No, we matched the maxRadius to the enemy type roughly.
            // Regular: maxRadius 55 -> Dia 110. Enemy width 50.
            // Wait, original: `rippleRadius = beatPhase * enemy.width`.
            // Max ripple dia = 2 * enemy.width = 100.
            // Our canvas is 110. Close enough.
            // Boss: width 150. Max ripple dia = 300.
            // Our canvas is 260. Close enough.

            // Draw centered
            ctx.globalAlpha = (key === 'shield_outer') ? (rippleAlpha * 0.7) : (rippleAlpha * 0.4);
            ctx.drawImage(rippleCanvas, cx - rippleCanvas.width / 2, cy - rippleCanvas.height / 2);
            ctx.globalAlpha = 1.0;
          }
        }

        // Inner shield ripple
        if (isShielded) {
          var innerKey = 'shield_inner_' + style;
          var innerFrames = preRenderedRipples[innerKey];
          if (innerFrames) {
            // Inner ripple is 60% size in original code.
            // But here we pre-rendered it at full size?
            // Check initPreRenderedAssets... logic was:
            // `rippleTypes` has separate entries for `shield_outer` and `shield_inner`.
            // They utilize the SAME loop, so they have the SAME maxRadius (55 or 130).
            // Original Code: `innerRadius = rippleRadius * 0.6`.
            // So our pre-rendered `shield_inner` is TOO BIG (100%)!
            // It should be drawn at 60% scale.
            // Scaling it changes LW.
            // Original Inner Shield LW = 3.
            // Our pre-rendered Inner Shield LW = 3.
            // If we scale it 0.6x -> LW 1.8.
            // That's acceptable for an inner ripple.

            // OR, we should have pre-rendered it smaller?
            // Too late, already injected.
            // I will scale it here. 
            var innerFrameIndex = Math.floor(beatPhase * (innerFrames.length - 1));
            var innerCanvas = innerFrames[innerFrameIndex];
            if (innerCanvas) {
              ctx.globalAlpha = rippleAlpha * 0.5;
              var scale = 0.6;
              var w = innerCanvas.width * scale;
              var h = innerCanvas.height * scale;
              ctx.drawImage(innerCanvas, cx - w / 2, cy - h / 2, w, h);
              ctx.globalAlpha = 1.0;
            }
          }
        }
      }

      // Draw enemy
      ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);

      // Draw health bar for boss (only big enemies?)
      // Original code checked `if (bossVisible)` implies it's the boss.
      // But `drawEnemy` is generic.
      // Wait, original `drawEnemy` did NOT draw health bar!
      // `updateBoss` logic drew the boss health bar!
      // `drawEnemy` is for minions.
      // `updateBoss` handles the Boss rendering separately?
      // Let's check `updateBoss` (lines 3085+).
      // `updateBoss` calls `ctx.drawImage` for the boss sprite.
      // It DOES NOT call `drawEnemy` for the boss itself!
      // It calls `drawEnemy` for *orbiters* and *minions*.
      // AND `updateBoss` logic has its OWN ripple drawing code (lines 3153+).

      // OH NO.
      // `drawEnemy` is ONLY for minions.
      // The Boss has DUPLICATE ripple drawing logic in `updateBoss`.
      // I need to refactor BOTH.

      // I just refactored `drawEnemy`. This handles minions (100+ entities).
      // I DO need to refactor `updateBoss` next.
    }

    // ============================================
    // BOSS SYSTEM
    // ============================================
    // Boss orbiting soldiers
    var bossOrbiters = [];
    var maxOrbiters = 5;
    var orbiterRespawnDelay = 3000; // 3 seconds to respawn
    var lastOrbiterDeathTime = 0;
    var orbitersInitialized = false;

    // Smart filler management
    var maxBossFillers = 6;
    var lastBossFillerBeat = 0;
    var bossFillerBeatInterval = 4; // Spawn every 4 beats

    /**
     * Activates a boss encounter matching `currentBoss` (1 = green, 2 = red,
     * 3 = purple). Clears all existing enemies and minions, plays the boss sting,
     * and creates the boss object with a shield that is always active at the start.
     */
    function spawnBoss() {
      bossActive = true;
      enemies = []; // Clear regular enemies
      bossMinions = []; // Clear any existing minions
      bossOrbiters = []; // Clear orbiters
      orbitersInitialized = false;
      showAnnouncement("levelDisplay", "BOSS!", 2000);
      startBossMusic();

      var isRedBoss = (currentBoss === 2);
      var isPurpleBoss = (currentBoss === 3);
      boss = {
        x: canvas.width / 2 - 75,
        y: -150,
        width: 150,
        height: 150,
        health: CONFIG.bossHealth,
        maxHealth: CONFIG.bossHealth,
        speed: CONFIG.bossSpeed,
        direction: 1,
        verticalDirection: 1, // For red/purple boss vertical movement
        entering: true,
        isRedBoss: isRedBoss,
        isPurpleBoss: isPurpleBoss,
        // Boss shield system
        shielded: true, // Start with shield
        shieldStartTime: Date.now(),
        shieldDuration: 5000, // 5 seconds on
        shieldCooldown: 5000, // 5 seconds off (only for red/purple boss)
        shieldCycling: isRedBoss || isPurpleBoss // Red and purple bosses cycle shields
      };
    }

    /**
     * One-time initialisation of the orbiting escort satellites once the boss
     * has finished its entrance animation. Orbiter count: 4 (green), 6 (red),
     * or 8 (purple) based on boss difficulty.
     */
    function initBossOrbiters() {
      if (orbitersInitialized) return;
      orbitersInitialized = true;

      var orbiterCount = boss.isPurpleBoss ? 8 : (boss.isRedBoss ? 6 : 4);
      maxOrbiters = orbiterCount;

      for (var i = 0; i < orbiterCount; i++) {
        spawnOrbiter(i, orbiterCount);
      }
    }

    /**
     * Creates one orbiter satellite at the given angular slot and pushes it
     * into `bossOrbiters`. Orbiters use the same enemy sprite as the current
     * boss phase (enemy1 / enemy1_red / enemy1_purple).
     * @param {number} index - Angular slot (0..total-1).
     * @param {number} total - Total number of orbiters in the ring.
     */
    function spawnOrbiter(index, total) {
      var angle = (index / total) * Math.PI * 2;
      var enemyType = boss.isPurpleBoss ? 'enemy1_purple' : (boss.isRedBoss ? 'enemy1_red' : 'enemy1');

      bossOrbiters.push({
        angle: angle,
        baseRadius: 120,
        width: 40,
        height: 40,
        baseWidth: 40,
        baseHeight: 40,
        type: enemyType,
        index: index,
        total: total,
        breathPhase: index * 0.2,
        alive: true
      });
    }

    /**
     * Each frame: rotates all living orbiters around the boss centre with a
     * BPM-pulsing radius, draws them with a ripple ring, handles bullet and
     * player collision, and respawns destroyed orbiters after a 3-second delay.
     * Returns true if a collision killed the player (signals game loop to stop).
     * @returns {boolean}
     */
    function updateBossOrbiters() {
      if (!boss || boss.entering) return;

      // Initialize orbiters once boss has entered
      if (!orbitersInitialized) {
        initBossOrbiters();
      }

      var time = Date.now();
      var bossCx = boss.x + boss.width / 2;
      var bossCy = boss.y + boss.height / 2;

      // BPM-synced orbit radius pulsing
      var beatPhase = (time % BPM_INTERVAL) / BPM_INTERVAL;
      var radiusPulse = 1 + Math.sin(beatPhase * Math.PI * 2) * 0.15;

      // Rotation speed synced to BPM (one full rotation every 8 beats)
      var rotationSpeed = (Math.PI * 2) / (BPM_INTERVAL * 8);
      var baseRotation = (time * rotationSpeed) % (Math.PI * 2);

      for (var i = bossOrbiters.length - 1; i >= 0; i--) {
        var orbiter = bossOrbiters[i];
        if (!orbiter.alive) continue;

        // Calculate position
        var currentAngle = baseRotation + orbiter.angle;
        var currentRadius = orbiter.baseRadius * radiusPulse;

        var orbiterX = bossCx + Math.cos(currentAngle) * currentRadius - orbiter.width / 2;
        var orbiterY = bossCy + Math.sin(currentAngle) * currentRadius - orbiter.height / 2;

        // Store position for collision detection
        orbiter.x = orbiterX;
        orbiter.y = orbiterY;

        // Draw orbiter (no breathing - only enemy2 types breathe)
        var drawWidth = orbiter.baseWidth;
        var drawHeight = orbiter.baseHeight;
        var drawX = orbiterX;
        var drawY = orbiterY;

        // Draw ripple
        var ripplePhase = (time % BPM_INTERVAL) / BPM_INTERVAL;
        var maxRipple = drawWidth * 0.8;
        var rippleRadius = ripplePhase * maxRipple;
        var rippleAlpha = 1 - ripplePhase;

        if (rippleAlpha > 0.05) {
          var colorKey = boss.isPurpleBoss ? 'purple' : (boss.isRedBoss ? 'red' : 'green');
          var frames = preRenderedRipples[colorKey + '_regular'];
          if (frames) {
            var frameIndex = Math.floor(ripplePhase * (frames.length - 1));
            var rCanvas = frames[frameIndex];
            if (rCanvas) {
              // Scale down to ~0.6 to match orbiter size (40px vs 55px radius)
              // Original: maxRipple = drawWidth * 0.8 = 32.
              // Regular maxRadius = 55. 32/55 approx 0.6.
              var w = rCanvas.width * 0.6;
              var h = rCanvas.height * 0.6;
              ctx.globalAlpha = rippleAlpha * 0.5;
              ctx.drawImage(rCanvas, drawX + drawWidth / 2 - w / 2, drawY + drawHeight / 2 - h / 2, w, h);
              ctx.globalAlpha = 1.0;
            }
          }
        }

        // Draw orbiter image
        var img = boss.isPurpleBoss ? enemyImg1Purple : (boss.isRedBoss ? enemyImg1Red : enemyImg1);
        ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);

        // Orbiter shooting (lower chance than boss)
        if (Math.random() < 0.008) {
          enemyBullets.push({
            x: Math.floor(orbiterX + orbiter.width / 2 - 2),
            y: Math.floor(orbiterY + orbiter.height),
            width: 5,
            height: 10,
            speed: CONFIG.enemyBulletSpeed
          });
        }

        // Check collision with player bullets
        for (var j = playerBullets.length - 1; j >= 0; j--) {
          var bullet = playerBullets[j];
          if (bullet.x < orbiter.x + orbiter.width &&
            bullet.x + bullet.width > orbiter.x &&
            bullet.y < orbiter.y + orbiter.height &&
            bullet.y + bullet.height > orbiter.y) {
            playerBullets.splice(j, 1);
            orbiter.alive = false;
            bossOrbiters.splice(i, 1);
            score += 15; // Slightly more than regular enemies
            updateUI();
            playSound('enemyDead');
            spawnExplosion(orbiter.x + orbiter.width / 2, orbiter.y + orbiter.height / 2);
            lastOrbiterDeathTime = time;
            break;
          }
        }

        // Check collision with player
        if (orbiter.alive &&
          player.x < orbiter.x + orbiter.width &&
          player.x + player.width > orbiter.x &&
          player.y < orbiter.y + orbiter.height &&
          player.y + player.height > orbiter.y) {
          orbiter.alive = false;
          bossOrbiters.splice(i, 1);
          playerTakeDamage(CONFIG.enemyCollisionDamage);
          lastOrbiterDeathTime = time;
          if (gameOver) return true;
        }
      }

      // Respawn orbiters after delay
      if (bossOrbiters.length < maxOrbiters && time - lastOrbiterDeathTime > orbiterRespawnDelay) {
        // Find missing index
        var existingIndices = bossOrbiters.map(function (o) { return o.index; });
        for (var i = 0; i < maxOrbiters; i++) {
          if (existingIndices.indexOf(i) === -1) {
            spawnOrbiter(i, maxOrbiters);
            lastOrbiterDeathTime = time; // Reset timer for next respawn
            break;
          }
        }
      }

      return false;
    }

    /**
     * Beat-synced filler enemy spawner active during boss fights. Spawns up to
     * `maxBossFillers` additional enemies (mix of side-entry and top-entry)
     * every 4 beats. The spawn chance scales inversely with the current filler
     * count so the field self-regulates to a comfortable density.
     */
    function spawnBossFiller() {
      var time = Date.now();

      // Count current fillers (non-formation, non-orbiter enemies)
      var currentFillers = enemies.filter(function (e) { return !e.formation; }).length;

      // Don't spawn if at cap
      if (currentFillers >= maxBossFillers) return;

      // Beat-synced spawning (every 4 beats)
      var currentBeat = Math.floor(time / BPM_INTERVAL);
      if (currentBeat - lastBossFillerBeat < bossFillerBeatInterval) return;

      // Dynamic spawn chance based on current count (fewer enemies = higher chance)
      var spawnChance = 0.5 * (1 - currentFillers / maxBossFillers);
      if (Math.random() > spawnChance) return;

      lastBossFillerBeat = currentBeat;

      // Spawn from sides to avoid boss orbit zone
      var fromSide = Math.random() < 0.5;
      var enemyType = boss.isPurpleBoss ?
        (Math.random() < 0.5 ? 'enemy2_purple' : 'enemy3_purple') :
        (boss.isRedBoss ?
          (Math.random() < 0.5 ? 'enemy2_red' : 'enemy3_red') :
          (Math.random() < 0.5 ? 'enemy2' : 'enemy3'));

      var width = (enemyType === 'enemy2_red' || enemyType === 'enemy2_purple') ? 29 : 50;
      var height = (enemyType === 'enemy2_red' || enemyType === 'enemy2_purple') ? 29 : 50;

      var enemy;
      if (fromSide) {
        // Side entry - upper half only, away from player
        var fromLeft = Math.random() < 0.5;
        enemy = {
          x: fromLeft ? -width : canvas.width,
          y: 100 + Math.random() * 150, // Upper half (100-250)
          width: width,
          height: height,
          baseWidth: width,
          baseHeight: height,
          speed: 0,
          horizontalSpeed: CONFIG.enemyBaseSpeed + 0.5,
          horizontalDirection: fromLeft ? 1 : -1,
          type: enemyType,
          formation: false,
          sideEntry: true,
          breathPhase: Math.random()
        };
      } else {
        // Top entry (edges only, away from boss)
        var spawnX = Math.random() < 0.5 ?
          Math.random() * 150 : // Left edge
          canvas.width - 150 - width + Math.random() * 150; // Right edge

        enemy = {
          x: spawnX,
          y: -height,
          width: width,
          height: height,
          baseWidth: width,
          baseHeight: height,
          speed: CONFIG.enemyBaseSpeed + 0.3,
          type: enemyType,
          formation: false,
          breathPhase: Math.random()
        };

        // Add movement behaviors
        if (CONFIG.zigzagEnemies.indexOf(enemyType) !== -1) {
          enemy.zigzag = true;
          enemy.zigzagDirection = Math.random() < 0.5 ? 1 : -1;
          enemy.zigzagSpeed = 2;
          enemy.zigzagTimer = 0;
          enemy.zigzagInterval = 30;
        }
        if (CONFIG.sideToSideEnemies.indexOf(enemyType) !== -1) {
          enemy.sideToSide = true;
          enemy.horizontalDirection = Math.random() < 0.5 ? 1 : -1;
          enemy.horizontalSpeed = 2;
        }
      }

      enemies.push(EnemyPool.get(enemy));
    }

    /**
     * Spawns a single side-scrolling minion that enters from a random edge and
     * travels across the screen. Minions are distinct from `bossOrbiters` and
     * `enemies`; they are tracked in the `bossMinions` array.
     */
    function createBossMinion() {
      // Spawn from left or right side randomly
      var fromLeft = Math.random() < 0.5;
      var targetY = 100 + Math.random() * 150; // Stay in upper half

      bossMinions.push({
        x: fromLeft ? -50 : canvas.width,
        y: targetY,
        width: 50,
        height: 50,
        speed: CONFIG.bossMinionSpeed,
        direction: fromLeft ? 1 : -1,
        isRedMinion: (currentBoss === 2),
        isPurpleMinion: (currentBoss === 3)
      });
    }

    /**
     * Per-frame update for all boss minions: draws, moves, checks off-screen
     * removal, handles bullet collisions (minion kills chip 1 HP off the boss
     * if the boss is unshielded), and checks player collision. New minions spawn
     * at the rate defined by `CONFIG.bossMinionSpawnChance`.
     * Returns true if a collision resulted in player death.
     * @returns {boolean}
     */
    function updateBossMinions() {
      for (var i = bossMinions.length - 1; i >= 0; i--) {
        var minion = bossMinions[i];

        // Draw minion (enemy2 for boss 1, enemy3_red for boss 2)
        var minionImg = minion.isPurpleMinion ? enemyImg3Purple : (minion.isRedMinion ? enemyImg3Red : enemyImg2);
        ctx.drawImage(minionImg, minion.x, minion.y, minion.width, minion.height);

        // Move horizontally
        minion.x += minion.speed * minion.direction;

        // Remove if off screen on opposite side
        if ((minion.direction > 0 && minion.x > canvas.width) ||
          (minion.direction < 0 && minion.x < -minion.width)) {
          bossMinions.splice(i, 1);
          continue;
        }

        // Check collision with player bullets
        for (var j = playerBullets.length - 1; j >= 0; j--) {
          if (isColliding(playerBullets[j], minion)) {
            playerBullets.splice(j, 1);
            bossMinions.splice(i, 1);
            score += 10;
            updateUI();
            playSound('enemyDead');
            spawnExplosion(minion.x + minion.width / 2, minion.y + minion.height / 2);
            break;
          }
        }
      }

      // Check collision with player (separate loop since array may have changed)
      for (var i = bossMinions.length - 1; i >= 0; i--) {
        if (isColliding(bossMinions[i], player)) {
          bossMinions.splice(i, 1);
          playerTakeDamage(CONFIG.enemyCollisionDamage);
          if (gameOver) return true; // Signal game over
        }
      }

      // Spawn new minions
      if (Math.random() < CONFIG.bossMinionSpawnChance) {
        createBossMinion();
      }

      return false; // Game continues
    }

    /**
     * Main boss update called every frame. Manages the shield cycle (on/off
     * timer; green boss never regains it), entrance animation, horizontal and
     * optional vertical drift, bullet firing, BPM-synced ripple rendering,
     * golden shield ripple overlay, and the health bar HUD element.
     */
    function updateBoss() {
      if (!boss) return;

      // Update boss shield
      var now = Date.now();
      var timeSinceShieldStart = now - boss.shieldStartTime;

      if (boss.shielded) {
        // Check if shield duration expired
        if (timeSinceShieldStart >= boss.shieldDuration) {
          boss.shielded = false;
          boss.shieldStartTime = now; // Reset timer for cooldown
        }
      } else if (boss.shieldCycling) {
        // Red boss: check if cooldown expired to regenerate shield
        if (timeSinceShieldStart >= boss.shieldCooldown) {
          boss.shielded = true;
          boss.shieldStartTime = now;
        }
      }
      // Green boss: once shield is down, it stays down (shieldCycling = false)

      // Update boss blink effect
      updateBossBlink();

      // Boss entrance animation
      if (boss.entering) {
        boss.y += 3;
        if (boss.y >= 245) {
          boss.y = 245;
          boss.entering = false;
        }
      } else {
        // Move side to side
        boss.x += boss.speed * boss.direction;
        if (boss.x <= 0 || boss.x >= canvas.width - boss.width) {
          boss.direction *= -1;
        }

        // Red/purple boss also moves north/south
        if (boss.isRedBoss || boss.isPurpleBoss) {
          boss.y += boss.speed * 0.6 * boss.verticalDirection;
          if (boss.y <= 205) {
            boss.verticalDirection = 1;
          } else if (boss.y >= 285) {
            boss.verticalDirection = -1;
          }
        }

        // Boss shooting
        if (Math.random() < CONFIG.bossShootChance) {
          var bossBulletSpeed = CONFIG.enemyBulletSpeed + 1;
          if (boss.isRedBoss) {
            bossBulletSpeed = CONFIG.enemyBulletSpeed + 3; // Faster for red boss
          } else if (boss.isPurpleBoss) {
            bossBulletSpeed = CONFIG.enemyBulletSpeed + 4; // Fastest for purple boss
          }
          enemyBullets.push({
            x: Math.floor(boss.x + boss.width / 2 - 4),
            y: Math.floor(boss.y + boss.height),
            width: 8,
            height: 15,
            speed: bossBulletSpeed,
            isBossBullet: true
          });
        }
      }

      // Draw boss ripple effect at 123 BPM (PRE-RENDERED)
      var bossCx = boss.x + boss.width / 2;
      var bossCy = boss.y + boss.height / 2;
      var time = Date.now();
      var beatPhase = (time % BPM_INTERVAL) / BPM_INTERVAL;
      var rippleAlpha = 1 - beatPhase;

      var key = boss.isPurpleBoss ? 'purple' : (boss.isRedBoss ? 'red' : 'green');
      var frames = preRenderedRipples[key + '_boss'];

      if (rippleAlpha > 0.05 && frames) {
        var frameIndex = Math.floor(beatPhase * (frames.length - 1));
        var rCanvas = frames[frameIndex];
        if (rCanvas) {
          ctx.globalAlpha = rippleAlpha * 0.5;
          ctx.drawImage(rCanvas, bossCx - rCanvas.width / 2, bossCy - rCanvas.height / 2);
          ctx.globalAlpha = 1.0;
        }
      }

      // Second boss ripple
      var beatPhase2 = ((time + BPM_INTERVAL / 2) % BPM_INTERVAL) / BPM_INTERVAL;
      var rippleAlpha2 = 1 - beatPhase2;
      if (rippleAlpha2 > 0.05 && frames) {
        var frameIndex2 = Math.floor(beatPhase2 * (frames.length - 1));
        var rCanvas2 = frames[frameIndex2];
        if (rCanvas2) {
          ctx.globalAlpha = rippleAlpha2 * 0.3;
          ctx.drawImage(rCanvas2, bossCx - rCanvas2.width / 2, bossCy - rCanvas2.height / 2);
          ctx.globalAlpha = 1.0;
        }
      }

      // Draw golden shield ripple when boss is shielded
      if (boss.shielded && rippleAlpha > 0.05) {
        var shieldFrames = preRenderedRipples['shield_outer_boss'];
        if (shieldFrames) {
          var frameIndex = Math.floor(beatPhase * (shieldFrames.length - 1));
          var sCanvas = shieldFrames[frameIndex];
          if (sCanvas) {
            ctx.globalAlpha = rippleAlpha * 0.7;
            // Scale up 1.2x to match original huge shield
            var sw = sCanvas.width * 1.2;
            var sh = sCanvas.height * 1.2;
            ctx.drawImage(sCanvas, bossCx - sw / 2, bossCy - sh / 2, sw, sh);
            ctx.globalAlpha = 1.0;
          }
        }

        // Inner shield ripple
        var innerShieldFrames = preRenderedRipples['shield_inner_boss'];
        if (innerShieldFrames) {
          var frameIndex = Math.floor(beatPhase * (innerShieldFrames.length - 1));
          var iCanvas = innerShieldFrames[frameIndex];
          if (iCanvas) {
            ctx.globalAlpha = rippleAlpha * 0.5;
            // Scale 0.6x (should match original logic)
            // But wait, if pre-rendered is "boss" size, maybe 0.8?
            // Original: innerRadius = rippleRadius * 0.6.
            // So 0.6 scale is correct relative to the outer ripple size?
            // No, logic was relative to *same* maxRipple.
            // So yes, 0.6 scale if we use 1.0 sized canvas.
            // But if `shield_inner_boss` was pre-rendered with maxRadius 130...
            // We draw it at 0.6 scale.
            var iw = iCanvas.width * 0.6;
            var ih = iCanvas.height * 0.6;
            ctx.drawImage(iCanvas, bossCx - iw / 2, bossCy - ih / 2, iw, ih);
            ctx.globalAlpha = 1.0;
          }
        }
      }

      // Draw boss (only if visible during blink)
      if (bossVisible) {
        var bossImage = boss.isPurpleBoss ? bossImgPurple : (boss.isRedBoss ? bossImgRed : bossImg);
        ctx.drawImage(bossImage, boss.x, boss.y, boss.width, boss.height);
      }

      // Draw health bar (always visible)
      var healthPercent = boss.health / boss.maxHealth;
      ctx.fillStyle = "#333";
      ctx.fillRect(boss.x, boss.y - 15, boss.width, 10);
      ctx.fillStyle = healthPercent > 0.3 ? "#00FF00" : "#FF0000";
      ctx.fillRect(boss.x, boss.y - 15, boss.width * healthPercent, 10);
    }

    /**
     * Registers one player-bullet hit on the boss. Shielded hits deal no damage
     * (mobile version; desktop version deals 0.5 chip damage). Unshielded hits
     * deal 1 HP. At 0 HP, triggers screen shake, clears all boss entities,
     * awards a score bonus, and advances the game phase:
     *   Boss 1 â†’ red phase (level 5, score set to 800)
     *   Boss 2 â†’ purple phase (level 9, score set to 2000)
     *   Boss 3 â†’ victory screen
     */
    function damageBoss() {
      if (!boss) return;

      // Check if boss is shielded
      if (boss.shielded) {
        return; // No damage when shielded
      }

      boss.health--;

      // Start boss blinking effect
      bossBlinking = true;
      bossBlinkTimer = 10; // Short blink (10 frames)

      if (boss.health <= 0) {
        // Boss defeated - trigger screen shake and explosion!
        triggerScreenShake(15, 800); // Strong shake for boss death
        spawnExplosion(boss.x + boss.width / 2, boss.y + boss.height / 2, true); // Boss explosion

        bossActive = false;
        boss = null;
        bossMinions = [];
        bossOrbiters = [];
        orbitersInitialized = false;
        enemies = [];
        stopBossMusic();

        if (currentBoss === 1) {
          // Boss 1 defeated - show victory, then start red phase
          boss1Defeated = true;

          // Track boss 1 defeat
          fireEvent('boss_defeated', {
            'ab_music_group': userABGroup,
            'platform': 'mobile',
            'boss_id': 1,
            'score': score,
            'music_variant': localStorage.getItem('nonex_music') !== 'off' ? 'on' : 'off'
          });

          // Calculate bonus and set score to 800 (only if player is under threshold)
          var bonus = 800 - score;
          if (bonus > 0) {
            score = 800;
          }
          redPhaseStartScore = score;
          updateUI();

          // Show victory message
          showAnnouncement("levelDisplay", "Victory!", 2500);

          // Show bonus in yellow (only if player earned one)
          if (bonus > 0) {
            setTimeout(function () {
              showAnnouncement("bonusDisplay", "Bonus +" + bonus + "!", 2000);
            }, 500);
          }

          // After delay, start level 5 with wave reset
          setTimeout(function () {
            redPhase = true;
            level = 5;
            currentWave = 0;
            waveInProgress = false;
            waveCooldown = false;
            powerupsSpawnedThisLevel = { health: false, doubleLaser: false, shield: false };
            lastPowerupSpawnTime = 0;
            updateUI();
            showAnnouncement("levelDisplay", "Level 5", 2000);
          }, 3000);
        } else if (currentBoss === 2) {
          // Boss 2 defeated - start purple phase (levels 9-12)
          boss2Defeated = true;

          // Track boss 2 defeat
          fireEvent('boss_defeated', {
            'ab_music_group': userABGroup,
            'platform': 'mobile',
            'boss_id': 2,
            'score': score,
            'music_variant': localStorage.getItem('nonex_music') !== 'off' ? 'on' : 'off'
          });

          // Calculate bonus and set score to 2000 (only if player is under threshold)
          var bonus = 2000 - score;
          if (bonus > 0) {
            score = 2000;
          }
          purplePhaseStartScore = score;
          updateUI();

          showAnnouncement("levelDisplay", "Victory!", 2500);

          // Show bonus in yellow (only if player earned one)
          if (bonus > 0) {
            setTimeout(function () {
              showAnnouncement("bonusDisplay", "Bonus +" + bonus + "!", 2000);
            }, 500);
          }

          setTimeout(function () {
            purplePhase = true;
            level = 9;
            currentWave = 0;
            waveInProgress = false;
            waveCooldown = false;
            powerupsSpawnedThisLevel = { health: false, doubleLaser: false, shield: false };
            lastPowerupSpawnTime = 0;
            updateUI();
            showAnnouncement("levelDisplay", "Level 9", 2000);
          }, 3000);
        } else if (currentBoss === 3) {
          // Boss 3 defeated - game complete!
          boss3Defeated = true;
          bossDefeated = true;

          // Track boss 3 defeat
          fireEvent('boss_defeated', {
            'ab_music_group': userABGroup,
            'platform': 'mobile',
            'boss_id': 3,
            'score': score,
            'music_variant': localStorage.getItem('nonex_music') !== 'off' ? 'on' : 'off'
          });
          score += 100;
          updateUI();
          showAnnouncement("levelDisplay", "Victory! You Win!", 3000);
          setTimeout(function () {
            showVictory();
          }, 3500);
        }
      }
    }

    /**
     * Handles the boss hit-flash animation. Decrements `bossBlinkTimer` each
     * frame and toggles `bossVisible` to create a rapid strobe effect.
     */
    function updateBossBlink() {
      if (bossBlinking) {
        bossBlinkTimer--;
        bossVisible = Math.floor(bossBlinkTimer / 2) % 2 === 0;
        if (bossBlinkTimer <= 0) {
          bossBlinking = false;
          bossVisible = true;
        }
      }
    }

    /**
     * Ends the game in a victory state. Clears all game objects, checks for a
     * top-10 score, builds the victory HTML (score, optional rank badge, email
     * subscription form, return button), and displays the #victory overlay.
     */
    function showVictory() {
      gameOver = true;
      stopBossMusic();
      // Keep background music playing - don't stop it

      // Clear all game objects from screen
      enemies = [];
      playerBullets = [];
      enemyBullets = [];
      powerups = [];
      bossMinions = [];
      boss = null;

      // Track player won (defeated all 3 bosses)
      fireEvent('player_won', {
        'ab_music_group': userABGroup,
        'platform': 'mobile',
        'final_score': score,
        'music_variant': localStorage.getItem('nonex_music') !== 'off' ? 'on' : 'off'
      });

      // Clear the canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Check if top 10 score and save
      var madeTopTen = isTopTenScore(score);
      var rank = getScoreRank(score);
      if (madeTopTen) {
        addHighScore(score);
      }

      // Build victory display
      var victoryEl = document.getElementById("victory");
      var html = "<div style='font-size: 22px; margin-bottom: 15px;'>Thank you for playing NON-X!</div>";
      html += "<div style='font-size: 20px; margin-bottom: 25px;'>Your Score: <strong>" + score + "</strong>";
      if (madeTopTen) {
        html += " <span style='color: #FFD700;'>- TOP 10! Rank #" + rank + "</span>";
      }
      html += "</div>";

      // Leaderboard submission
      html += "<div id='leaderboardSubmit' style='margin-bottom: 20px;'>";
      html += "<div style='font-size: 16px; margin-bottom: 8px;'>Submit to Global Leaderboard:</div>";
      html += "<input type='text' id='igInput' placeholder='Instagram handle (optional)' style='padding: 8px; font-size: 14px; width: 200px; border-radius: 4px; border: none; margin-bottom: 8px;'><br>";
      html += "<button onclick='submitToLeaderboard()' style='padding: 8px 16px; font-size: 14px; border-radius: 4px; border: none; background: #00FFFF; color: #000; cursor: pointer; font-weight: bold;'>Submit Score</button>";
      html += "</div>";

      // Leaderboard display
      html += "<div id='leaderboardDisplay' style='margin-bottom: 25px;'></div>";

      // Buttons row (mute + play again + leave game)
      html += "<div style='margin-bottom: 20px; white-space: nowrap;'>";
      html += "<button id='victoryMuteBtn' onclick='toggleMusic()' style='padding: 12px 20px; font-size: 16px; border-radius: 4px; border: none; background: #00FFFF; color: #000; cursor: pointer; margin-right: 10px; font-weight: bold;'>" + (bgMusic.paused ? 'ðŸ”‡' : 'ðŸ”Š') + "</button>";
      html += "<button onclick='playAgain()' style='padding: 12px 24px; font-size: 16px; border-radius: 4px; border: none; background: #00FFFF; color: #000; cursor: pointer; font-weight: bold; margin-right: 16px;'>â–¶ Play Again</button>";
      html += "<button onclick='leaveGame(\"victory\")' style='padding: 12px 24px; font-size: 16px; border-radius: 4px; border: none; background: #555; color: #fff; cursor: pointer;'>Leave Game</button>";
      html += "</div>";

      html += "<div style='margin-top: 15px; font-size: 14px;'>&copy; <a href='https://modmotif.com/' target='_blank' style='color: #00FFFF; text-decoration: underline;'>Modmotif</a> 2026</div>";
      html += buildBugButtonHTML('victory');

      victoryEl.innerHTML = html;
      victoryEl.style.display = "block";
      document.getElementById("startButton").style.display = "none";

      // Show survey after 5th game (once only)
      if (shouldShowSurvey()) {
        var surveyTarget = document.getElementById('leaderboardDisplay');
        if (surveyTarget) {
          var surveyDiv = document.createElement('div');
          surveyDiv.innerHTML = buildSurveyHTML('mobile');
          surveyTarget.parentNode.insertBefore(surveyDiv, surveyTarget.nextSibling);
        }
      }

      // Show leaderboard immediately
      showLeaderboard();
    }

    /** Stops all audio and navigates back to `index.html`. */
    function returnToHomeScreen() {
      stopBackgroundMusic();
      stopBossMusic();
      stopCreditsMusic();
      window.location.href = 'index.html';
    }

    // ============================================
    // SURVEY & BUG REPORT
    // ============================================
    // Forms submit directly to stanigarkeith@gmail.com via FormSubmit.co
    // No account or ID needed â€” already configured and working.
    var FORMSUBMIT_URL = 'https://formsubmit.co/ajax/stanigarkeith@gmail.com';

    function shouldShowSurvey() {
      var gameCount = parseInt(localStorage.getItem('nonx_game_count') || '0', 10);
      var surveyDone = localStorage.getItem('nonx_survey_done') === 'true';
      return gameCount >= 5 && !surveyDone;
    }

    function buildSurveyHTML(platform) {
      var s = '';
      s += "<div id='nonxSurvey' style='margin: 20px 0; padding: 16px; border: 1px solid #00FFFF; border-radius: 6px; text-align: left; max-width: 420px; margin-left: auto; margin-right: auto;'>";
      s += "<div style='font-size: 16px; color: #00FFFF; margin-bottom: 14px; text-align: center; font-weight: bold;'>ðŸ“‹ Quick Feedback (5 games in â€” thank you!)</div>";

      var questions = [
        { id: 'q1', text: 'Did you enjoy the gameplay?' },
        { id: 'q2', text: 'Would you play again?' },
        { id: 'q3', text: 'Was the game easy to pick up and play?' },
        { id: 'q4', text: 'Did you enjoy the music?' },
        { id: 'q5', text: 'Would you like more music options?' }
      ];

      questions.forEach(function(q) {
        s += "<div style='margin-bottom: 10px; font-size: 14px; color: #fff;'>" + q.text;
        s += "<span style='margin-left: 12px;'>";
        s += "<label style='margin-right: 10px; cursor: pointer;'><input type='radio' name='" + q.id + "' value='Yes' style='margin-right: 4px;'>Yes</label>";
        s += "<label style='cursor: pointer;'><input type='radio' name='" + q.id + "' value='No' style='margin-right: 4px;'>No</label>";
        s += "</span></div>";
      });

      s += "<div style='margin-bottom: 10px;'>";
      s += "<div style='font-size: 14px; color: #fff; margin-bottom: 6px;'>Suggestions or recommendations:</div>";
      s += "<textarea id='surveyComments' rows='3' style='width: 100%; padding: 6px; font-size: 13px; border-radius: 4px; border: none; background: #1a1a1a; color: #fff; resize: vertical; box-sizing: border-box;' placeholder='Any thoughts? We read everything...'></textarea>";
      s += "</div>";

      s += "<div style='text-align: center; white-space: nowrap;'>";
      s += "<button onclick='submitSurvey(\"" + platform + "\")' style='padding: 8px 20px; font-size: 14px; border-radius: 4px; border: none; background: #00FFFF; color: #000; cursor: pointer; font-weight: bold; margin-right: 12px;'>Submit Feedback</button>";
      s += "<button onclick='dismissSurvey()' style='padding: 8px 16px; font-size: 14px; border-radius: 4px; border: none; background: #333; color: #aaa; cursor: pointer;'>Skip</button>";
      s += "</div>";
      s += "</div>";
      return s;
    }

    function submitSurvey(platform) {
      var answers = {
        'Enjoyed gameplay':  document.querySelector('input[name="q1"]:checked'),
        'Would play again':  document.querySelector('input[name="q2"]:checked'),
        'Easy to pick up':   document.querySelector('input[name="q3"]:checked'),
        'Enjoyed music':     document.querySelector('input[name="q4"]:checked'),
        'Want more music':   document.querySelector('input[name="q5"]:checked'),
        'Suggestions':       (document.getElementById('surveyComments') || {}).value || '',
        'Platform':          platform,
        'AB Music Group':    userABGroup,
        'Music Variant':     localStorage.getItem('nonex_music') !== 'off' ? 'on' : 'off',
        'Games Played':      localStorage.getItem('nonx_game_count') || '5'
      };

      var body = {};
      Object.keys(answers).forEach(function(k) {
        body[k] = answers[k] ? answers[k].value : 'No answer';
      });
      body['Suggestions'] = answers['Suggestions'];

      fetch(FORMSUBMIT_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
        body: JSON.stringify(body)
      }).then(function() {
        localStorage.setItem('nonx_survey_done', 'true');
        fireEvent('survey_submitted', {
          'platform': platform,
          'ab_music_group': userABGroup,
          'music_variant': localStorage.getItem('nonex_music') !== 'off' ? 'on' : 'off',
          'games_played': parseInt(localStorage.getItem('nonx_game_count') || '5', 10)
        });
        var el = document.getElementById('nonxSurvey');
        if (el) el.innerHTML = "<div style='text-align:center; color:#00FFFF; padding: 12px;'>âœ“ Thanks for your feedback!</div>";
      }).catch(function() {
        localStorage.setItem('nonx_survey_done', 'true');
        var el = document.getElementById('nonxSurvey');
        if (el) el.innerHTML = "<div style='text-align:center; color:#555; padding: 12px;'>Could not send â€” but thanks anyway!</div>";
      });
    }

    function dismissSurvey() {
      localStorage.setItem('nonx_survey_done', 'true');
      fireEvent('survey_dismissed', {
        'ab_music_group': userABGroup,
        'music_variant': localStorage.getItem('nonex_music') !== 'off' ? 'on' : 'off',
        'games_played': parseInt(localStorage.getItem('nonx_game_count') || '5', 10)
      });
      var el = document.getElementById('nonxSurvey');
      if (el) el.style.display = 'none';
    }

    function buildBugButtonHTML(source) {
      return "<div style='margin-top: 10px;'>" +
        "<button onclick='openBugReport(\"" + source + "\")' style='padding: 6px 14px; font-size: 12px; border-radius: 4px; border: 1px solid #555; background: transparent; color: #555; cursor: pointer;'>ðŸ› Report a Bug</button>" +
        "</div>";
    }

    function openBugReport(source) {
      var existing = document.getElementById('nonxBugModal');
      if (existing) { existing.style.display = 'flex'; return; }

      var modal = document.createElement('div');
      modal.id = 'nonxBugModal';
      modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.85);z-index:9999;display:flex;align-items:center;justify-content:center;';
      modal.innerHTML =
        "<div style='background:#111;border:1px solid #00FFFF;border-radius:8px;padding:24px;max-width:400px;width:90%;color:#fff;font-family:monospace;'>" +
        "<div style='font-size:16px;color:#00FFFF;margin-bottom:16px;font-weight:bold;'>ðŸ› Report a Bug</div>" +
        "<div style='margin-bottom:10px;'>" +
          "<label style='font-size:13px;display:block;margin-bottom:4px;'>What happened?</label>" +
          "<textarea id='bugDescription' rows='3' style='width:100%;padding:6px;font-size:13px;border-radius:4px;border:none;background:#1a1a1a;color:#fff;resize:vertical;box-sizing:border-box;' placeholder='Describe the bug...'></textarea>" +
        "</div>" +
        "<div style='margin-bottom:10px;'>" +
          "<label style='font-size:13px;display:block;margin-bottom:4px;'>Steps to reproduce (optional):</label>" +
          "<textarea id='bugSteps' rows='2' style='width:100%;padding:6px;font-size:13px;border-radius:4px;border:none;background:#1a1a1a;color:#fff;resize:vertical;box-sizing:border-box;' placeholder='e.g. Level 3, used shield, then...'></textarea>" +
        "</div>" +
        "<div style='margin-bottom:16px;'>" +
          "<label style='font-size:13px;display:block;margin-bottom:4px;'>Your email (optional, for follow-up):</label>" +
          "<input type='email' id='bugEmail' style='width:100%;padding:6px;font-size:13px;border-radius:4px;border:none;background:#1a1a1a;color:#fff;box-sizing:border-box;' placeholder='you@example.com'>" +
        "</div>" +
        "<div style='text-align:right; white-space: nowrap;'>" +
          "<button onclick='submitBugReport(\"" + source + "\")' style='padding:8px 18px;font-size:13px;border-radius:4px;border:none;background:#00FFFF;color:#000;cursor:pointer;font-weight:bold;margin-right:10px;'>Submit</button>" +
          "<button onclick='document.getElementById(\"nonxBugModal\").style.display=\"none\"' style='padding:8px 14px;font-size:13px;border-radius:4px;border:none;background:#333;color:#aaa;cursor:pointer;'>Cancel</button>" +
        "</div>" +
        "</div>";
      document.body.appendChild(modal);
    }

    function submitBugReport(source) {
      var desc  = (document.getElementById('bugDescription') || {}).value || '';
      var steps = (document.getElementById('bugSteps') || {}).value || '';
      var email = (document.getElementById('bugEmail') || {}).value || '';

      if (!desc.trim()) {
        alert('Please describe the bug before submitting.');
        return;
      }

      fetch(FORMSUBMIT_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
        body: JSON.stringify({
          'Type': 'Bug Report',
          'Source': source,
          'Description': desc,
          'Steps': steps,
          'Reporter Email': email || 'Not provided',
          'Platform': 'mobile',
          'Games Played': localStorage.getItem('nonx_game_count') || '?',
          'AB Music Group': userABGroup
        })
      }).then(function() {
        fireEvent('bug_report_submitted', {
          'platform': 'mobile',
          'source': source,
          'ab_music_group': userABGroup,
          'music_variant': localStorage.getItem('nonex_music') !== 'off' ? 'on' : 'off'
        });
        var modal = document.getElementById('nonxBugModal');
        if (modal) modal.innerHTML =
          "<div style='background:#111;border:1px solid #00FFFF;border-radius:8px;padding:32px;color:#00FFFF;font-family:monospace;text-align:center;'>" +
          "âœ“ Bug report sent!<br><br>" +
          "<button onclick='document.getElementById(\"nonxBugModal\").style.display=\"none\"' style='padding:8px 18px;font-size:13px;border-radius:4px;border:none;background:#333;color:#aaa;cursor:pointer;'>Close</button>" +
          "</div>";
      }).catch(function() {
        alert('Could not send bug report. Please try again later.');
      });
    }

    /** Fires leave_game event then navigates to main menu. */
    function leaveGame(source) {
      fireEvent('leave_game', {
        'ab_music_group': userABGroup,
        'platform': 'mobile',
        'source': source, // 'game_over' or 'victory'
        'score': score,
        'music_variant': localStorage.getItem('nonex_music') !== 'off' ? 'on' : 'off'
      });
      stopBackgroundMusic();
      stopBossMusic();
      stopCreditsMusic();
      window.location.href = 'index.html';
    }

    /** Resets and restarts the game in place without returning to main menu. */
    function playAgain() {
      // Hide both end screens
      document.getElementById('gameOver').style.display = 'none';
      document.getElementById('victory').style.display = 'none';

      // Trigger the start button reset branch (gameOver is true so it fully resets)
      var sb = document.getElementById('startButton');
      sb.style.display = 'block';
      sb.click();
    }

    // ============================================
    // BULLETS
    // ============================================
    /**
     * Fires one or more player bullets from the ship's current position,
     * based on the active laser level:
     *   1 â†’ single centre bullet
     *   2 â†’ dual side-by-side bullets (double laser)
     *   3 â†’ three evenly spread bullets (triple laser, purple phase default)
     *   4 â†’ four evenly spread bullets (quad laser, purple phase rare upgrade)
     */
    function shootBullet() {
      playSound('playerBullet');
      if (laserLevel >= 4) {
        // Quad laser - four bullets spread across ship width (rare upgrade)
        var offsets = [0.15, 0.38, 0.62, 0.85];
        for (var q = 0; q < 4; q++) {
          playerBullets.push(BulletPool.get(
            Math.floor(player.x + player.width * offsets[q] - 2),
            Math.floor(player.y),
            5,
            10,
            CONFIG.bulletSpeed
          ));
        }
      } else if (laserLevel === 3) {
        // Triple laser - three bullets spread across ship width (purple phase default)
        var offsets = [0.2, 0.5, 0.8];
        for (var t = 0; t < 3; t++) {
          playerBullets.push(BulletPool.get(
            Math.floor(player.x + player.width * offsets[t] - 2),
            Math.floor(player.y),
            5,
            10,
            CONFIG.bulletSpeed
          ));
        }
      } else if (hasDoubleLaser) {
        // Double laser - two side-by-side bullets
        playerBullets.push(BulletPool.get(
          Math.floor(player.x + player.width / 4 - 2),
          Math.floor(player.y),
          5,
          10,
          CONFIG.bulletSpeed
        ));
        playerBullets.push(BulletPool.get(
          Math.floor(player.x + (player.width * 3 / 4) - 2),
          Math.floor(player.y),
          5,
          10,
          CONFIG.bulletSpeed
        ));
      } else {
        // Single bullet
        playerBullets.push(BulletPool.get(
          Math.floor(player.x + player.width / 2 - 2),
          Math.floor(player.y),
          5,
          10,
          CONFIG.bulletSpeed
        ));
      }
    }

    /**
     * Fires one bullet downward from the bottom-centre of the given enemy.
     * Bullet speed scales with the current game phase (red: +40%, purple: +65%).
     * @param {Object} enemy - The firing enemy object.
     */
    function shootEnemyBullet(enemy) {
      var bulletSpeed = CONFIG.enemyBulletSpeed;
      if (purplePhase) {
        bulletSpeed *= 1.65; // 65% faster in purple phase
      } else if (redPhase) {
        bulletSpeed *= 1.4; // 40% faster in red phase
      }
      enemyBullets.push(BulletPool.get(
        Math.floor(enemy.x + enemy.width / 2 - 2),
        Math.floor(enemy.y + enemy.height),
        5,
        10,
        bulletSpeed
      ));
    }

    // ============================================
    // COLLISION DETECTION
    // ============================================
    /**
     * Axis-Aligned Bounding Box (AABB) collision test between two rect objects.
     * @param {{x:number, y:number, width:number, height:number}} a
     * @param {{x:number, y:number, width:number, height:number}} b
     * @returns {boolean} True when the two rects overlap.
     */
    function isColliding(a, b) {
      return a.x < b.x + b.width &&
        a.x + a.width > b.x &&
        a.y < b.y + b.height &&
        a.y + a.height > b.y;
    }

    // ============================================
    // PLAYER DAMAGE
    // ============================================
    /**
     * Applies damage to the player, accounting for the shield power-up:
     *   â€¢ Purple phase with shield: damage fully blocked.
     *   â€¢ Earlier phases with shield: damage reduced to 5; absorbed entirely
     *     when health â‰¤ 15.
     *   â€¢ No shield in red/purple phase: downgrades laser level on hit.
     * Triggers the player blink effect, updates the HUD, and ends the game
     * (showing the Game Over overlay) if health reaches 0.
     * @param {number} damage - HP to subtract before shield mitigation.
     */
    function playerTakeDamage(damage) {
      if (hasShield) {
        shieldHitsRemaining--;
        if (shieldHitsRemaining <= 0) {
          hasShield = false;
          showAnnouncement("powerupDisplay", "Shield Broken!", 1500);
        } else {
          showAnnouncement("powerupDisplay", "Shield: " + shieldHitsRemaining + " hits left", 800);
        }
        if (purplePhase) {
          // Purple phase: shield fully blocks all damage, no health loss
          return;
        }
        // Earlier phases: shield reduces damage to 5, protects health at low HP
        damage = 5;
        if (health <= 15) {
          showAnnouncement("powerupDisplay", "Shield absorbed damage!", 800);
          return;
        }
      } else {
        // Lose laser power when hit without shield (red and purple phases)
        if ((redPhase || purplePhase) && hasDoubleLaser) {
          if (laserLevel >= 4) {
            laserLevel = 3; // Quad -> triple
            showAnnouncement("powerupDisplay", "Lost Quad Laser!", 1500);
          } else if (laserLevel === 3) {
            laserLevel = 2; // Triple -> double
            showAnnouncement("powerupDisplay", "Lost Triple Laser!", 1500);
          } else {
            hasDoubleLaser = false;
            laserLevel = 1;
          }
        }
      }

      health -= damage;
      updateUI();

      // Start blinking effect
      playerBlinking = true;
      playerBlinkTimer = 30; // Blink for 30 frames (~0.5 seconds)

      if (health <= 0) {
        health = 0;
        updateUI();
        gameOver = true;
        playSound('playerDead');
        stopBossMusic();
        // Keep background music playing - don't stop it

        // Check if top 10 score and save
        var madeTopTen = isTopTenScore(score);
        var rank = getScoreRank(score);
        if (madeTopTen) {
          addHighScore(score);
        }

        // Build game over display
        var gameOverEl = document.getElementById("gameOver");
        var html = "Game Over!<br><br>Your Score: " + score;
        if (madeTopTen) {
          html += "<br><span style='color: #FFD700;'>TOP 10! Rank #" + rank + "</span>";
        }
        html += "<br><br>";
        html += "<div style='margin-bottom: 20px; white-space: nowrap;'>";
        html += "<button id='gameOverMuteBtn' onclick='toggleMusic()' style='padding: 12px 20px; font-size: 16px; border-radius: 4px; border: none; background: #00FFFF; color: #000; cursor: pointer; margin-right: 10px; font-weight: bold;'>" + (bgMusic.paused ? 'ðŸ”‡' : 'ðŸ”Š') + "</button>";
        html += "<button onclick='playAgain()' style='padding: 12px 24px; font-size: 16px; border-radius: 4px; border: none; background: #00FFFF; color: #000; cursor: pointer; font-weight: bold; margin-right: 16px;'>â–¶ Play Again</button>";
        html += "<button onclick='leaveGame(\"game_over\")' style='padding: 12px 24px; font-size: 16px; border-radius: 4px; border: none; background: #555; color: #fff; cursor: pointer;'>Leave Game</button>";
        html += "</div>";
        html += "<div style='margin-top: 15px; font-size: 14px;'>&copy; <a href='https://modmotif.com/' target='_blank' style='color: #00FFFF; text-decoration: underline;'>Modmotif</a> 2026</div>";
        html += buildBugButtonHTML('game_over');
        gameOverEl.innerHTML = html;
        gameOverEl.style.display = "block";
        document.getElementById("startButton").style.display = "none";

        // Show survey after 5th game (once only)
        if (shouldShowSurvey()) {
          var surveyDiv = document.createElement('div');
          surveyDiv.innerHTML = buildSurveyHTML('mobile');
          gameOverEl.appendChild(surveyDiv);
        }

        // Track player death (played until death = game_complete per analytics spec)
        fireEvent('player_death', {
          'ab_music_group': userABGroup,
          'platform': 'mobile',
          'level_reached': level,
          'score': score,
          'music_variant': localStorage.getItem('nonex_music') !== 'off' ? 'on' : 'off'
        });
        fireEvent('game_complete', {
          'ab_music_group': userABGroup,
          'platform': 'mobile',
          'level_reached': level,
          'score': score,
          'music_variant': localStorage.getItem('nonex_music') !== 'off' ? 'on' : 'off'
        });
      } else {
        playSound('playerHit');
      }
    }

    /**
     * Handles the player hit-flash animation. Decrements `playerBlinkTimer`
     * each frame and toggles `playerVisible` every 3 frames to create a
     * strobe effect lasting ~0.5 s (30 frames).
     */
    function updatePlayerBlink() {
      if (playerBlinking) {
        playerBlinkTimer--;
        // Toggle visibility every 3 frames
        playerVisible = Math.floor(playerBlinkTimer / 3) % 2 === 0;
        if (playerBlinkTimer <= 0) {
          playerBlinking = false;
          playerVisible = true;
        }
      }
    }

    // ============================================
    // INPUT HANDLING
    // ============================================
    document.addEventListener("keydown", function (e) {
      // Shift+D â€” toggle developer mode
      if (e.shiftKey && (e.key === 'd' || e.key === 'D')) {
        devMode = !devMode;
        var indicator = document.getElementById('devModeIndicator');
        if (!indicator) {
          indicator = document.createElement('div');
          indicator.id = 'devModeIndicator';
          indicator.style.cssText = 'position:fixed;top:8px;left:50%;transform:translateX(-50%);' +
            'background:#FF0;color:#000;font-family:monospace;font-size:12px;font-weight:bold;' +
            'padding:3px 10px;border-radius:4px;z-index:9999;pointer-events:none;';
          indicator.textContent = 'âš  DEV MODE â€” Analytics OFF | Shift+V: Victory | Shift+G: Game Over';
          document.body.appendChild(indicator);
        }
        indicator.style.display = devMode ? 'block' : 'none';
        console.log('%c[DEV MODE] ' + (devMode ? 'ENABLED ðŸŸ¢' : 'DISABLED ðŸ”´'), 'color:#FF0;font-weight:bold;font-size:14px;');
        return;
      }

      // Shift+V â€” skip to victory (devMode only)
      if (e.shiftKey && (e.key === 'v' || e.key === 'V')) {
        if (devMode) {
          console.log('%c[DEV MODE] Skipping to victory screen', 'color:#00FFFF;font-weight:bold;');
          showVictory();
        }
        return;
      }

      // Shift+G â€” skip to game over (devMode only)
      if (e.shiftKey && (e.key === 'g' || e.key === 'G')) {
        if (devMode) {
          console.log('%c[DEV MODE] Skipping to game over screen', 'color:#00FFFF;font-weight:bold;');
          health = 0;
          updateUI();
          gameOver = true;
          stopBossMusic();
          var madeTopTen = isTopTenScore(score);
          var rank = getScoreRank(score);
          if (madeTopTen) addHighScore(score);
          var gameOverEl = document.getElementById('gameOver');
          var html = "Game Over!<br><br>Your Score: " + score;
          if (madeTopTen) html += "<br><span style='color:#FFD700;'>TOP 10! Rank #" + rank + "</span>";
          html += "<br><br>";
          html += "<div style='margin-bottom: 20px; white-space: nowrap;'>";
          html += "<button id='gameOverMuteBtn' onclick='toggleMusic()' style='padding: 12px 20px; font-size: 16px; border-radius: 4px; border: none; background: #00FFFF; color: #000; cursor: pointer; margin-right: 10px; font-weight: bold;'>" + (bgMusic.paused ? 'ðŸ”‡' : 'ðŸ”Š') + "</button>";
          html += "<button onclick='playAgain()' style='padding: 12px 24px; font-size: 16px; border-radius: 4px; border: none; background: #00FFFF; color: #000; cursor: pointer; font-weight: bold; margin-right: 16px;'>â–¶ Play Again</button>";
          html += "<button onclick='leaveGame(\"game_over\")' style='padding: 12px 24px; font-size: 16px; border-radius: 4px; border: none; background: #555; color: #fff; cursor: pointer;'>Leave Game</button>";
          html += "</div>";
          gameOverEl.innerHTML = html;
          gameOverEl.style.display = 'block';
          document.getElementById('startButton').style.display = 'none';
        }
        return;
      }

      // Shift+1â€“9/0 â€” jump to level (devMode only)
      if (devMode && e.shiftKey && !gameOver && !bossActive) {
        var jumpLevel = null;
        if (e.key === '!') jumpLevel = 1;
        else if (e.key === '@') jumpLevel = 2;
        else if (e.key === '#') jumpLevel = 3;
        else if (e.key === '$') jumpLevel = 4;
        else if (e.key === '%') jumpLevel = 5;
        else if (e.key === '^') jumpLevel = 6;
        else if (e.key === '&') jumpLevel = 7;
        else if (e.key === '*') jumpLevel = 8;
        else if (e.key === '(') jumpLevel = 9;
        else if (e.key === ')') jumpLevel = 12;
        if (jumpLevel !== null) {
          enemies.forEach(function (e) { EnemyPool.release(e); });
          enemies = [];
          waveInProgress = false;
          waveCooldown = false;
          currentWave = 0;
          bossActive = false;
          boss = null;
          level = jumpLevel;
          redPhase = jumpLevel >= 5;
          purplePhase = jumpLevel >= 9;
          boss1Defeated = jumpLevel >= 5;
          boss2Defeated = jumpLevel >= 9;
          health = CONFIG.maxHealth;
          score = jumpLevel >= 9 ? 2000 : (jumpLevel >= 5 ? 800 : 0);
          powerupsSpawnedThisLevel = { health: false, doubleLaser: false, shield: false };
          updateUI();
          showAnnouncement("levelDisplay", "DEV: Level " + jumpLevel, 2000);
          console.log('%c[DEV MODE] Jumped to level ' + jumpLevel, 'color:#00FFFF;font-weight:bold;');
        }
      }

      // Pause toggle (P or Escape)
      if (e.key === "p" || e.key === "P" || e.key === "Escape") {
        if (!gameOver) {
          paused = !paused;
          document.getElementById("pauseDisplay").style.display = paused ? "block" : "none";
          document.getElementById("startButton").innerText = paused ? "Resume" : "Pause";
          if (paused) {
            bgMusic.pause();
          } else {
            bgMusic.play();
          }
        }
        return;
      }

      // Ignore other keys if paused
      if (paused) return;

      if (e.key === "Right" || e.key === "ArrowRight") rightPressed = true;
      else if (e.key === "Left" || e.key === "ArrowLeft") leftPressed = true;
      else if (e.key === " ") {
        e.preventDefault();
        shootBullet();
      }
    });

    document.addEventListener("keyup", function (e) {
      if (e.key === "Right" || e.key === "ArrowRight") rightPressed = false;
      else if (e.key === "Left" || e.key === "ArrowLeft") leftPressed = false;
    });

    // ============================================
    // MOBILE CANVAS SCALING
    // ============================================
    /**
     * Scales the canvas to fill the device viewport using a CSS transform,
     * maintaining the native 480Ã—1040 aspect ratio. Called once on load and
     * again on every `resize` event. Uses `Math.max` so the canvas always
     * covers the full screen without letterboxing.
     */
    function resizeCanvas() {
      var vw = window.innerWidth;
      var vh = window.innerHeight;
      var scale = Math.max(vw / canvas.width, vh / canvas.height);
      canvas.style.transformOrigin = 'center center';
      canvas.style.transform = 'scale(' + scale + ')';
    }

    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // ============================================
    // TOUCH CONTROLS
    // ============================================
    /**
     * Converts a Touch object's CSS-pixel clientX into the canvas coordinate
     * space, accounting for the CSS transform scale applied by `resizeCanvas`.
     * @param {Touch} touch - A Touch object from a touch event.
     * @returns {number} X position in canvas pixels.
     */
    function getTouchCanvasX(touch) {
      var rect = canvas.getBoundingClientRect();
      // Scale from CSS pixels to canvas pixels
      var scaleX = canvas.width / rect.width;
      return (touch.clientX - rect.left) * scaleX;
    }

    canvas.addEventListener("touchstart", function (e) {
      e.preventDefault();
      if (gameOver || paused) return;
      var touch = e.touches[0];
      touchActive = true;
      touchTargetX = getTouchCanvasX(touch);
      // Begin shoot cycle on first touch
      touchShootCycleStart = Date.now();
      touchShootActive = true;
      touchLastShot = 0;
    }, { passive: false });

    canvas.addEventListener("touchmove", function (e) {
      e.preventDefault();
      if (!touchActive) return;
      var touch = e.touches[0];
      touchTargetX = getTouchCanvasX(touch);
    }, { passive: false });

    canvas.addEventListener("touchend", function (e) {
      e.preventDefault();
      if (e.touches.length === 0) {
        touchActive = false;
        touchShootActive = false;
      }
    }, { passive: false });

    canvas.addEventListener("touchcancel", function (e) {
      touchActive = false;
      touchShootActive = false;
    }, { passive: false });

    /**
     * Called every game frame. Moves the player toward the touch x position at
     * up to 10 px/frame (snaps when within 10 px), then manages the shoot cycle:
     *   Active window : TOUCH_SHOOT_DURATION ms  (1.8 s)
     *   Reload window : TOUCH_SHOOT_COOLDOWN ms  (0.4 s)
     * During the active window, fires a bullet every TOUCH_SHOOT_INTERVAL ms
     * (130 ms) as long as the player is touching the screen.
     */
    function updateTouchControls() {
      if (!touchActive) return;
      var now = Date.now();

      // Move player toward touch x (snap directly â€” finger IS the ship)
      var targetCenterX = touchTargetX;
      var playerCenterX = player.x + player.width / 2;
      var diff = targetCenterX - playerCenterX;
      // Move up to 10px/frame, but snap if very close
      if (Math.abs(diff) > 10) {
        player.x += (diff / Math.abs(diff)) * Math.min(Math.abs(diff), 10);
      } else {
        player.x += diff;
      }
      player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));

      // Shoot cycle: 5s on, 1.5s cooldown, repeat
      var elapsed = now - touchShootCycleStart;
      if (elapsed >= TOUCH_SHOOT_DURATION + TOUCH_SHOOT_COOLDOWN) {
        // Start a new cycle
        touchShootCycleStart = now;
        elapsed = 0;
        touchShootActive = true;
      }
      touchShootActive = elapsed < TOUCH_SHOOT_DURATION;

      // Fire at interval during active window
      if (touchShootActive && now - touchLastShot >= TOUCH_SHOOT_INTERVAL) {
        shootBullet();
        touchLastShot = now;
      }
    }

    // ============================================
    // MAIN GAME LOOP
    // ============================================
    /**
     * Main game loop, called via `requestAnimationFrame`. Each frame:
     *   1. Early-returns if game is over; keeps rAF alive while paused.
     *   2. Clears the canvas and updates screen shake.
     *   3. Updates touch controls (movement + auto-fire).
     *   4. Draws the player ship (with blink) and processes keyboard movement.
     *   5. Updates player bullets (upward movement, off-screen removal, collision
     *      with boss/enemies, shield interaction).
     *   6. Updates enemy bullets (downward, player collision, damage application).
     *   7. Updates power-ups (fall, player collection).
     *   8. Delegates to the boss subsystem or the wave-formation subsystem.
     *   9. Schedules the next frame with requestAnimationFrame.
     */
    function draw() {
      if (gameOver) return;

      // If paused, just keep the animation frame going but don't update
      if (paused) {
        requestAnimationFrame(draw);
        return;
      }

      // Update screen shake effect
      updateScreenShake();

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Update spatial grid each frame
      SpatialGrid.clear();
      for (var i = 0; i < enemies.length; i++) {
        SpatialGrid.insert(enemies[i]);
      }
      // Also insert boss minions if active
      if (bossActive) {
        for (var i = 0; i < bossMinions.length; i++) {
          SpatialGrid.insert(bossMinions[i]);
        }
      }

      // Update player blink effect
      updatePlayerBlink();

      // Draw shield ripple effect if active
      if (hasShield) {
        var playerCx = player.x + player.width / 2;
        var playerCy = player.y + player.height / 2;
        var time = Date.now();
        var beatPhase = (time % BPM_INTERVAL) / BPM_INTERVAL;
        var maxShieldRipple = player.width * 0.9;
        var shieldRippleRadius = beatPhase * maxShieldRipple;
        var shieldRippleAlpha = 1 - beatPhase;

        ctx.save();
        if (shieldRippleAlpha > 0.05) {
          ctx.beginPath();
          ctx.arc(playerCx, playerCy, shieldRippleRadius, 0, Math.PI * 2);
          ctx.strokeStyle = 'rgba(0, 255, 255, ' + (shieldRippleAlpha * 0.6) + ')';
          ctx.lineWidth = 3;
          ctx.stroke();
        }

        // Second ripple
        var beatPhase2 = ((time + BPM_INTERVAL / 2) % BPM_INTERVAL) / BPM_INTERVAL;
        var shieldRippleRadius2 = beatPhase2 * maxShieldRipple;
        var shieldRippleAlpha2 = 1 - beatPhase2;
        if (shieldRippleAlpha2 > 0.05) {
          ctx.beginPath();
          ctx.arc(playerCx, playerCy, shieldRippleRadius2, 0, Math.PI * 2);
          ctx.strokeStyle = 'rgba(0, 255, 255, ' + (shieldRippleAlpha2 * 0.4) + ')';
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        ctx.restore();
      }

      // Draw firing glow when player is actively touching (under joystick)
      if (!gameOver && !paused && touchActive) {
        var jx = player.x + player.width / 2;
        var jy = player.y + player.height + 42; // joystick center
        var gradient = ctx.createRadialGradient(jx, jy, 0, jx, jy, 80);
        gradient.addColorStop(0, 'rgba(0, 255, 255, 0.5)');
        gradient.addColorStop(0.5, 'rgba(0, 255, 255, 0.25)');
        gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(jx - 80, jy - 80, 160, 160);
      }

      // Draw joystick base below player
      {
        var jx = player.x + player.width / 2;
        var jRadius = 42;
        var jy = player.y + player.height + jRadius;
        ctx.save();
        // Joystick base circle
        ctx.beginPath();
        ctx.arc(jx, jy, jRadius, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0, 255, 255, 0.45)';
        ctx.fill();
        ctx.restore();
      }

      // Draw quad laser glow when player has quad lasers
      if (!gameOver && !paused && laserLevel >= 4) {
        var playerCenterX = player.x + player.width / 2;
        var playerCenterY = player.y + player.height / 2;
        var gradient = ctx.createRadialGradient(playerCenterX, playerCenterY, 0, playerCenterX, playerCenterY, player.width);
        gradient.addColorStop(0, 'rgba(0, 255, 255, 0.4)');
        gradient.addColorStop(0.5, 'rgba(0, 255, 255, 0.2)');
        gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(player.x - player.width / 2, player.y - player.height / 2, player.width * 2, player.height * 2);
      }

      // Draw and move player (only if visible during blink)
      if (playerVisible) {
        ctx.drawImage(playerImg, player.x, player.y, player.width, player.height);
      }
      // Touch movement + auto-shoot cycle
      updateTouchControls();
      // Keyboard movement (only applies when touch is not active)
      if (!touchActive) {
        if (rightPressed && player.x < canvas.width - player.width) {
          player.x += CONFIG.playerSpeed;
        } else if (leftPressed && player.x > 0) {
          player.x -= CONFIG.playerSpeed;
        }
      }

      // Update player bullets
      ctx.fillStyle = "#00FF00";
      for (var i = playerBullets.length - 1; i >= 0; i--) {
        var bullet = playerBullets[i];

        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
        bullet.y -= bullet.speed;

        if (bullet.y < 0) {
          BulletPool.release(bullet);
          playerBullets.splice(i, 1);
          continue;
        }

        // Check collision with boss
        if (boss && isColliding(bullet, boss)) {
          BulletPool.release(bullet);
          playerBullets.splice(i, 1);
          damageBoss();
          continue;
        }

        // Check collision with enemies (SPATIAL GRID OPTIMIZATION)
        var candidates = SpatialGrid.retrieve(bullet);
        for (var j = 0; j < candidates.length; j++) {
          var enemy = candidates[j];
          // Double check actual collision (grid is just broad phase)
          if (isColliding(bullet, enemy)) {
            // Check if enemy is shielded
            if (enemy.shielded) {
              // Track shield hits - shield breaks after 25 hits
              if (typeof enemy.shieldHits === 'undefined') {
                enemy.shieldHits = 0;
              }
              enemy.shieldHits++;

              // Break shield permanently - 15 hits for levels 1-8, 25 for levels 9+
              var shieldBreakThreshold = level >= 9 ? 25 : 15;
              if (enemy.shieldHits >= shieldBreakThreshold) {
                enemy.shielded = false;
                enemy.shieldBroken = true; // Mark as broken so cascade doesn't restore it
              }

              // Bullet stops at shield - destroy bullet but enemy survives
              BulletPool.release(bullet);
              playerBullets.splice(i, 1);
              // Optional: play shield hit sound here later
              break;
            } else {
              // No shield - destroy both bullet and enemy
              BulletPool.release(bullet);
              playerBullets.splice(i, 1);

              spawnExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
              var realIndex = enemies.indexOf(enemy);
              if (realIndex > -1) {
                EnemyPool.release(enemy);
                enemies.splice(realIndex, 1);
              }
              score += 10;
              updateUI();
              playSound('enemyDead');
              checkLevelUp();
              break;
            }
          }
        }
      }

      // Update enemy bullets
      ctx.fillStyle = "#FF0000";
      for (var i = enemyBullets.length - 1; i >= 0; i--) {
        var bullet = enemyBullets[i];

        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
        bullet.y += bullet.speed;

        if (bullet.y > canvas.height) {
          BulletPool.release(bullet);
          enemyBullets.splice(i, 1);
          continue;
        }

        if (isColliding(bullet, player)) {
          BulletPool.release(bullet);
          enemyBullets.splice(i, 1);
          var damage = bullet.isBossBullet ? CONFIG.bossDamage : CONFIG.enemyBulletDamage;
          playerTakeDamage(damage);
          if (gameOver) return;
        }
      }

      // Update power-ups
      for (var i = powerups.length - 1; i >= 0; i--) {
        var powerup = powerups[i];

        drawPowerup(powerup);
        powerup.y += powerup.speed;

        if (powerup.y > canvas.height) {
          powerups.splice(i, 1);
          continue;
        }

        if (isColliding(powerup, player)) {
          collectPowerup(powerup);
          powerups.splice(i, 1);
        }
      }

      // Boss mode
      if (bossActive) {
        updateBoss();

        // Update orbiting soldiers
        var orbiterGameOver = updateBossOrbiters();
        if (orbiterGameOver) return;

        // Update side-scrolling minions (enemy2)
        var minionGameOver = updateBossMinions();
        if (minionGameOver) return;

        // Smart filler spawning (beat-synced, capped)
        spawnBossFiller();

        // Random powerup spawn during boss fight
        if (!powerupsSpawnedThisLevel.health && !powerupsSpawnedThisLevel.doubleLaser) {
          if (Math.random() < 0.0008) {
            var powerupType = Math.random() < 0.6 ? POWERUP_TYPES.HEALTH : POWERUP_TYPES.DOUBLE_LASER;
            if (createPowerup(powerupType)) {
              if (powerupType === POWERUP_TYPES.HEALTH) {
                powerupsSpawnedThisLevel.health = true;
              } else {
                powerupsSpawnedThisLevel.doubleLaser = true;
              }
            }
          }
        }

        // Update filler enemies during boss fight
        for (var i = enemies.length - 1; i >= 0; i--) {
          var enemy = enemies[i];

          drawEnemy(enemy);

          // Side entry enemies move horizontally
          if (enemy.sideEntry) {
            enemy.x += enemy.horizontalSpeed * enemy.horizontalDirection;
            enemy.y += 0.3; // Slight downward drift

            // Remove if crossed screen
            if ((enemy.horizontalDirection > 0 && enemy.x > canvas.width) ||
              (enemy.horizontalDirection < 0 && enemy.x < -enemy.width)) {
              EnemyPool.release(enemies[i]); // Release
              enemies.splice(i, 1);
              continue;
            }
          } else {
            // Top entry enemies
            enemy.y += enemy.speed;

            // Zigzag movement
            if (enemy.zigzag) {
              enemy.x += enemy.zigzagSpeed * enemy.zigzagDirection;
              enemy.zigzagTimer++;
              if (enemy.zigzagTimer >= enemy.zigzagInterval) {
                enemy.zigzagTimer = 0;
                enemy.zigzagDirection *= -1;
              }
              if (enemy.x <= 0) {
                enemy.x = 0;
                enemy.zigzagDirection = 1;
              } else if (enemy.x >= canvas.width - enemy.width) {
                enemy.x = canvas.width - enemy.width;
                enemy.zigzagDirection = -1;
              }
            }

            // Side-to-side movement
            if (enemy.sideToSide) {
              enemy.x += enemy.horizontalSpeed * enemy.horizontalDirection;
              if (enemy.x <= 0) {
                enemy.x = 0;
                enemy.horizontalDirection = 1;
              } else if (enemy.x >= canvas.width - enemy.width) {
                enemy.x = canvas.width - enemy.width;
                enemy.horizontalDirection = -1;
              }
            }
          }

          // Check collision with player
          if (isColliding(enemy, player)) {
            EnemyPool.release(enemies[i]); // Release
            enemies.splice(i, 1);
            playerTakeDamage(CONFIG.enemyCollisionDamage);
            if (gameOver) return;
            continue;
          }

          // Remove if off screen (bottom)
          if (enemy.y > canvas.height) {
            EnemyPool.release(enemies[i]); // Release
            enemies.splice(i, 1);
            continue;
          }

          // Check collision with player bullets
          for (var j = playerBullets.length - 1; j >= 0; j--) {
            if (isColliding(playerBullets[j], enemy)) {
              BulletPool.release(playerBullets[j]);
              playerBullets.splice(j, 1);
              spawnExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
              EnemyPool.release(enemies[i]); // Release
              enemies.splice(i, 1);
              score += 10;
              updateUI();
              playSound('enemyDead');
              break;
            }
          }
        }

        // Check boss collision with player
        if (boss && isColliding(boss, player)) {
          playerTakeDamage(CONFIG.bossDamage);
          if (gameOver) return;
        }
      } else {
        // Regular enemy mode - wave-based formations
        var time = Date.now();

        // Start first wave if not started
        if (currentWave === 0 && !waveCooldown) {
          startWave(1);
        }

        // Update morphing formations
        if (waveInProgress) {
          // Move formation center smoothly as a unit (ease-out lerp)
          if (!formationEntered) {
            formationCurrentCenterY += (formationTargetCenterY - formationCurrentCenterY) * 0.045;
            if (formationTargetCenterY - formationCurrentCenterY < 1) {
              formationCurrentCenterY = formationTargetCenterY;
              formationEntered = true;
              // Reset morph clock so the first explodedâ†’collapsed transition
              // starts fresh from this moment rather than snapping instantly.
              morphStartTime = Date.now();
              lastMorphTime = Date.now();
              // Show shield warning (brief after level 1 - players already know)
              var warningEl = document.getElementById("warningDisplay");
              warningEl.style.display = "block";
              if (level > 1) {
                // Brief 2-second warning for experienced players
                setTimeout(function () {
                  warningEl.style.display = "none";
                }, 2000);
              }
              // Mark all formation enemies as reached
              enemies.forEach(function (e) {
                if (e.formation && e.formationType === 'morphing') {
                  e.reachedTarget = true;
                  e.centerY = formationCurrentCenterY;
                }
              });
            }
          }
          updateMorphingFormation(time);
          updateShieldCascade();
          updateKamikazeEntry();
        }

        // Update barrier reinforcements
        updateBarriers();

        for (var i = enemies.length - 1; i >= 0; i--) {
          var enemy = enemies[i];

          // Skip drawing enemies that are entirely above the canvas
          if (enemy.y + enemy.height > 0) {
            drawEnemy(enemy);
          }

          // Formation enemies - position relative to formation center
          if (enemy.formation) {
            // During entry, update position based on moving formation center
            if (!formationEntered && enemy.formationType === 'morphing') {
              var baseX = enemy.centerX + enemy.currentPos.x * enemy.spreadRadius;
              var baseY = formationCurrentCenterY + enemy.currentPos.y * enemy.spreadRadius * 0.8;
              enemy.x = baseX - enemy.width / 2;
              enemy.y = baseY - enemy.height / 2;
            }

            // Legacy formation types (spiral, pincer, sineWave) for variety
            var beatPhase = ((time + (enemy.breathPhase || 0) * BPM_INTERVAL) % BPM_INTERVAL) / BPM_INTERVAL;

            if (enemy.formationType === 'spiral' && enemy.reachedTarget) {
              enemy.spiralAngle += 0.02;
              var pulseFactor = 1 + Math.sin(beatPhase * Math.PI * 2) * 0.3;
              var currentRadius = enemy.spiralBaseRadius * pulseFactor;
              enemy.x = enemy.spiralCenterX + Math.cos(enemy.spiralAngle) * currentRadius - enemy.width / 2;
              enemy.y = enemy.spiralCenterY + Math.sin(enemy.spiralAngle) * currentRadius - enemy.height / 2;
            }

            if (enemy.formationType === 'pincer') {
              if (!enemy.reachedTarget) {
                if (enemy.pincerSide === 'left' && enemy.x < enemy.pincerTargetX) {
                  enemy.x += enemy.pincerSpeed;
                  if (enemy.x >= enemy.pincerTargetX) enemy.reachedTarget = true;
                } else if (enemy.pincerSide === 'right' && enemy.x > enemy.pincerTargetX) {
                  enemy.x -= enemy.pincerSpeed;
                  if (enemy.x <= enemy.pincerTargetX) enemy.reachedTarget = true;
                }
              } else {
                var pulseDist = Math.sin(beatPhase * Math.PI * 2) * 30;
                if (enemy.pincerSide === 'left') {
                  enemy.x = enemy.pincerBaseX + pulseDist;
                } else {
                  enemy.x = enemy.pincerBaseX - pulseDist;
                }
              }
            }

            if (enemy.formationType === 'sineWave' && enemy.reachedTarget) {
              var wavePhase = (time / BPM_INTERVAL) * Math.PI * 2;
              enemy.x = enemy.baseX + Math.sin(wavePhase + enemy.sinePhase) * enemy.sineAmplitude;
              var vertBounce = Math.abs(Math.sin(beatPhase * Math.PI)) * 15;
              enemy.y = enemy.baseY + vertBounce;
              if (enemy.x < 0) enemy.x = 0;
              if (enemy.x > canvas.width - enemy.width) enemy.x = canvas.width - enemy.width;
            }

            // Morphing formations are handled by updateMorphingFormation()
          } else {
            // Regular non-formation enemies (fillers and kamikazes)

            // Kamikaze enemies dive toward player
            if (enemy.kamikaze) {
              // Still descending with the group center â€” position handled by updateKamikazeEntry
              if (enemy.kamikazeEntering) continue;

              enemy.x += enemy.kamikazeVelX;
              enemy.y += enemy.kamikazeVelY;

              // Remove if off screen
              if (enemy.y > canvas.height || enemy.x < -enemy.width || enemy.x > canvas.width) {
                EnemyPool.release(enemies[i]); // Release
                enemies.splice(i, 1);
                continue;
              }
            }
            // Side entry enemies move horizontally across screen
            else if (enemy.sideEntry) {
              enemy.x += enemy.horizontalSpeed * enemy.horizontalDirection;
              enemy.y += 0.3; // Slight downward drift

              // Remove if crossed screen
              if ((enemy.horizontalDirection > 0 && enemy.x > canvas.width) ||
                (enemy.horizontalDirection < 0 && enemy.x < -enemy.width)) {
                EnemyPool.release(enemies[i]); // Release
                enemies.splice(i, 1);
                continue;
              }
            } else {
              // Top entry enemies move down
              enemy.y += enemy.speed;

              // Zigzag movement
              if (enemy.zigzag) {
                enemy.x += enemy.zigzagSpeed * enemy.zigzagDirection;
                enemy.zigzagTimer++;
                if (enemy.zigzagTimer >= enemy.zigzagInterval) {
                  enemy.zigzagTimer = 0;
                  enemy.zigzagDirection *= -1;
                }
                if (enemy.x <= 0) {
                  enemy.x = 0;
                  enemy.zigzagDirection = 1;
                } else if (enemy.x >= canvas.width - enemy.width) {
                  enemy.x = canvas.width - enemy.width;
                  enemy.zigzagDirection = -1;
                }
              }

              // Side-to-side movement
              if (enemy.sideToSide) {
                enemy.x += enemy.horizontalSpeed * enemy.horizontalDirection;
                if (enemy.x <= 0) {
                  enemy.x = 0;
                  enemy.horizontalDirection = 1;
                } else if (enemy.x >= canvas.width - enemy.width) {
                  enemy.x = canvas.width - enemy.width;
                  enemy.horizontalDirection = -1;
                }
              }
            }
          }

          if (isColliding(enemy, player)) {
            EnemyPool.release(enemies[i]); // Release
            enemies.splice(i, 1);
            playerTakeDamage(CONFIG.enemyCollisionDamage);
            if (gameOver) return;
            continue;
          }

          // Remove non-formation enemies (barriers, kamikazes) if off screen
          if (!enemy.formation && enemy.y > canvas.height) {
            EnemyPool.release(enemies[i]); // Release
            enemies.splice(i, 1);
            continue;
          }

          // Enemy shooting (level 2+)
          // Shielded enemies don't shoot
          var canShoot = level >= 2 && !enemy.shielded && !enemy.kamikaze;
          if (canShoot) {
            var now = Date.now();
            if (enemy.nextShootTime && now >= enemy.nextShootTime) {
              shootEnemyBullet(enemy);
              // Cooldown: random interval based on level
              // Purple phase: shorter gaps (more aggressive), earlier phases: slower
              var minGap = purplePhase ? 1200 : (redPhase ? 1800 : 2500);
              var maxGap = purplePhase ? 3000 : (redPhase ? 4500 : 6000);
              enemy.nextShootTime = now + minGap + Math.random() * (maxGap - minGap);
            } else if (!enemy.nextShootTime) {
              // Fallback for enemies that didn't get nextShootTime on spawn (fillers, barriers)
              var shootChance = CONFIG.enemyShootChance + (level - 2) * CONFIG.enemyShootIncrease;
              if (Math.random() < shootChance) {
                shootEnemyBullet(enemy);
              }
            }
          }
        }

        // Check wave completion
        checkWaveCompletion();

        // Spawn power-ups
        trySpawnPowerup();
      }

      // Update and draw explosion effects
      updateExplosions();

      requestAnimationFrame(draw);
    }

    // ============================================
    // GAME START
    // ============================================
    /**
     * Renders the four power-up icon previews into the intro card's small
     * `<canvas>` elements using the same shapes as the in-game pickups.
     * Called once at page load so the icons are visible before any game starts.
     */
    function drawCardPowerupIcons() {
      (function () {
        var c = document.getElementById('puHealth');
        var g = c.getContext('2d');
        var w = c.width, h = c.height;
        g.fillStyle = '#FF3333';
        g.beginPath(); g.moveTo(w / 2, 0); g.lineTo(w, h / 2); g.lineTo(w / 2, h); g.lineTo(0, h / 2); g.closePath(); g.fill();
        g.strokeStyle = '#FF0000'; g.lineWidth = 2; g.stroke();
        g.fillStyle = '#FFFFFF';
        g.fillRect(w / 2 - 2, h / 4, 4, h / 2);
        g.fillRect(w / 4, h / 2 - 2, w / 2, 4);
      })();
      (function () {
        var c = document.getElementById('puLaser');
        var g = c.getContext('2d');
        var w = c.width, h = c.height, cx = w / 2, cy = h / 2, r = w / 2 - 1;
        g.fillStyle = '#9933FF';
        g.beginPath();
        for (var i = 0; i < 6; i++) {
          var a = (Math.PI / 3) * i - Math.PI / 2;
          if (i === 0) g.moveTo(cx + r * Math.cos(a), cy + r * Math.sin(a));
          else g.lineTo(cx + r * Math.cos(a), cy + r * Math.sin(a));
        }
        g.closePath(); g.fill();
        g.strokeStyle = '#6600CC'; g.lineWidth = 2; g.stroke();
        g.fillStyle = '#FFFFFF';
        g.fillRect(cx - 7, cy - 7, 3, 14);
        g.fillRect(cx + 4, cy - 7, 3, 14);
      })();
      (function () {
        var c = document.getElementById('puShield');
        var g = c.getContext('2d');
        var w = c.width, h = c.height;
        g.fillStyle = '#00FFFF';
        g.beginPath(); g.moveTo(w / 2, 0); g.lineTo(w, h); g.lineTo(0, h); g.closePath(); g.fill();
        g.strokeStyle = '#00CCCC'; g.lineWidth = 2; g.stroke();
        g.beginPath(); g.arc(w / 2, h / 2 + 5, 6, 0, Math.PI * 2);
        g.strokeStyle = '#FFFFFF'; g.lineWidth = 2; g.stroke();
      })();
      (function () {
        var c = document.getElementById('puQuad');
        var g = c.getContext('2d');
        var w = c.width, h = c.height, cx = w / 2, cy = h / 2, r = w / 2 - 1;
        g.fillStyle = '#9933FF';
        g.beginPath();
        for (var i = 0; i < 6; i++) {
          var a = (Math.PI / 3) * i - Math.PI / 2;
          if (i === 0) g.moveTo(cx + r * Math.cos(a), cy + r * Math.sin(a));
          else g.lineTo(cx + r * Math.cos(a), cy + r * Math.sin(a));
        }
        g.closePath(); g.fill();
        g.strokeStyle = '#6600CC'; g.lineWidth = 2; g.stroke();
        g.fillStyle = '#FFFFFF';
        var offsets = [-9, -3, 3, 9];
        for (var j = 0; j < 4; j++) { g.fillRect(cx + offsets[j], cy - 6, 2, 12); }
      })();
    }

    drawCardPowerupIcons();

    /**
     * Initializes the game session from the intro card.
     *
     * This function is triggered by the "Start Game" button and performs the
     * following initialization sequence:
     * 1. Preloads all sound effects to satisfy browser autoplay policies
     *    (user interaction is required to unlock Web Audio API)
     * 2. Hides the intro card and reveals the game interface
     * 3. Programmatically triggers the start button to begin gameplay
     */
    function startFromCard() {
      // Preload all sound effects to unlock browser audio context
      // (requires user interaction per browser autoplay policies)
      for (var key in sounds) {
        if (sounds[key]) {
          sounds[key].load();
        }
      }

      // Transition from intro card to active game state
      document.getElementById('introCard').style.display = 'none';
      var sb = document.getElementById('startButton');
      sb.style.display = 'block';
      sb.innerText = 'Pause';
      sb.classList.add('game-active');
      sb.click();
    }

    // â”€â”€ Start / Pause button listener â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Dual-purpose: when `gameOver` is true it fully resets and starts a new
    // game session; otherwise it toggles the pause state. All mutable game
    // state variables are explicitly reset here to avoid leftover values from
    // the previous run affecting the new session.
    var startButton = document.getElementById("startButton");
    startButton.addEventListener("click", function () {
      this.blur();

      if (gameOver) {
        // Reset game state
        stopBossMusic();
        stopCreditsMusic();
        gameOver = false;
        score = 0;
        level = 1;
        health = CONFIG.startingHealth;
        hasDoubleLaser = false;
        laserLevel = 1;
        hasShield = false;
        shieldHitsRemaining = 0;
        powerupsSpawnedThisLevel = { health: false, doubleLaser: false, shield: false };
        lastPowerupSpawnTime = 0;
        playerBlinking = false;
        playerVisible = true;
        touchActive = false;
        touchShootActive = false;
        bossActive = false;
        bossDefeated = false;
        boss = null;
        bossBlinking = false;
        bossVisible = true;

        // Reset phase tracking
        currentBoss = 0;
        boss1Defeated = false;
        boss2Defeated = false;
        boss3Defeated = false;
        redPhase = false;
        redPhaseStartScore = 0;
        purplePhase = false;
        purplePhaseStartScore = 0;

        // Reset wave state
        currentWave = 0;
        waveEnemiesRemaining = 0;
        waveInProgress = false;
        waveCooldown = false;
        lastWaveEndTime = 0;
        morphStartTime = 0;
        currentMorphShape = 0;
        formationRotation = 0;
        targetFormationRotation = 0;
        lastMorphTime = 0;
        morphCount = 0;
        barrierSpawned = false;
        barrierEnemies = [];
        pendingKamikazeCount = 0;
        kamikazesLaunched = false;
        kamikazeCenterY = -80;
        kamikazeCenterActive = false;
        formationEntered = false;
        formationCurrentCenterY = -200;
        shieldCascadeStarted = false;
        shieldCascadeTime = 0;
        shieldsDropped = 0;
        allShieldsDown = false;
        shieldRegenTime = 0;

        player.x = canvas.width / 2;
        player.y = canvas.height - PLAYER_START_Y_OFFSET;
        player.width = PLAYER_SPRITE_W;
        player.height = PLAYER_SPRITE_H;
        enemies = [];
        playerBullets = [];
        enemyBullets = [];
        powerups = [];
        explosions = [];
        bossMinions = [];
        bossOrbiters = [];
        orbitersInitialized = false;
        lastOrbiterDeathTime = 0;
        lastBossFillerBeat = 0;

        // Update UI
        updateUI();
        document.getElementById("levelDisplay").style.display = "none";
        document.getElementById("powerupDisplay").style.display = "none";
        document.getElementById("bonusDisplay").style.display = "none";
        document.getElementById("warningDisplay").style.display = "none";
        document.getElementById("pauseDisplay").style.display = "none";
        document.getElementById("gameOver").style.display = "none";
        document.getElementById("victory").style.display = "none";
        paused = false;


        // Change button to Pause and move to corner on mobile
        startButton.innerText = "Pause";
        startButton.classList.add('game-active');

        // Track game start with A/B group, platform and music variant
        fireEvent('game_start', {
          'ab_music_group': userABGroup,
          'platform': 'mobile',
          'music_variant': localStorage.getItem('nonex_music') !== 'off' ? 'on' : 'off'
        });

        // Increment game play counter for survey trigger
        var gameCount = parseInt(localStorage.getItem('nonx_game_count') || '0', 10) + 1;
        localStorage.setItem('nonx_game_count', String(gameCount));

        // Level Display
        showAnnouncement("levelDisplay", "Level 1", 2000);
        startBackgroundMusic();
        draw();
      } else {
        // Game is running - toggle pause
        paused = !paused;
        document.getElementById("pauseDisplay").style.display = paused ? "block" : "none";
        startButton.innerText = paused ? "Resume" : "Pause";
        if (paused) {
          bgMusic.pause();
        } else {
          bgMusic.play();
        }
      }
    });

    // â”€â”€ Mute button listener â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    var muteButton = document.getElementById("muteButton");
    muteButton.addEventListener("click", function () {
      this.blur();
      toggleMusic();
    });
  </script>
</body>

</html>